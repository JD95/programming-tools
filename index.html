<!doctype html>
<html lang="en">
<head>
<title>Programming Tools</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="generator" content="Org-mode">
<meta name="author" content="Jeffrey Dwyer">

<link  href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>
<style type="text/css">
/* org mode styles on top of twbs */

html {
    position: relative;
    min-height: 100%;
}

body {
    font-size: 18px;
    margin-bottom: 105px;
}

footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 101px;
    background-color: #f5f5f5;
}

footer > div {
    padding: 10px;
}

footer p {
    margin: 0 0 5px;
    text-align: center;
    font-size: 16px;
}

#table-of-contents {
    margin-top: 20px;
    margin-bottom: 20px;
}

blockquote p {
    font-size: 18px;
}

pre {
    font-size: 16px;
}

.footpara {
    display: inline-block;
}

figcaption {
  font-size: 16px;
  color: #666;
  font-style: italic;
  padding-bottom: 15px;
}

/* from twbs docs */

.bs-docs-sidebar.affix {
    position: static;
}
@media (min-width: 768px) {
    .bs-docs-sidebar {
        padding-left: 20px;
    }
}

/* All levels of nav */
.bs-docs-sidebar .nav > li > a {
    display: block;
    padding: 4px 20px;
    font-size: 14px;
    font-weight: 500;
    color: #999;
}
.bs-docs-sidebar .nav > li > a:hover,
.bs-docs-sidebar .nav > li > a:focus {
    padding-left: 19px;
    color: #A1283B;
    text-decoration: none;
    background-color: transparent;
    border-left: 1px solid #A1283B;
}
.bs-docs-sidebar .nav > .active > a,
.bs-docs-sidebar .nav > .active:hover > a,
.bs-docs-sidebar .nav > .active:focus > a {
    padding-left: 18px;
    font-weight: bold;
    color: #A1283B;
    background-color: transparent;
    border-left: 2px solid #A1283B;
}

/* Nav: second level (shown on .active) */
.bs-docs-sidebar .nav .nav {
    display: none; /* Hide by default, but at >768px, show it */
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 30px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav > li > a:focus {
    padding-left: 29px;
}
.bs-docs-sidebar .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav > .active:focus > a {
    padding-left: 28px;
    font-weight: 500;
}

/* Nav: third level (shown on .active) */
.bs-docs-sidebar .nav .nav .nav {
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 40px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav .nav > li > a:focus {
    padding-left: 39px;
}
.bs-docs-sidebar .nav .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav .nav > .active:focus > a {
    padding-left: 38px;
    font-weight: 500;
}

/* Show and affix the side nav when space allows it */
@media (min-width: 992px) {
    .bs-docs-sidebar .nav > .active > ul {
        display: block;
    }
    /* Widen the fixed sidebar */
    .bs-docs-sidebar.affix,
    .bs-docs-sidebar.affix-bottom {
        width: 213px;
    }
    .bs-docs-sidebar.affix {
        position: fixed; /* Undo the static from mobile first approach */
        top: 20px;
    }
    .bs-docs-sidebar.affix-bottom {
        position: absolute; /* Undo the static from mobile first approach */
    }
    .bs-docs-sidebar.affix .bs-docs-sidenav,.bs-docs-sidebar.affix-bottom .bs-docs-sidenav {
        margin-top: 0;
        margin-bottom: 0
    }
}
@media (min-width: 1200px) {
    /* Widen the fixed sidebar again */
    .bs-docs-sidebar.affix-bottom,
    .bs-docs-sidebar.affix {
        width: 263px;
    }
}
</style>
<style>body { margin-bottom: 0px; }</style><script type="text/javascript">
$(function() {
    'use strict';

    $('.bs-docs-sidebar li').first().addClass('active');

    $(document.body).scrollspy({target: '.bs-docs-sidebar'});

    $('.bs-docs-sidebar').affix();
});
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  displayAlign: "center",
  displayIndent: "2em",
  messageStyle: "none",
  "HTML-CSS": {
    scale: 100,
    styles: {
      ".MathJax_Display": {
        "font-size": "100%"
      }
    }
  },
  "SVG": {
    scale: 100,
    styles: {
      ".MathJax_SVG_Display": {
        "font-size": "100%",
        "margin-left": "-2.281em"
      }
    }
  }
});
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG"></script>
</head>
<body>
<div id="content" class="container">
<div class="row"><div class="col-md-9"><h1 class="title">Programming Tools</h1>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Representing Data</h2>
<div class="outline-text-2" id="text-1">
<p>
Programming is the process of breaking down problems into pieces that a computer can understand. The most challenging aspect of this process is changing the way we thinking about problems and, on a more philosophical note, the world around us. Computers have no concept of what a tree is or how to render a webpage until we as the programmers define what these terms mean. In many ways, this is similar to translating from your native language into another, more formal, one.
</p>

<p>
At its most basic level, programming can be summed up in two questions: how can we represent the problem's nouns and how can we represent the problem's verbs? Nouns tell us <b>what</b> we're working with. Verbs tell us <b>what to do</b> with the nouns or how to make them.
</p>

<p>
More generally, there are quite a few useful similarities between langauge and programming:
</p>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">language</th>
<th scope="col" class="text-left">programming</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">noun</td>
<td class="text-left">data</td>
</tr>

<tr>
<td class="text-left">verb</td>
<td class="text-left">function</td>
</tr>

<tr>
<td class="text-left">adverb</td>
<td class="text-left">higher order function</td>
</tr>

<tr>
<td class="text-left">pronoun</td>
<td class="text-left">object</td>
</tr>

<tr>
<td class="text-left">adjective</td>
<td class="text-left">interface</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Constants</h3>
<div class="outline-text-3" id="text-1-1">
<p>
In programming nouns can take several forms depending on how much you know about the noun beforehand. If a value already known ahead of time, it can be represented with a constant. Constants are specific values like the number <code>5</code> or the word <code>"Hello"</code>. These are directly stated as part of the program and are the most constrained form of a noun.
</p>

<p>
Most programming languages, including C++, categorize different values in the following way:
</p>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">real world</th>
<th scope="col" class="text-left">C++ type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">numbers</td>
<td class="text-left">int</td>
</tr>

<tr>
<td class="text-left">decimals</td>
<td class="text-left">float</td>
</tr>

<tr>
<td class="text-left">letters</td>
<td class="text-left">char</td>
</tr>

<tr>
<td class="text-left">text/words</td>
<td class="text-left">string</td>
</tr>
</tbody>
</table>

<p>
Each of these different categories of values are called a <code>Type</code>. Types help tell the program what can and cannot be done with certain values. It wouldn't make sense for a person to try and send a text message with a bicycle and we'd like the same to be true in our programs as well. The four types listed above are not the only types we can work with while programming, but they are some the most primitive. All other types are combinations of these four types.
</p>

<p>
The first of these types <code>int</code> represents positive and negative whole numbers and can be expressed in a program like this:
</p>

<div class="org-src-container">

<pre class="src src-cpp">0
-1
4
239458459823459246
-123493952395923592359
</pre>
</div>

<p>
<code>int</code> values are great for counting things or representing amounts. A few examples of real world <code>int</code> values are: ages, years, stars in a movie review, students in a classroom, etc.
</p>

<p>
The next category of values are <code>float</code> values. These values represent decimal numbers and can be expressed like this:
</p>

<div class="org-src-container">

<pre class="src src-cpp">0.0
.05
-1.214253235
12435.234
</pre>
</div>

<p>
<code>float</code> values are great for representing percentages, positions, fractions, etc. Concepts like height, discounts, and money can be representing with this type.
</p>

<p>
Numbers are not the only values which can be represented on a computer. Any symbol on your keyboard can be represented using the <code>char</code> type. Typically, <code>char</code> values are used to represent letters and single digits. Any symbol surrounded by single quotes is a <code>char</code>. For example:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #2aa889;">'a'</span>
<span style="color: #2aa889;">'9'</span>
<span style="color: #2aa889;">'$'</span>
<span style="color: #2aa889;">'&gt;'</span>
<span style="color: #2aa889;">':'</span>
</pre>
</div>

<p>
By grouping <code>char</code> values together we can make a <code>string</code>. The <code>string</code> type allows us to represent any amount of text within our programs. Names, addresses, dates, etc. are typically represented using this type. You can express a <code>string</code> by wrapping the text in double quotes like so:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #2aa889;">"Hello there fellow humans!"</span>
<span style="color: #2aa889;">"cost: 50, tax:96%, discount:0.5"</span>
<span style="color: #2aa889;">"&lt;(-.-)&gt;  (@_o)!!!"</span>
</pre>
</div>

<p>
Strings have a special value to represent no text, otherwise known as the "empty string" or <code>""</code>. There is no space between the quotes and is the same as an empty chat dialogue box or an empty searchbar.
</p>

<p>
Programs are essentially text files which people (mostly you) will have to read. In order to make our programs as easy to understand for humans, it is often useful to give better names for the values we want to use so they better capture the real world noun they are meant to represent. For example, instead of just saying <code>int</code>, one could say <code>Age</code>.
</p>

<p>
In C++, you can tell the computer to interpet a word as a type via the <code>using</code> keyword. The term <code>keyword</code> in programming refers to words that have predefined meanings within the given programming language. These keywords cannot be redefiend by the user.
</p>

<p>
Here we can see examples of <code>using</code> usage:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">MarbleCount</span> = <span style="color: #d26937;">int</span>;
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">StudentName</span> = string;
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">Discount</span> = <span style="color: #d26937;">float</span>;
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">PlayerSymbol</span> = <span style="color: #d26937;">char</span>;
...
</pre>
</div>

<p>
There are five parts to defining our own name for a <code>type</code>. The first part is the <code>using</code> keyword which tells the program that we intend to define a new name. The second part is the name we want to use. The third part is the \(=\) sign. The fourth is the existing type which the name to the left of the \(=\) symbol will actually mean. The final bit of syntax for this kind of statement is the <code>;</code>. Any kind of statement or step in a program will end in a semi-colon.  
</p>

<p>
Note that any names you add into your program cannot have any spaces or strange symbols. The rules for new names are as follows:
</p>
<ul class="org-ul">
<li>the name <b>must</b> begin with a letter
</li>
<li>the name can only consist of letters, numbers, or the <code>_</code> symbol
</li>
</ul>

<p>
Although, these primitive types can represent quite a bit on their own, they cannot represent <b>everything</b> we might want to program. In order to represent more complicated nouns like people or places, we'll need a way to group these values together into a new type.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">definition of a struct</span>
<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Person</span> {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">age</span>;
  <span style="color: #d26937;">double</span> <span style="color: #599cab;">height</span>;
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">first_name</span>;
  <span style="color: #d26937;">char</span> <span style="color: #599cab;">middle_initial</span>;
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">last_name</span>;
  <span style="color: #d26937;">bool</span> <span style="color: #599cab;">employed</span>;
};

<span style="color: #245361;">// </span><span style="color: #245361;">creating a struct value</span>
Person {30, 5.11, <span style="color: #2aa889;">"Captain"</span>, <span style="color: #2aa889;">'J'</span>, <span style="color: #2aa889;">"Sparrow"</span>, <span style="color: #33859e; font-weight: bold;">true</span>}
</pre>
</div>

<p>
In the first section of the above code we see a new type of statement. Here the code defines a <code>struct</code> or a collection of values. The syntax for <code>struct</code> definitions are as folows:
</p>
<ul class="org-ul">
<li>the <code>struct</code> keyword
</li>
<li>the name of the new type (typically in upper case).
</li>
<li>the <code>{</code> symbol
</li>
<li>the different values in the <code>struct</code> which follow the pattern <code>type</code> then <code>name</code> ended with a <code>;</code>
</li>
<li>close the <code>{</code> with the <code>}</code> symbol
</li>
<li>semi-colon
</li>
</ul>

<p>
The names given to the values within the <code>struct</code> are there so you can access the individual parts of a struct later on.
</p>

<p>
For example, if we assumed that the name \(p\) referred to a <code>Person</code> value, we could access its members like this:
</p>

<div class="org-src-container">

<pre class="src src-cpp">p.age
p.height
p.first_name
</pre>
</div>

<p>
The dot expressions can be read as <code>p's age</code> or <code>p's first_name</code>. While the dot value <code>.age</code> could potentially refer to the age of any <code>Person</code>, it has to be paired with a particular <code>Person</code> in order to be used.
</p>

<p>
The second part of the code above defines a constant <code>Person</code> value. Constructing a value of any <code>struct</code> can be done by giving a value for each of the different members of the type. Note that the order is important, it is the same as they are defined. First the age, which is an <code>int</code>, then the hieght, which is a <code>double</code>, etc. The <code>{}</code> symbols are generally associated with groups of values and are used in both definitions and expressions.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Functions</h3>
<div class="outline-text-3" id="text-1-2">
<p>
When a value isn't known ahead of time we can express it as a <code>function</code>. Functions are both a less specific version of a constant as well as a way to represent verbs.
</p>

<p>
In maths, functions represent "mappings" from some domain into some range/co-domain. For our purposes we can think of the "domain" as the types of values that are needed to create the value we want (the co-domain). For example, addition can be thought of as a function that takes two <code>int</code> values and creates another <code>int</code> value.
</p>

<p>
\[addition(x,y) = x + y\]
</p>

<p>
In order to translate this definition into C++ we need to follow these steps:
</p>
<ul class="org-ul">
<li>determine what <code>type</code> of value you want to construct later on
</li>
<li>come up with some name for the process of making the value (the function)
</li>
<li>determine what other values might be needed and their <code>type</code>
</li>
<li>write out an expression that, given all the inputs, will construct the value you want
</li>
</ul>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">addition</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> x + y;
}
</pre>
</div>

<p>
The above code is the implementation to the earlier math expression. The first part of the definition is the <code>type</code> of the value we'll construct later once we know what the inputs are. The second part is the name of the function so we can refer to our definition later. The third part is a comma seperated list of all the input values needed to make our result. 
</p>

<p>
These parts so far make up the "signature" of the function. This indicates all the information needed to use the function we've defined. It is a good idea first design the signature before trying to come up with the expression for the next part, the implementation.
</p>

<p>
The implementation of a function is the part surrounded by the curly braces. This section of the function defines the steps needed to construct the result. When the value is constructed we indicate this by using a <code>return</code> statement.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">plus_five</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> x + 5;
}

plus_five(10)
</pre>
</div>

<p>
The above function specifices a way to construct an <code>int</code> value from another <code>int</code>. Once the value \(x\) is known, <code>plus_five</code> will construct another <code>int</code> by adding five to \(x\).
</p>

<p>
The second part uses the defined function to construct the value <code>15</code>. This is refered to as "calling" the function. Note that all which is needed to use the function is its name and a comma seperated list of the inputs.
</p>

<div class="org-src-container">

<pre class="src src-cpp">addition(1,2)
</pre>
</div>

<p>
The above uses our previous defition of addition to construct <code>3</code>. The useful thing about functions is that they can work with data that doesn't exist until the program actual runs.
</p>

<p>
Functions are needed when certain values aren't known ahead of time. These unknown values become the inputs to the functions and the process of constructing these values are how <code>verbs</code> are represented in programming. All programs do is construct new values out of other values. For example, games construct images at 60 fps from values like player health, position, camera angles, etc. Many tasks within programming are similar and by defining more abstract expressions with functions we can end up reusing those definitions.
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> templates</h3>
<div class="outline-text-3" id="text-1-3">
<p>
The final level of abstraction in C++ can be achieved with <code>templates</code>. These kinds of values are needed when nothing is known about a value except that you need a value. This allows for the definition of very abstract concepts like a pair.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">B</span>&gt;
<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Pair</span> {
  <span style="color: #d26937;">A</span> <span style="color: #599cab;">first</span>;
  <span style="color: #d26937;">B</span> <span style="color: #599cab;">second</span>;
};

<span style="color: #195466; font-weight: bold;">template</span>&lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>&gt;
<span style="color: #d26937;">T</span> <span style="color: #599cab;">add_pair</span>(<span style="color: #d26937;">Pair</span>&lt;<span style="color: #d26937;">T</span>&gt; <span style="color: #599cab;">p</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> p.first + p.second;
}

</pre>
</div>

<p>
<code>template</code> values can be thought of as functions which take a <code>type</code> and return other <code>types</code>. In the above code we define a struct <code>Pair</code> which can hold a pair of <b>any</b> two types.
</p>

<p>
There are three parts to a template definition:
</p>
<ul class="org-ul">
<li>the keyword <code>template</code>
</li>
<li>a comma seperated list of <code>types</code>, with each of the types preceeded by the keyword <code>typename</code>
</li>
<li>the definition that uses the input types
</li>
</ul>

<p>
Templates are often used to define either very abstract concepts or used to make tools for programmers. Most programming languages will have a collection of templated functions and types which save the programmer time by defining concepts beforehand. For example, the <code>string</code> type in C++ is actually provided by a library.
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Summary</h3>
<div class="outline-text-3" id="text-1-4">
<p>
The first part of programming is determing how to break down a problem and then deciding how to represent the pieces. Any values which are known ahead of time can be defined with a constant. Any values which can't be constructed until other values are known (possibly when the program is run) can be defined by functions. Any values for which not even the <code>type</code> is known ahead of time can be defined by <code>templates</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Math Tools</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> basic math functions</h3>
<div class="outline-text-3" id="text-2-1">
<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">function</th>
<th scope="col" class="text-left">meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">+</td>
<td class="text-left">addition</td>
</tr>

<tr>
<td class="text-left">-</td>
<td class="text-left">subtraction</td>
</tr>

<tr>
<td class="text-left"><code>*</code></td>
<td class="text-left">multiplication</td>
</tr>

<tr>
<td class="text-left"><code>/</code></td>
<td class="text-left">division</td>
</tr>

<tr>
<td class="text-left">%</td>
<td class="text-left">modulus</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>note that the word "operator" might show up in the place of function at some point.
</li>
<li>an operator is just a function with a funny symbol instead of a word for a name.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> char math</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>remember that characters are represented as numbers in an ascii table
</li>
<li>every value of <code>char</code> is a number that corresponds to a symbol
</li>
<li>because <code>char</code> values are secretly numbers, you can actually do math with them
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">This converts a character letter (between 'A-Z') to its lower case</span>
<span style="color: #245361;">// </span><span style="color: #245361;">version by adding the difference between 'a' and 'A' since the number</span>
<span style="color: #245361;">// </span><span style="color: #245361;">for 'a' is greater than for 'A'</span>
<span style="color: #d26937;">char</span> <span style="color: #599cab;">lower_case</span>(<span style="color: #d26937;">char</span> <span style="color: #599cab;">c</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> c + (<span style="color: #2aa889;">'a'</span> - <span style="color: #2aa889;">'A'</span>);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> string math</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>strings can be combined using <code>+</code>
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">combine("pop", "tart") would return "poptart"</span>
<span style="color: #d26937;">string</span> <span style="color: #599cab;">combine</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">first</span>, <span style="color: #d26937;">string</span> <span style="color: #599cab;">second</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> first + second;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> String Tools</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> find length of string</h3>
<div class="outline-text-3" id="text-3-1">
<p>
get the length
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">get_length</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> s.length();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> accessing parts of a string</h3>
<div class="outline-text-3" id="text-3-2">
</div><div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> front</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
gets the first character
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">get_first("hello") returns 'h'</span>
<span style="color: #d26937;">char</span> <span style="color: #599cab;">get_first</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> s.front();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> back</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
gets the last character
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">get_last("hello") returns 'o'</span>
<span style="color: #d26937;">char</span> <span style="color: #599cab;">get_last</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> s.back();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3"><span class="section-number-4">3.2.3</span> at</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
gets the character at a certain spot
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">get_at(1, "hello") returns 'e'</span>
<span style="color: #245361;">// </span><span style="color: #245361;">get_at(0, "hello") = get_front("hello")</span>
<span style="color: #245361;">// </span><span style="color: #245361;">get_at(4, "hello") = get_last("hello")</span>
<span style="color: #d26937;">char</span> <span style="color: #599cab;">get_at</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">spot</span>, <span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> s.at(spot);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2-4" class="outline-4">
<h4 id="sec-3-2-4"><span class="section-number-4">3.2.4</span> substr</h4>
<div class="outline-text-4" id="text-3-2-4">
<p>
gets the characters between some starting and ending spot
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">get_substr(1,4, "hello") returns "ello"</span>
<span style="color: #d26937;">string</span> <span style="color: #599cab;">get_substr</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">begin</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">end</span>, <span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> s.substr(begin, end);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> modifying a string</h3>
<div class="outline-text-3" id="text-3-3">
</div><div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1"><span class="section-number-4">3.3.1</span> insert</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
adds a character(s) into a string at a certain spot
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">insert_word("hello", 4, " world") returns "hello world"</span>
<span style="color: #245361;">// </span><span style="color: #245361;">insert_word(" really", 1, "I love cookies") returns "I really love cookies"</span>
<span style="color: #d26937;">string</span> <span style="color: #599cab;">insert_word</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">word</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">at</span>, <span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> s.insert(at, word);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2"><span class="section-number-4">3.3.2</span> erase</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
removes a character(s) at a certain spot
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">remove_word(2, 6, "I don't love cookies") returns "I love cookies"</span>
<span style="color: #d26937;">string</span> <span style="color: #599cab;">remove_word</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">at</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">length</span>, <span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> s.erase(at, length);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> searching a string</h3>
<div class="outline-text-3" id="text-3-4">
<p>
finds first occurence of substring
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">find_cake("Hello cake") returns 6</span>
<span style="color: #245361;">// </span><span style="color: #245361;">find_cake("hello friendo") returns -1</span>
<span style="color: #d26937;">int</span> <span style="color: #599cab;">find_cake</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> s.find(<span style="color: #2aa889;">"cake"</span>);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Choice and Decision Tools</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> how to make a decision?</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>empty the bag if it is full
</li>
<li>take the cake out of the oven when the timer is done
</li>
<li>bring me the biggest pumpkin 
</li>
<li>does this test belong to me?
</li>
<li>is this my car?
</li>
</ul>
</div>

<div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> a new type!</h4>
<div class="outline-text-4" id="text-4-1-1">
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #599cab;">bool</span> <span style="color: #599cab;">=</span> true <span style="color: #599cab;">|</span> false
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> some new combinators!</h4>
<div class="outline-text-4" id="text-4-1-2">
<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">meaning</th>
<th scope="col" class="text-left">operator</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">less than</td>
<td class="text-left">&lt;</td>
</tr>

<tr>
<td class="text-left">greater than</td>
<td class="text-left">&gt;</td>
</tr>

<tr>
<td class="text-left">equal to</td>
<td class="text-left">==</td>
</tr>

<tr>
<td class="text-left">less than or equal to</td>
<td class="text-left">&lt;=</td>
</tr>

<tr>
<td class="text-left">greater than or equal to</td>
<td class="text-left">&gt;=</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-4-1-3" class="outline-4">
<h4 id="sec-4-1-3"><span class="section-number-4">4.1.3</span> useful logic functions</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
not = !
or  = ||
and = &amp;&amp;
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> using comparisons to change result of function</h3>
<div class="outline-text-3" id="text-4-2">
</div><div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1"><span class="section-number-4">4.2.1</span> the ternary operator</h4>
<div class="outline-text-4" id="text-4-2-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">breaking up the problem doesn't help</span>
<span style="color: #d26937;">int</span> <span style="color: #599cab;">add_if_even_and_divisible_by_three</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">input</span>){
  <span style="color: #195466; font-weight: bold;">return</span> (even(input) &amp;&amp; divisible_by_three(input)) ? input + 5 : input;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-2" class="outline-4">
<h4 id="sec-4-2-2"><span class="section-number-4">4.2.2</span> reading the ternary operator</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
condition ? value1 : value2
</p>

<ul class="org-ul">
<li>evaluate the condition before <code>?</code> 
</li>
<li>if it evaluates to true, then value1 is the answer
</li>
<li>otherwise value2 is the answer
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Variables and Scope</h2>
<div class="outline-text-2" id="text-5">
<p>
We need to understand how C++ goes about representing the values which are passed back and forth between functions.
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> A Name and a Box</h3>
<div class="outline-text-3" id="text-5-1">
<p>
In mathematics, a variable is simply a name for a value which has not been given yet.
</p>

<p>
Examples:
</p>
<ul class="org-ul">
<li>area of circle: \[area(r) = \pi r^2\]
</li>
<li>area of triangle: \[area(b,h) = \frac{1}{2} bh\]
</li>
<li>line formula: \[y(m,x,b) = mx + b\]
</li>
</ul>

<p>
In all of these examples, the names \(x\), \(r\), \(b\), etc. are all placeholders which are swapped out when the values are eventually known. Functions are simply names for expressions and can be swapped out with their definitions. While this method is simple for humans to understand and work with, it is inefficent for a computer to perfectly emulate.
</p>

<p>
On a computer, a variable is name which refers to a box holding a value of some type.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 5;
</pre>
</div>


<figure>
<p><img src="./images/variables-and-scope/variable-with-type-with-value.png" class="img-responsive" alt="variable-with-type-with-value.png">
</p>
</figure>

<p>
There are three parts to defining a variable to work with in C++:
</p>
<ul class="org-ul">
<li>The type of the variables (int, bool, float, string, etc.)
</li>
<li>The name of the variable
</li>
<li>The value in the box (must match the type)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> The auto Keyword</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Writing out the types can be annoying (sometimes impossible). An alternative to explicitly writing out the type for a variable is to use the keyword <code>auto</code> in place of the actual type.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">MySuperLongAnnoyingNameForMyType</span> {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">thing1</span>;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">thing2</span>;
};

<span style="color: #d26937;">MySuperLongAnnoyingNameForMyType</span> <span style="color: #599cab;">add_numbers</span>(...) { ... } 

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">x</span> = 5;
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">word</span> = <span style="color: #33859e; font-weight: bold;">true</span>;
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">result</span> = add_numbers(...);
  ...
}
</pre>
</div>

<p>
In the above example, the function <code>add_numbers</code> returns a <code>MySuperLongAnnoyingNameForMyType</code>. Instead of having to write out the type for the variable, <code>auto</code> will tell C++ to look at the return type of <code>add_numbers</code> to figure out what the type of <code>result</code> is. 
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Assignment</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Unlike in maths, once the box has been filled with a value it can be changed as many times as we want.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 5;
cout &lt;&lt; <span style="color: #2aa889;">"before: "</span> &lt;&lt; x &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
x = 6;
cout &lt;&lt; <span style="color: #2aa889;">"after: "</span> &lt;&lt; x &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
</pre>
</div>


<figure>
<p><img src="./images/variables-and-scope/assignment.png" class="img-responsive" alt="assignment.png">
</p>
</figure>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> Variables can be Assigned to Eachother</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Because the variable is a name which refers to a value, these names can be used anywhere a value of that type would have been accepted. For example, if we wanted to fill one variable's box with a value, we could use the value of another variable to fill it.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 5;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span> = 10;
x = y;
cout &lt;&lt; x &lt;&lt; <span style="color: #2aa889;">" "</span> &lt;&lt; y &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
</pre>
</div>


<figure>
<p><img src="./images/variables-and-scope/assignment-with-another-variable.png" class="img-responsive" alt="assignment-with-another-variable.png">
</p>
</figure>

<p>
Notice that after the assignment there remains two separate boxes. With normal variables, <b>assignment does not result in two names refering to the same box</b>. The contents of one box is copied into the other box. If \(y\) is assigned to \(x\), later changing \(x\) does not affect \(y\).
</p>
</div>
</div>

<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> Function Evaluation and Scope</h3>
<div class="outline-text-3" id="text-5-5">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">line</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">m</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">b</span>){
  <span style="color: #195466; font-weight: bold;">return</span> (m * x) + b;
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">m</span> = 5;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 4;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">b</span> = 3;
  cout &lt;&lt; line(m,x,b);
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
When the program is evaluated it starts from the first line of <code>main()</code> and runs the program, line by line, until it reaches the <code>return 0;</code>. Every line with a variable creates a new box which the name refers to. When a function is called, we jump to the first line of that function (in this case <code>line()</code>). New variables are created for each of the inputs and filled with the values passed in when the function was called.
</p>

<p>
What happens if the inputs to a function have the same names as existing variables? Fortunately, this isn't a problem because functions create their own <b>scope</b>.
</p>


<figure>
<p><img src="./images/variables-and-scope/line-example/line-example.png" class="img-responsive" alt="line-example.png">
</p>
</figure>

<p>
A scope can be thought of as a room. Imagine a school with multiple people who have the same name. If all of the students were looking down and they heard their name called, they would be confused as to whether it was them being called on. However, this isn't a problem if none of them are in the same room.
</p>

<p>
This is how the problem of many variables with the same name is solved. A name can only be used by one variable at a time in each scope. So long as variables are in different scopes, their names do not conflict.
</p>
</div>
</div>

<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> References</h3>
<div class="outline-text-3" id="text-5-6">
<p>
While the default for variables is for a name to refer to its own unique box, it is possible for a name to refer to an existing box.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">line</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">m</span>, <span style="color: #d26937;">int</span>&amp; <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">b</span>){
  <span style="color: #195466; font-weight: bold;">return</span> (m * x) + b;
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">m</span> = 5;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 4;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">b</span> = 3;
  cout &lt;&lt; line(m,x,b);
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>


<figure>
<p><img src="./images/variables-and-scope/line-example/line-example-reference-1.png" class="img-responsive" alt="line-example-reference-1.png">
</p>
</figure>

<p>
This means that what ever operations are done to the name \(x\) within line will also affect the box of the \(x\) inside of main.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">line</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">m</span>, <span style="color: #d26937;">int</span>&amp; <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span>&amp; <span style="color: #599cab;">b</span>){
  <span style="color: #195466; font-weight: bold;">return</span> (m * x) + b;
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">m</span> = 5;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 4;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">b</span> = 3;
  cout &lt;&lt; line(m,b,b);
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>


<figure>
<p><img src="./images/variables-and-scope/line-example/line-example-reference-2.png" class="img-responsive" alt="line-example-reference-2.png">
</p>
</figure>

<p>
If the same box is passed in for both references, the names \(x\) and \(b\) will refer to the <b>same</b> box.
</p>
</div>
</div>

<div id="outline-container-sec-5-7" class="outline-3">
<h3 id="sec-5-7"><span class="section-number-3">5.7</span> Pointers</h3>
<div class="outline-text-3" id="text-5-7">
<p>
While references can refer to existing boxes, pointers are special variables which have a box that holds <b>references</b> to other values. 
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 5;
  <span style="color: #d26937;">int</span>* <span style="color: #599cab;">y</span> = &amp;x;
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>


<figure>
<p><img src="./images/variables-and-scope/pointer-example/1.png" class="img-responsive" alt="1.png">
</p>
</figure>

<p>
Pointers cannot be used as normal variables unless they are dereferenced.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">add</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">a</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">b</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> a + b;
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 5;
  <span style="color: #d26937;">int</span>* <span style="color: #599cab;">y</span> = &amp;x;
  cout &lt;&lt; add(x, (*y));
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
Dereferencing a pointer tells C++ to "follow" the reference to the box it's pointing at. This is what happens with normal variables and references, except neither can actually change which box they are refering to.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">add</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">a</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">b</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> a + b;
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 5;
  <span style="color: #d26937;">int</span>* <span style="color: #599cab;">y</span> = &amp;x;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">z</span> = 10;
  y = &amp;z;
  cout &lt;&lt; add(x, (*y));
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>


<figure>
<p><img src="./images/variables-and-scope/pointer-example/2.png" class="img-responsive" alt="2.png">
</p>
</figure>

<p>
Pointers are needed when unknown amounts of data are created at runtime. For example, if a file is loaded into memory, the program can't know ahead of time how the contents are. If the size cannot be known ahead of time, then it is impossible to use a normal variable for it. To get around this, the memory is reserved when the file is loaded and the result is a pointer to this data.
</p>

<p>
When initially created, pointers will refer to a speciall value called <code>Null</code>. If a pointer is set to <code>Null</code> it means it does not currently refer to any existing value. If you attempt to dereference a null pointer it will cause the program to crash.
</p>
</div>
</div>

<div id="outline-container-sec-5-8" class="outline-3">
<h3 id="sec-5-8"><span class="section-number-3">5.8</span> Side effects</h3>
<div class="outline-text-3" id="text-5-8">
<p>
References and pointers are dangerous to work with given that they can manipulate values which are outside of the scope they exist in. Misuse of these tools can lead to problems that are difficult to track down <b>if</b> you can even correctly detect where the problem is happening. Pointers especially have a tendency to blow up some time after they are actually created due to the <code>Null</code> value.
</p>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">

<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">variable type</th>
<th scope="col" class="text-left">symbol</th>
<th scope="col" class="text-left">example</th>
<th scope="col" class="text-left">when to use</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">value</td>
<td class="text-left">(none)</td>
<td class="text-left">int</td>
<td class="text-left">most of the time, it is the safest option</td>
</tr>

<tr>
<td class="text-left">reference</td>
<td class="text-left">&amp;</td>
<td class="text-left">int&amp;</td>
<td class="text-left">with <b>big</b> values that are too expensive to be copied</td>
</tr>

<tr>
<td class="text-left">pointers</td>
<td class="text-left">*</td>
<td class="text-left">int*</td>
<td class="text-left">when working with data whose size is unknown beforehand</td>
</tr>
</tbody>
</table>

<p>
In modern practice, there are several alternatives to using "raw" pointers. While they will not be discussed here, you can find more information about "smart pointers" at these links:
</p>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one">https://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one</a>
</li>
<li><a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">http://en.cppreference.com/w/cpp/memory/unique_ptr</a>
</li>
<li><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">http://en.cppreference.com/w/cpp/memory/shared_ptr</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-9" class="outline-3">
<h3 id="sec-5-9"><span class="section-number-3">5.9</span> When to use Variables?</h3>
<div class="outline-text-3" id="text-5-9">
<p>
Variables can come in handy when writing functions that use the same result in more than one place.
</p>

<p>
Lets write a function that transforms names from first, middle, then last to last, first middle with a comma after the last name.
</p>
<pre class="example">
"Robert Milton Jones" -&gt; "Jones, Robert Milton"
"Tom Marvolo Riddle" -&gt; "Riddle, Tom Marvolo"
"John Jacob Jingleheimer" -&gt; "Jingleheimer, Jon Jacob"
</pre>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">name_swap</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>){
  <span style="color: #195466; font-weight: bold;">return</span> (name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length() - 1))
         .substr(
           (name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length()-1)
             .find(<span style="color: #2aa889;">' '</span>) + 1), 
           (name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length()-1))
             .length() - 1)
       + <span style="color: #2aa889;">", "</span>
       + (name.substr(0, name.find(<span style="color: #2aa889;">' '</span>) - 1))
       + <span style="color: #2aa889;">" "</span>
       + (name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length() - 1))
         .substr(
           0, 
           ((name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length() - 1))
         .find(<span style="color: #2aa889;">' '</span>) - 1))
       ;
}
</pre>
</div>
<p>
if we follow the normal algorithm, we get this disgusting mess
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">first_name</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> name.substr(0, name.find(<span style="color: #2aa889;">' '</span>) - 1);
}
<span style="color: #d26937;">string</span> <span style="color: #599cab;">middle_name</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> (name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length() - 1))
         .substr(
           0, 
           ((name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length() - 1))
         .find(<span style="color: #2aa889;">' '</span>) - 1;
}
<span style="color: #d26937;">string</span> <span style="color: #599cab;">last_name</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> (name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length() - 1))
         .substr(
           (name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length()-1)
             .find(<span style="color: #2aa889;">' '</span>) + 1), 
           (name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length()-1))
             .length() - 1);
}
<span style="color: #d26937;">string</span> <span style="color: #599cab;">name_swap</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>){
  <span style="color: #195466; font-weight: bold;">return</span> last_name(name) 
       + <span style="color: #2aa889;">", "</span>
       + first_name(name)
       + <span style="color: #2aa889;">" "</span>
       + middle_name(name);
}
</pre>
</div>
<p>
we could try making seperate functions to get each name, but that just moves the problem
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">first_name</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> name.substr(0, name.find(<span style="color: #2aa889;">' '</span>) - 1);
}
<span style="color: #d26937;">string</span> <span style="color: #599cab;">middle_last</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length() - 1);
}
<span style="color: #d26937;">string</span> <span style="color: #599cab;">middle_name</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> middle_last(name) 
         .substr(0, middle_last(name).find(<span style="color: #2aa889;">' '</span>) - 1);
}
<span style="color: #d26937;">string</span> <span style="color: #599cab;">last_name</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> middle_last(name).substr(
           middle_last(name).find(<span style="color: #2aa889;">' '</span>) + 1, 
           middle_last(name).length() - 1);
}
<span style="color: #d26937;">string</span> <span style="color: #599cab;">name_swap</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>){
  <span style="color: #195466; font-weight: bold;">return</span> last_name(name) 
       + <span style="color: #2aa889;">", "</span>
       + first_name(name)
       + <span style="color: #2aa889;">" "</span>
       + middle_name(name);
}
</pre>
</div>

<p>
If you see the same pattern more than twice, you should make a function, however it's a bit annoying to have to write out new functions in C++'s bulky syntax all the time. If these functions will never be used again, then it would be preferable to just define variables within the function to hold onto the intermediate results.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">name_swap</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>){

  <span style="color: #d26937;">string</span> <span style="color: #599cab;">first_name</span> = name.substr(0, name.find(<span style="color: #2aa889;">' '</span>) - 1);

  <span style="color: #d26937;">string</span> <span style="color: #599cab;">middle_last</span> = 
    name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length() - 1);

  <span style="color: #d26937;">string</span> <span style="color: #599cab;">middle_name</span> = 
    middle_last.substr(0, middle_last.find(<span style="color: #2aa889;">' '</span>) - 1);

  <span style="color: #d26937;">string</span> <span style="color: #599cab;">last_name</span> = 
    middle_last.substr(
       middle_last.find(<span style="color: #2aa889;">' '</span>) + 1, 
       middle_last.length() - 1);

  <span style="color: #195466; font-weight: bold;">return</span> last_name + <span style="color: #2aa889;">", "</span> + first_name + <span style="color: #2aa889;">" "</span> + middle_name; 
}
</pre>
</div>

<p>
This is safe so long as we don't change what the variables hold and if the order in which the results are used doesn't matter.
</p>
</div>
</div>

<div id="outline-container-sec-5-10" class="outline-3">
<h3 id="sec-5-10"><span class="section-number-3">5.10</span> When to not use Variables</h3>
<div class="outline-text-3" id="text-5-10">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">division</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>){
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">result</span> = x / y;
  <span style="color: #195466; font-weight: bold;">return</span> y == 0 ? <span style="color: #2aa889;">"fail!"</span> : to_string(result);
}
</pre>
</div>

<p>
In this case it is unsafe to store the result in a variable because it is calculated before the safety check! Remember that programs execute statements in order, so if \(y\) happens to be zero, it will attempt the division and crash the program before the check can catch it.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Functions as Values</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> C++ function variables</h3>
<div class="outline-text-3" id="text-6-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">add</span> = [] (<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>)  { <span style="color: #195466; font-weight: bold;">return</span>  x + y; };
</pre>
</div>


<figure>
<p><img src="./images/functions-as-values/lambda-value.png" class="img-responsive" alt="lambda-value.png">
</p>
</figure>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">add</span> = [] (<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>)  { <span style="color: #195466; font-weight: bold;">return</span>  x + y; };
<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = add(5,5);
</pre>
</div>


<figure>
<p><img src="./images/functions-as-values/lambda-no-capture-eval-1.png" class="img-responsive" alt="lambda-no-capture-eval-1.png">
</p>
</figure>


<figure>
<p><img src="./images/functions-as-values/lambda-no-capture-eval-2.png" class="img-responsive" alt="lambda-no-capture-eval-2.png">
</p>
</figure>


<figure>
<p><img src="./images/functions-as-values/lambda-no-capture-eval-3.png" class="img-responsive" alt="lambda-no-capture-eval-3.png">
</p>
</figure>


<figure>
<p><img src="./images/functions-as-values/lambda-no-capture-eval-4.png" class="img-responsive" alt="lambda-no-capture-eval-4.png">
</p>
</figure>


<figure>
<p><img src="./images/functions-as-values/lambda-no-capture-eval-5.png" class="img-responsive" alt="lambda-no-capture-eval-5.png">
</p>
</figure>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> lambda capture</h3>
<div class="outline-text-3" id="text-6-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 10;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">addX</span> = [x](<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>) { <span style="color: #195466; font-weight: bold;">return</span> x + y; };
</pre>
</div>


<figure>
<p><img src="./images/functions-as-values/lambda-capture-by-value.png" class="img-responsive" alt="lambda-capture-by-value.png">
</p>
</figure>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 10;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">addX</span> = [&amp;x](<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>) { <span style="color: #195466; font-weight: bold;">return</span> x + y; };
</pre>
</div>


<figure>
<p><img src="./images/functions-as-values/lambda-capture-by-reference.png" class="img-responsive" alt="lambda-capture-by-reference.png">
</p>
</figure>
</div>

<div id="outline-container-sec-6-2-1" class="outline-4">
<h4 id="sec-6-2-1"><span class="section-number-4">6.2.1</span> Capture Practice 1</h4>
<div class="outline-text-4" id="text-6-2-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 10;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span> = 5;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">z</span> = 22;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">f</span> = [???]() { <span style="color: #195466; font-weight: bold;">return</span> x + y + z; };
</pre>
</div>
<p>
What needs to be captured?
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 10;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span> = 5;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">z</span> = 22;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">f</span> = [x,y,z]() { <span style="color: #195466; font-weight: bold;">return</span> x + y + z; };
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-2-2" class="outline-4">
<h4 id="sec-6-2-2"><span class="section-number-4">6.2.2</span> Capture Practice 2</h4>
<div class="outline-text-4" id="text-6-2-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 10;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span> = 5;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">z</span> = 22;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">f</span> = [???](<span style="color: #d26937;">int</span> <span style="color: #599cab;">a</span>) { <span style="color: #195466; font-weight: bold;">return</span> a + y + z; };
</pre>
</div>
<p>
What needs to be captured?
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 10;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span> = 5;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">z</span> = 22;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">f</span> = [y,z](<span style="color: #d26937;">int</span> <span style="color: #599cab;">a</span>) { <span style="color: #195466; font-weight: bold;">return</span> a + y + z; };
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-2-3" class="outline-4">
<h4 id="sec-6-2-3"><span class="section-number-4">6.2.3</span> Capture Practice 3</h4>
<div class="outline-text-4" id="text-6-2-3">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 10;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span> = 5;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">z</span> = 22;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">f</span> = [???](<span style="color: #d26937;">int</span> <span style="color: #599cab;">a</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>) { <span style="color: #195466; font-weight: bold;">return</span> a + y + z; };
</pre>
</div>
<p>
What needs to be captured?
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 10;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span> = 5;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">z</span> = 22;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">f</span> = [z](<span style="color: #d26937;">int</span> <span style="color: #599cab;">a</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>) { <span style="color: #195466; font-weight: bold;">return</span> a + y + z; };
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> passing functions to other functions</h3>
<div class="outline-text-3" id="text-6-3">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;functional&gt;</span>

<span style="color: #245361;">// </span><span style="color: #245361;">the functional header is needed for the function type</span>
<span style="color: #d26937;">int</span> <span style="color: #599cab;">do_math</span>(<span style="color: #d26937;">function</span>&lt;<span style="color: #d26937;">int</span>(<span style="color: #d26937;">int</span>,<span style="color: #d26937;">int</span>)&gt; <span style="color: #599cab;">op</span>, <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">int</span>&amp; <span style="color: #599cab;">x</span>, <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">int</span>&amp; <span style="color: #599cab;">y</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> op(x,y);
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">add</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>) { <span style="color: #195466; font-weight: bold;">return</span> x + y; };

do_math(add, 7, 3); <span style="color: #245361;">// </span><span style="color: #245361;">10</span>
</pre>
</div>


<figure>
<p><img src="./images/functions-as-values/passing-functions-1.png" class="img-responsive" alt="passing-functions-1.png">
</p>
</figure>

<figure>
<p><img src="./images/functions-as-values/passing-functions-2.png" class="img-responsive" alt="passing-functions-2.png">
</p>
</figure>

<figure>
<p><img src="./images/functions-as-values/passing-functions-3.png" class="img-responsive" alt="passing-functions-3.png">
</p>
</figure>

<figure>
<p><img src="./images/functions-as-values/passing-functions-4.png" class="img-responsive" alt="passing-functions-4.png">
</p>
</figure>

<figure>
<p><img src="./images/functions-as-values/passing-functions-5.png" class="img-responsive" alt="passing-functions-5.png">
</p>
</figure>

<figure>
<p><img src="./images/functions-as-values/passing-functions-6.png" class="img-responsive" alt="passing-functions-6.png">
</p>
</figure>
</div>
</div>

<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> what are the uses of lambdas?</h3>
<div class="outline-text-3" id="text-6-4">
</div><div id="outline-container-sec-6-4-1" class="outline-4">
<h4 id="sec-6-4-1"><span class="section-number-4">6.4.1</span> less repetition in code</h4>
<div class="outline-text-4" id="text-6-4-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">Tag</span> = string;
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">HP</span> = <span style="color: #d26937;">int</span>;

<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Action</span> {
  ...
};

<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Unit</span> {
  ...
};

<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">AiUnit</span> {
  <span style="color: #d26937;">Tag</span> <span style="color: #599cab;">id</span>;
  <span style="color: #d26937;">HP</span> <span style="color: #599cab;">hp</span>;
  <span style="color: #d26937;">Unit</span>* <span style="color: #599cab;">target</span>;
  <span style="color: #d26937;">function</span>&lt;Action(<span style="color: #599cab;">Unit</span>*, <span style="color: #d26937;">HP</span>)&gt; <span style="color: #599cab;">behavior</span>;
};
</pre>
</div>

<p>
The AiUnit can have its individual behavior swapped out by simply assigning a new function
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Collections of Fixed Size</h2>
<div class="outline-text-2" id="text-7">
<p>
in C++, arrays represent fixed length collections
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">char</span> <span style="color: #599cab;">letters</span>[5] = {<span style="color: #2aa889;">'a'</span>,<span style="color: #2aa889;">'b'</span>,<span style="color: #2aa889;">'c'</span>,<span style="color: #2aa889;">'d'</span>,<span style="color: #2aa889;">'e'</span>};
</pre>
</div>


<figure>
<p><img src="./images/array-introduction/array-in-memory.png" class="img-responsive" alt="array-in-memory.png">
</p>
</figure>

<p>
Previously, if we wanted to talk about a collecction, we'd have to make a big struct
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">Age</span> = <span style="color: #d26937;">int</span>;
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">Name</span> = string;
<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Person</span> { <span style="color: #d26937;">Age</span> <span style="color: #599cab;">age</span>; <span style="color: #d26937;">Name</span> <span style="color: #599cab;">name</span>; };

<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">TeamName</span> = string;
<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Team</span> { 
  <span style="color: #d26937;">TeamName</span> <span style="color: #599cab;">name</span>; 
  <span style="color: #d26937;">Person</span> <span style="color: #599cab;">coach</span>;
  <span style="color: #d26937;">Person</span> <span style="color: #599cab;">quater_back</span>;
  <span style="color: #d26937;">Person</span> <span style="color: #599cab;">wide_reciever</span>;
  ...
};
</pre>
</div>

<p>
Now we can represent collections with arrays
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">Age</span> = <span style="color: #d26937;">int</span>;
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">Name</span> = string;
<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Person</span> { <span style="color: #d26937;">Age</span> <span style="color: #599cab;">age</span>; <span style="color: #d26937;">Name</span> <span style="color: #599cab;">name</span>; };

<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">TeamName</span> = string;
<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Team</span> { 
  <span style="color: #d26937;">TeamName</span> <span style="color: #599cab;">name</span>; 
  <span style="color: #d26937;">Person</span> <span style="color: #599cab;">captain</span>;

  <span style="color: #245361;">// </span><span style="color: #245361;">instead of having a value for each player</span>
  <span style="color: #245361;">// </span><span style="color: #245361;">use an array to represent the team</span>
  <span style="color: #d26937;">Person</span> <span style="color: #599cab;">players</span>[11];
};
</pre>
</div>
</div>

<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> accessing array elements</h3>
<div class="outline-text-3" id="text-7-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>&gt;
<span style="color: #d26937;">T</span> <span style="color: #599cab;">first_of_five</span>(<span style="color: #d26937;">T</span> <span style="color: #599cab;">stuff</span>[5]) {
  <span style="color: #195466; font-weight: bold;">return</span> stuff[0];
}

<span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>&gt;
<span style="color: #d26937;">T</span> <span style="color: #599cab;">second_of_five</span>(<span style="color: #d26937;">T</span> <span style="color: #599cab;">stuff</span>[5]) {
  <span style="color: #195466; font-weight: bold;">return</span> stuff[1];
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">numbers</span>[5] = { 1,2,3,4,5 };
first_of_five(numbers); <span style="color: #245361;">// </span><span style="color: #245361;">1</span>

<span style="color: #d26937;">int</span> <span style="color: #599cab;">truths</span>[5] = { <span style="color: #33859e; font-weight: bold;">true</span>, <span style="color: #33859e; font-weight: bold;">false</span>, <span style="color: #33859e; font-weight: bold;">true</span>, <span style="color: #33859e; font-weight: bold;">true</span>, <span style="color: #33859e; font-weight: bold;">false</span> };
second_of_five(truths); <span style="color: #245361;">// </span><span style="color: #245361;">false</span>
</pre>
</div>

<ul class="org-ul">
<li>arrays start from 0
</li>
<li>the index represents spaces from the start
</li>
</ul>


<figure>
<p><img src="./images/array-introduction/array-assignment-1.png" class="img-responsive" alt="array-assignment-1.png">
</p>
</figure>

<figure>
<p><img src="./images/array-introduction/array-assignment-2.png" class="img-responsive" alt="array-assignment-2.png">
</p>
</figure>

<figure>
<p><img src="./images/array-introduction/array-assignment-3.png" class="img-responsive" alt="array-assignment-3.png">
</p>
</figure>
</div>
</div>

<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> modifying array elements</h3>
<div class="outline-text-3" id="text-7-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">char</span> <span style="color: #599cab;">letters</span>[5] = {<span style="color: #2aa889;">'a'</span>, <span style="color: #2aa889;">'b'</span>, <span style="color: #2aa889;">'c'</span>, <span style="color: #2aa889;">'d'</span>, <span style="color: #2aa889;">'e'</span>};
<span style="color: #d26937;">int</span> <span style="color: #599cab;">i</span> = 0;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">j</span> = 3;
letters[i] = letters[j];
</pre>
</div>


<figure>
<p><img src="./images/array-introduction/modifying-array-1.png" class="img-responsive" alt="modifying-array-1.png">
</p>
</figure>

<figure>
<p><img src="./images/array-introduction/modifying-array-2.png" class="img-responsive" alt="modifying-array-2.png">
</p>
</figure>

<figure>
<p><img src="./images/array-introduction/modifying-array-3.png" class="img-responsive" alt="modifying-array-3.png">
</p>
</figure>

<figure>
<p><img src="./images/array-introduction/modifying-array-4.png" class="img-responsive" alt="modifying-array-4.png">
</p>
</figure>
</div>
</div>

<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> warning</h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li>arrays are always passed by reference
</li>
<li>there is no way to return a raw array
</li>
<li>cannot use == to compare arrays
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> Better array type</h3>
<div class="outline-text-3" id="text-7-4">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;array&gt;</span>

<span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">int</span>, 5&gt; <span style="color: #599cab;">numbers</span> = { 1,2,3,4,5 };
</pre>
</div>

<ul class="org-ul">
<li>Can return std::array from functions
</li>
<li>Has lots of nice functions like .front, .back, and works with comparison operations
</li>
</ul>

<p>
But how can we use all of the elements of a vector?
</p>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Recursion</h2>
<div class="outline-text-2" id="text-8">
<p>
There are five steps for recursion:
</p>

<ol class="org-ol">
<li>Find the "do nothing" input 
</li>
<li>Find the "do nothing" step 
</li>
<li>Break off the front
</li>
<li>Make the problem smaller
</li>
<li>Combine results
</li>
</ol>
</div>

<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> Finding the do-nothing step and input</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Although we're solving problems with steps that repeat, eventually there is a point where the problem is solved and no more work needs to be done.
</p>

<p>
Consider the problem of adding up all the numbers from some integer <b>10</b> to <b>1</b>. When written out this is what we want to happen:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum_10_to_1</span>(){
  <span style="color: #195466; font-weight: bold;">return</span> 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1;
}
</pre>
</div>

<p>
If we zoom in on the front of the problem we see something like this:
</p>

<div class="org-src-container">

<pre class="src src-cpp">10 + ...
</pre>
</div>

<p>
The integer <b>10</b> plus some other stuff. We are looking for a place where more work is needed so we'll have to go to the other end of the expression:
</p>

<div class="org-src-container">

<pre class="src src-cpp">... 1
</pre>
</div>

<p>
Here we have nothing more to add and conveniently we've also found our do-nothing input. If the problem was add all the numbers from <b>1</b> to <b>1</b>, then the result would just be <b>1</b>. Nothing happens. So how can we simulate doing nothing with additon? Well, adding 0 to any number does nothing, so in this case plus 0 is our do-nothing step.
</p>

<p>
So how can we generalize this to adding up all the numbers from some integer <b>n</b> to <b>1</b>? Well when written out we see something similar to what we had last time:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> n + (n-1) + (n-2) + ... + 1;
}
</pre>
</div>

<p>
Only, in this case, we don't know exactly how many terms we need to add up. That being said, we can see our do-nothing step has not changed. When we are uncertain of how many steps we need to actually repeat we'll have to come up with some kind of check to tell when we've reached the do-nothing step.
</p>

<p>
In this case our check could be:
</p>

<div class="org-src-container">

<pre class="src src-cpp">n == 1
</pre>
</div>

<p>
Common do-nothing inputs are:
</p>
<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">type</th>
<th scope="col" class="text-left">input</th>
<th scope="col" class="text-left">check</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">numbers</td>
<td class="text-left">0 or 1</td>
<td class="text-left">== 0</td>
</tr>

<tr>
<td class="text-left">string</td>
<td class="text-left">""</td>
<td class="text-left">== ""</td>
</tr>

<tr>
<td class="text-left">vector</td>
<td class="text-left">{}</td>
<td class="text-left">.empty()</td>
</tr>
</tbody>
</table>


<p>
Once we've established when no more work has to be done and what the result should be in that case, we can move on to actually doing some of the work.
</p>
</div>
</div>

<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> Breaking off the front</h3>
<div class="outline-text-3" id="text-8-2">
<p>
Because we cannot always know ahead of time how much work has to be done, like in the case of adding all the numbers from <b>n</b> to <b>1</b>, we need to find some way of breaking off a piece of the problem so we only need to program one step at a time.
</p>

<p>
Let's say we wanted to take some <code>string</code>, say <b>"hello"</b> and make it all captials, <b>"HELLO"</b>. This problem as it is cannot be solved using the tools we know so far, however we do know how to make a <code>char</code> upper case using <code>toupper()</code>.
</p>

<p>
In this case, breaking off the front can be taken literally, grab the first character of the <code>string</code> using <code>.front()</code>.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #599cab;">string</span>(<span style="color: #2aa889;">"hello"</span>).front()
</pre>
</div>

<p>
Now that we have a character to work with, we can simply apply <code>toupper()</code> to get the first value of our desired result <b>'H'</b>.
</p>

<div class="org-src-container">

<pre class="src src-cpp">toupper(string(<span style="color: #2aa889;">"hello"</span>).front())
</pre>
</div>

<p>
This can easily be generalized to any string by replace the literal <b>"hello"</b> with a variable, lets say <b>s</b>:
</p>

<div class="org-src-container">

<pre class="src src-cpp">toupper(s.front())
</pre>
</div>

<p>
If we return to the problem of adding numbers from <b>n</b> to <b>1</b> we can see a similar process is used, although it is not as obvious. In this case we aren't literally breaking off the front of the number, instead we are breaking off the front of the expression we want in the end:
</p>

<div class="org-src-container">

<pre class="src src-cpp">n | + (n-1) + (n-2) + ... + 1
</pre>
</div>

<p>
Here, after we break off the front we get the number <b>n</b> all by itself. Sometimes, breaking off the front doesn't have another step as with making the <b>char</b> into uppercase. This is fine because it still helps with the next step.
</p>
</div>
</div>

<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> Making the problem smaller</h3>
<div class="outline-text-3" id="text-8-3">
<p>
The trick to recursion is to solve a piece of the problem, and then make use of the results for a smaller version of the problem. We've already seen how to do the small step by breaking off the front, but we also need to figure out how to make the problem as a whole smaller.
</p>

<p>
For example, when adding up numbers after breaking off the front, we automatically get a smaller version of the problem:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">front</span> = n;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">smaller</span> = (n-1) + (n-2) + ... + 1;
  <span style="color: #195466; font-weight: bold;">return</span> front + smaller;
}
</pre>
</div>

<p>
In order to solve <code>sum(n)</code> we need to figure out how to solve <code>(n-1) + (n-2) + ...</code>, however notice that it has almost exactly the same shape as our original problem. To make this more apparent, we can give a new name to <code>(n-1)</code>.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #599cab;">step</span> 1<span style="color: #d26937;">:</span> assume sum<span style="color: #99d1ce;">(</span>x<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">=</span> x <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>x <span style="color: #599cab;">-</span> 1<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>x <span style="color: #599cab;">-</span> 2<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>x <span style="color: #599cab;">-</span> 3<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #599cab;">...</span> <span style="color: #599cab;">+</span> 1
<span style="color: #599cab;">step</span> 2<span style="color: #d26937;">:</span> given <span style="color: #99d1ce;">(</span>n <span style="color: #599cab;">-</span> 1<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>n <span style="color: #599cab;">-</span> 2<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>n <span style="color: #599cab;">-</span> 3<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #599cab;">...</span> <span style="color: #599cab;">+</span> 1
<span style="color: #599cab;">step</span> 3<span style="color: #d26937;">:</span> <span style="color: #99d1ce;">(</span>n <span style="color: #599cab;">-</span> 1<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>n <span style="color: #599cab;">-</span> 1 <span style="color: #599cab;">-</span> 1<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>n <span style="color: #599cab;">-</span> 1 <span style="color: #599cab;">-</span> 2<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #599cab;">...</span> <span style="color: #599cab;">+</span> 1
<span style="color: #599cab;">step</span> 4<span style="color: #d26937;">:</span> <span style="color: #195466; font-weight: bold;">let</span> m <span style="color: #599cab;">=</span> n <span style="color: #599cab;">-</span> 1
<span style="color: #599cab;">step</span> 5<span style="color: #d26937;">:</span> m <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>m <span style="color: #599cab;">-</span> 1<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>m <span style="color: #599cab;">-</span> 2<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>m <span style="color: #599cab;">-</span> 3<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #599cab;">...</span> <span style="color: #599cab;">+</span> 1
<span style="color: #599cab;">step</span> 6<span style="color: #d26937;">:</span> using step 1 <span style="color: #599cab;">=&gt;</span> sum<span style="color: #99d1ce;">(</span>m<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">=</span> m <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>m <span style="color: #599cab;">-</span> 1<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>m <span style="color: #599cab;">-</span> 2<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>m <span style="color: #599cab;">-</span> 3<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #599cab;">...</span> <span style="color: #599cab;">+</span> 1
<span style="color: #599cab;">step</span> 7<span style="color: #d26937;">:</span> using step 4 <span style="color: #599cab;">=&gt;</span> sum<span style="color: #99d1ce;">(</span>m<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">=</span> sum<span style="color: #99d1ce;">(</span>n<span style="color: #599cab;">-</span>1<span style="color: #99d1ce;">)</span>
</pre>
</div>

<p>
If we replace <code>(n-1)</code> with <code>m</code> we can see that our smaller problem has exactly the same shape as our orignal problem! Which means if the solution to <code>n + (n-1) + (n-2) + ... + 1</code> is <code>sum(n)</code> then the solution to <code>(n-1) + (n-2) + (n-3) + ... + 1</code> should be <code>sum(n-1)</code>.
</p>

<p>
<b>This</b> is the key to recursion! Because the steps we need to do are repeated, a smaller version of the problem can be solved in <b>exactly</b> the same way. So the solution of <code>(n-1) + (n-2) + ...</code> is simply <code>sum(n-1)</code>!
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">front</span> = n;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">smaller</span> = sum(n-1);
  <span style="color: #195466; font-weight: bold;">return</span> front + smaller;
}
</pre>
</div>

<p>
However, there is a problem if we stop here. Notice that happens if we do <code>sum(1)</code>, our do-nothing input from before:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(1) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">front</span> = 1;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">smaller</span> = sum(1-1);
  <span style="color: #195466; font-weight: bold;">return</span> front + smaller;
}
</pre>
</div>

<p>
What is the result of <code>sum(0)</code>? We could plug in <b>0</b> for <b>n</b> and find out:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(0) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">front</span> = 0;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">smaller</span> = sum(0-1);
  <span style="color: #195466; font-weight: bold;">return</span> front + smaller;
}
</pre>
</div>

<p>
This isn't good. The smaller version of the problem keeps dropping off towards negative infinity. Instead of getting <code>... + 3 + 2 + 1</code> we get <code>... + 3 + 2 + 1 + 0 + -1 + -2 + ...</code>. Luckily we already figured out how to check for when we've hit the do-nothing step and we can simply use <code>?:</code> to either return our 0 to make it <code>n+1</code> (our do-nothing step) or our smaller version of the problem.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">front</span> = n;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">smaller</span> = n &lt;= 1 ? 0 : sum(n-1);
  <span style="color: #195466; font-weight: bold;">return</span> front + smaller;
}
</pre>
</div>

<p>
Now our function will stop when we reach the do nothing case and simply return our do-nothing input! Conveniently for <code>sum</code> our combine step is obvious, we just need to add our front to our smaller version of the problem, however this isn't always so obvious.
</p>

<p>
Let's go back to the problem of capitalizing the letters of a string.
</p>

<p>
First we have to find the do-nothing step and input. Unlike numbers, the end of work isn't as clear, but think about it, what is the "zero" value of a string? It's the empty string "", the string with no characters in it. This makes sense because when we broke off the front for <b>"hello"</b> we got a character, and we cannot break off the front for <b>""</b> so that must be our do-nothing input.
</p>

<p>
Knowing this, we can start to fill in the function:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>){
  <span style="color: #d26937;">char</span> <span style="color: #599cab;">front</span> = toupper(s.front());
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = s == <span style="color: #2aa889;">""</span> ? <span style="color: #2aa889;">""</span> : all_caps(A?);
  <span style="color: #195466; font-weight: bold;">return</span> B?;
}
</pre>
</div>

<p>
First, we need to fill hole <code>A?</code>. To do this we need to do the inverse of our breaking off the front step. Instead of trying to grab the first character from the string, we need all the character after the front. In otherwords we need the substring of <code>s</code> from position 1 to the end:
</p>

<div class="org-src-container">

<pre class="src src-cpp">s.substr(1, s.length()-1)
</pre>
</div>

<p>
However, there is a problem. What happens if our string is only one character long? For example, in the string <code>"A"</code>, there is no position <b>1</b> and substr would crash our program trying to grab a character that doesn't exist. Moreover, if <b>s</b> is the empty string, then <b>.front()</b> will crash the program as well! This means we'll have to adjust what our do-nothing input is. Since we have to stop when there is only one character left, we can simply adjust our check to test for a string of at most length <b>1</b>.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>){
  <span style="color: #d26937;">char</span> <span style="color: #599cab;">front</span> = toupper(s.front());
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = s.length() &lt;= 1 ? <span style="color: #2aa889;">""</span> : all_caps(s.substr(1, s.length()-1));
  <span style="color: #195466; font-weight: bold;">return</span> B?;
}
</pre>
</div>

<p>
We can test this by simulating several strings: 
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #2aa889;">"hi"</span>){
  <span style="color: #d26937;">char</span> <span style="color: #599cab;">front</span> = toupper(<span style="color: #2aa889;">"hi"</span>.front());
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = <span style="color: #2aa889;">"hi"</span>.length() &lt;= 1 ? <span style="color: #2aa889;">""</span> : all_caps(<span style="color: #2aa889;">"hi"</span>.substr(1, <span style="color: #2aa889;">"hi"</span>.length()-1));
  <span style="color: #195466; font-weight: bold;">return</span> B?;
}

<span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #2aa889;">"hi"</span>){
  <span style="color: #d26937;">char</span> <span style="color: #599cab;">front</span> = <span style="color: #2aa889;">'H'</span>;
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = <span style="color: #33859e; font-weight: bold;">false</span> ? <span style="color: #2aa889;">""</span> : all_caps(<span style="color: #2aa889;">"i"</span>);
  <span style="color: #195466; font-weight: bold;">return</span> B?;
}
</pre>
</div>

<p>
Strings greater than one seem to work!
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #2aa889;">"A"</span>){
  <span style="color: #d26937;">char</span> <span style="color: #599cab;">front</span> = toupper(<span style="color: #2aa889;">"A"</span>.front());
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = <span style="color: #2aa889;">"A"</span>.length() &lt;= 1 ? <span style="color: #2aa889;">""</span> : all_caps(<span style="color: #2aa889;">"A"</span>.substr(1, <span style="color: #2aa889;">"A"</span>.length()-1));
  <span style="color: #195466; font-weight: bold;">return</span> B?;
}

<span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #2aa889;">"A"</span>){
  <span style="color: #d26937;">char</span> <span style="color: #599cab;">front</span> = <span style="color: #2aa889;">'A'</span>;
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = <span style="color: #33859e; font-weight: bold;">true</span> ? <span style="color: #2aa889;">""</span> : all_caps(...);
  <span style="color: #195466; font-weight: bold;">return</span> B?;
}
</pre>
</div>

<p>
Strings of size one work! Now we just have to fill in the hole B?.
</p>
</div>
</div>

<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> Combining Results</h3>
<div class="outline-text-3" id="text-8-4">
<p>
How can we combine a <b>char</b> value with a <b>string</b>? You can't, but converting a <b>char</b> into a <b>string</b> is straightforward. Just wrap the character with <code>string(1, ...)</code>. This will construct a new string with length <b>1</b> using the provided character.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>){
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">front</span> = string(1, toupper(s.front()));
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = s.length() &lt;= 1 ? s : all_caps(s.substr(1, s.length()-1));
  <span style="color: #195466; font-weight: bold;">return</span> B?;
}
</pre>
</div>

<p>
Now that we have two strings we can simply add them together!
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>){
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">front</span> = string(1, toupper(s.front()));
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = s.length() &lt;= 1 ? s : all_caps(s.substr(1, s.length()-1));
  <span style="color: #195466; font-weight: bold;">return</span> front + smaller;
}
</pre>
</div>

<p>
This looks like the correct answer, but just to be safe, lets test it with the empty string <code>""</code>.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #2aa889;">""</span>){
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">front</span> = string(1, toupper(<span style="color: #2aa889;">""</span>.front()));
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = <span style="color: #2aa889;">""</span>.length() &lt;= 1 ? <span style="color: #2aa889;">""</span> : all_caps(<span style="color: #2aa889;">""</span>.substr(1, <span style="color: #2aa889;">""</span>.length()-1));
  <span style="color: #195466; font-weight: bold;">return</span> front + smaller;
}

<span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #2aa889;">""</span>){
  <span style="color: #d26937;">char</span> <span style="color: #599cab;">front</span> = toupper(<span style="color: #2aa889;">""</span>.front());
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = <span style="color: #2aa889;">""</span>.length() &lt;= 1 ? <span style="color: #2aa889;">""</span> : all_caps(<span style="color: #2aa889;">""</span>.substr(1, <span style="color: #2aa889;">""</span>.length()-1));
  <span style="color: #195466; font-weight: bold;">return</span> front + smaller;
}

...
</pre>
</div>

<p>
Hopefully you've already spotted the problem. <code>"".front()</code> will crash the program, even though we have a check for strings of length <b>1</b> in the smaller step. This isn't world ending, but it means we can't separate the <b>front</b> and <b>smaller</b> values into variables for ease of reading and we'll have to change our do-nothing step.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>){
  <span style="color: #195466; font-weight: bold;">return</span> s.length() &lt;= 1 ? <span style="color: #2aa889;">""</span> : 
    (string(1, toupper(s.front())) + all_caps(s.substr(1, s.length()-1)));
}
</pre>
</div>

<p>
If we simply move the values from variables directly into the <code>return</code>, we'll accidentally drop the last character of the string. If the input is a string of length <b>1</b> it will return <code>""</code> and not the upper case version of it that we want. To solve this, we'll change the <b>false</b> path of the choice into a duplicate of the front.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>){
  <span style="color: #195466; font-weight: bold;">return</span> s.length() &lt;= 1 ? string(1, toupper(s.front())) : 
    (string(1, toupper(s.front())) + all_caps(s.substr(1, s.length()-1)));
}
</pre>
</div>

<p>
But this is ugly, we've duplicated code, <b>and</b> we've reintroduced the problem of calling <code>.front()</code> on an empty string, so lets pull out the step of converting a character into an uppercase string into an on-the-spot function.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>){
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">f</span> = [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">x</span>) { 
    <span style="color: #195466; font-weight: bold;">return</span> string(1, toupper(x.front())); 
  };
  <span style="color: #195466; font-weight: bold;">return</span> s.length() &lt;= 1 ? f(s) : 
    (f(s) + all_caps(s.substr(1, s.length()-1)));
}
</pre>
</div>

<p>
Now that we've pulled out that step, we can add a check in <b>f</b> to make sure we don't call <code>.front()</code> on an empty string.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>){
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">f</span> = [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">x</span>) { 
    <span style="color: #195466; font-weight: bold;">return</span> x == <span style="color: #2aa889;">""</span> ? <span style="color: #2aa889;">""</span> : string(1, toupper(x.front())); 
  };
  <span style="color: #195466; font-weight: bold;">return</span> s.length() &lt;= 1 ? f(s) : 
    (f(s) + all_caps(s.substr(1, s.length()-1)));
}
</pre>
</div>

<p>
It won't win any beautiful code awards, but it's definitely more robust than before.
</p>
</div>
</div>

<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5"><span class="section-number-3">8.5</span> Summary</h3>
<div class="outline-text-3" id="text-8-5">
<p>
As you have seen, while going through the steps for writing a recursive function you might have to alter your function to actually cover all of the cases. It is an iterative process where you discover more about the problem as you go, but in general, all recursive problems can be solved this way.
</p>

<p>
There is <b>always</b> some kind of do-nothing input or inputs for which your function either does no work or a single step of the work. Drill the function for small, easy to work with numbers until you find the do-nothing input. Once that is taken care of, we can write a check the inputs to the function for when we reach that do-nothing step. Then we can break off the front of the problem so we only have to do a single step of the problem and then later combine the front result with the solution to a smaller version of the problem.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Recursion with Arrays</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> Typical pattern</h3>
<div class="outline-text-3" id="text-9-1">
<p>
Recursion usually follows this pattern
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #599cab;">function</span>(<span style="color: #d26937;">collection</span> <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">function</span> <span style="color: #599cab;">f</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">index</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> stop_check(index) ? <span style="color: #245361;">// </span><span style="color: #245361;">End the recursion?</span>
           f(elems, index) : <span style="color: #245361;">// </span><span style="color: #245361;">Operation on element </span>
           default_value;    <span style="color: #245361;">// </span><span style="color: #245361;">The base case</span>
}
</pre>
</div>

<p>
The above is psuedo code, not real C++
</p>
</div>
</div>

<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> all</h3>
<div class="outline-text-3" id="text-9-2">
<p>
Design a function that checks if all elements of an array pass a test
</p>

<p>
We can start from the template
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #599cab;">all</span>(<span style="color: #d26937;">collection</span> <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">function</span> <span style="color: #599cab;">f</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">index</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> stop_check(index) ? <span style="color: #245361;">// </span><span style="color: #245361;">End the recursion?</span>
           f(elems, index) : <span style="color: #245361;">// </span><span style="color: #245361;">Operation on element </span>
           default_value;    <span style="color: #245361;">// </span><span style="color: #245361;">The base case</span>
}
</pre>
</div>

<p>
We want the results of the test, so 'all' should return a bool
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">bool</span> <span style="color: #599cab;">all</span>(<span style="color: #d26937;">collection</span> <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">function</span> <span style="color: #599cab;">f</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">index</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> stop_check(index) ? <span style="color: #245361;">// </span><span style="color: #245361;">End the recursion?</span>
           f(elems, index) : <span style="color: #245361;">// </span><span style="color: #245361;">Operation on element </span>
           default_value;    <span style="color: #245361;">// </span><span style="color: #245361;">The base case</span>
}
</pre>
</div>

<p>
We know we're working over an array
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>&gt;
<span style="color: #d26937;">bool</span> <span style="color: #599cab;">all</span>(<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">T</span>, n&gt; <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">function</span> <span style="color: #599cab;">f</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">index</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> stop_check(index) ? <span style="color: #245361;">// </span><span style="color: #245361;">End the recursion?</span>
           f(elems, index) : <span style="color: #245361;">// </span><span style="color: #245361;">Operation on element </span>
           default_value;    <span style="color: #245361;">// </span><span style="color: #245361;">The base case</span>
}
</pre>
</div>

<p>
We use the template to generalize over any type of array and also extract to the size so it will work for any sized array
</p>

<p>
The function needs to take an element of the array and test it so it's signature would be <code>bool(T)</code>
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>&gt;
<span style="color: #d26937;">bool</span> <span style="color: #599cab;">all</span>(<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">T</span>, n&gt; <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">function</span>&lt;<span style="color: #d26937;">bool</span>(<span style="color: #d26937;">T</span>)&gt; <span style="color: #599cab;">f</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">index</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> stop_check(index) ? <span style="color: #245361;">// </span><span style="color: #245361;">End the recursion?</span>
           f(elems, index) : <span style="color: #245361;">// </span><span style="color: #245361;">Operation on element </span>
           default_value;    <span style="color: #245361;">// </span><span style="color: #245361;">The base case</span>
}
</pre>
</div>

<p>
The recursion should stop right before index = n
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>&gt;
<span style="color: #d26937;">bool</span> <span style="color: #599cab;">all</span>(<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">T</span>, n&gt; <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">function</span>&lt;<span style="color: #d26937;">bool</span>(<span style="color: #d26937;">T</span>)&gt; <span style="color: #599cab;">f</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">index</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> index &lt; n ?         <span style="color: #245361;">// </span><span style="color: #245361;">End the recursion?</span>
           f(elems, index) : <span style="color: #245361;">// </span><span style="color: #245361;">Operation on element </span>
           default_value;    <span style="color: #245361;">// </span><span style="color: #245361;">The base case</span>
}
</pre>
</div>
<p>
we don't want to go until exactly n because the index is a position
</p>

<p>
If we assumed there were only two elements we could use &amp;&amp; to combine the results
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>&gt;
<span style="color: #d26937;">bool</span> <span style="color: #599cab;">all</span>(<span style="color: #d26937;">T</span> <span style="color: #599cab;">current</span>, <span style="color: #d26937;">T</span> <span style="color: #599cab;">next</span>, <span style="color: #d26937;">function</span>&lt;<span style="color: #d26937;">bool</span>(<span style="color: #d26937;">T</span>)&gt; <span style="color: #599cab;">f</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> f(current) &amp;&amp; f(next);

</pre>
</div>

<p>
So we can do the same in our recursive step
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>&gt;
<span style="color: #d26937;">bool</span> <span style="color: #599cab;">all</span>(<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">T</span>, n&gt; <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">function</span>&lt;<span style="color: #d26937;">bool</span>(<span style="color: #d26937;">T</span>)&gt; <span style="color: #599cab;">f</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">index</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> index &lt; n ? 
           f(elems.at(index)) &amp;&amp; all(elems, cond, index+1) : 
           default_value;    <span style="color: #245361;">// </span><span style="color: #245361;">The base case</span>
}
</pre>
</div>

<p>
The index must be increase so it accesses the next element
</p>

<p>
Finally we add in the default value
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span>&lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>&gt;
<span style="color: #d26937;">bool</span> <span style="color: #599cab;">all</span>(<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">T</span>, n&gt; <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">function</span>&lt;<span style="color: #d26937;">bool</span>(<span style="color: #d26937;">T</span>)&gt; <span style="color: #599cab;">f</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">index</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> index &lt; n ? 
           f(elems.at(index)) &amp;&amp; all(elems, f, index+1):
           <span style="color: #33859e; font-weight: bold;">true</span>;
}

<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">int</span>, 5&gt; <span style="color: #599cab;">numbers</span> = { 2,4,6,8,10 };
<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">int</span>, 5&gt; <span style="color: #599cab;">others</span> = { 2,4,5,8,10 };
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">even</span> = [](<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) { <span style="color: #195466; font-weight: bold;">return</span> n % 2 == 0; };

all(numbers, even, 0); <span style="color: #245361;">// </span><span style="color: #245361;">true </span>
all(others, even, 0);  <span style="color: #245361;">// </span><span style="color: #245361;">false</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> Collections of Unfixed Size</h2>
<div class="outline-text-2" id="text-10">
</div><div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> vectors</h3>
<div class="outline-text-3" id="text-10-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;vector&gt;</span>
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #195466; font-weight: bold;">namespace</span> <span style="color: #33859e; font-weight: bold;">std</span>;

<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">Age</span> = <span style="color: #d26937;">int</span>;
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">Name</span> = string;
<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Person</span> { <span style="color: #d26937;">Age</span> <span style="color: #599cab;">age</span>; <span style="color: #d26937;">Name</span> <span style="color: #599cab;">name</span>; };

<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">TeamName</span> = string;
<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Team</span> { 
  <span style="color: #d26937;">TeamName</span> <span style="color: #599cab;">name</span>; 
  <span style="color: #d26937;">Person</span> <span style="color: #599cab;">captain</span>;

  <span style="color: #245361;">// </span><span style="color: #245361;">instead of having a value for each player</span>
  <span style="color: #245361;">// </span><span style="color: #245361;">use an array to represent the team</span>
  <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">Person</span>&gt; <span style="color: #599cab;">players</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2"><span class="section-number-3">10.2</span> what can vectors do</h3>
<div class="outline-text-3" id="text-10-2">
</div><div id="outline-container-sec-10-2-1" class="outline-4">
<h4 id="sec-10-2-1"><span class="section-number-4">10.2.1</span> the familiar</h4>
<div class="outline-text-4" id="text-10-2-1">
<ul class="org-ul">
<li>.find
</li>
<li>.front
</li>
<li>.back
</li>
<li>.size
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-2-2" class="outline-4">
<h4 id="sec-10-2-2"><span class="section-number-4">10.2.2</span> the new</h4>
<div class="outline-text-4" id="text-10-2-2">
<ul class="org-ul">
<li>.empty
</li>
<li>.erase
</li>
<li>.begin
</li>
<li>.end
</li>
<li><code>.push_back</code>
</li>
<li><code>.pop_back</code>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-10-2-3" class="outline-4">
<h4 id="sec-10-2-3"><span class="section-number-4">10.2.3</span> empty</h4>
<div class="outline-text-4" id="text-10-2-3">
<p>
checks if the vector is empty or not
</p>
</div>
</div>

<div id="outline-container-sec-10-2-4" class="outline-4">
<h4 id="sec-10-2-4"><span class="section-number-4">10.2.4</span> erase</h4>
<div class="outline-text-4" id="text-10-2-4">
<ul class="org-ul">
<li>the opposite of insert, removes the element at the specified location
</li>
<li>note, you cannot use numbers for positions while inserting or erasing with a vector
</li>
<li>vectors require something called an "iterator"
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-10-2-5" class="outline-4">
<h4 id="sec-10-2-5"><span class="section-number-4">10.2.5</span> beging and end</h4>
<div class="outline-text-4" id="text-10-2-5">
<ul class="org-ul">
<li>.begin and .end return iterators to the beginning and end of the vector
</li>
<li>to convert a position into an iterator add or subtract it from either
</li>
</ul>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">numbers</span> = { 1,2,3 };
numbers.erase(numbers.begin() + 1);

<span style="color: #245361;">// </span><span style="color: #245361;">numbers = { 1, 3 };</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-10-2-6" class="outline-4">
<h4 id="sec-10-2-6"><span class="section-number-4">10.2.6</span> push back</h4>
<div class="outline-text-4" id="text-10-2-6">
<p>
inserts an element at the end of the vector
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">ns</span> = { 1,2,3,4 };
ns.push_back(5); <span style="color: #245361;">// </span><span style="color: #245361;">1, 2, 3, 4, 5</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-10-2-7" class="outline-4">
<h4 id="sec-10-2-7"><span class="section-number-4">10.2.7</span> pop back</h4>
<div class="outline-text-4" id="text-10-2-7">
<p>
removes the element at the end of a vector
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">ns</span> = { 1,2,3,4,5 };
ns.pop_back(5); <span style="color: #245361;">// </span><span style="color: #245361;">1, 2, 3, 4</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> New Recursion Techniques</h2>
<div class="outline-text-2" id="text-11">
<ul class="org-ul">
<li>Recursion is hard
</li>
<li>It's complicated
</li>
<li>Can we do better?
</li>
</ul>
</div>

<div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> Examining past problems</h3>
<div class="outline-text-3" id="text-11-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">nums</span>) {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">combine</span> = [nums]() <span style="color: #195466; font-weight: bold;">mutable</span> {
   <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span> = nums.front();
   nums.erase(nums.begin());
   <span style="color: #195466; font-weight: bold;">return</span> n + sum(nums);
  };
  <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>nums.empty() ? combine() : 0;
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">product</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">nums</span>) <span style="color: #195466; font-weight: bold;">mutable</span> {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">combine</span> = [nums]() {
   <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span> = nums.front();
   nums.erase(nums.begin());
   <span style="color: #195466; font-weight: bold;">return</span> n * sum(nums);
  };
  <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>nums.empty() ? combine() : 0;
}
</pre>
</div>

<p>
The functions only differ by the operation that combines the elements of the collection.
</p>

<p>
Can this be generalized?
</p>
</div>
</div>

<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2"><span class="section-number-3">11.2</span> Generalizing sum</h3>
<div class="outline-text-3" id="text-11-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">nums</span>) {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">combine</span> = [nums]() <span style="color: #195466; font-weight: bold;">mutable</span> {
   <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span> = nums.front();
   nums.erase(nums.begin());
   <span style="color: #195466; font-weight: bold;">return</span> n + sum(nums);
  };
  <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>nums.empty() ? combine() : 0;
}
</pre>
</div>
<p>
This is the original
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">F</span>&gt;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">nums</span>, <span style="color: #d26937;">F</span> <span style="color: #599cab;">f</span>) <span style="color: #195466; font-weight: bold;">mutable</span> {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">combine</span> = [nums, f]() {
   <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span> = nums.front();
   nums.erase(nums.begin());
   <span style="color: #195466; font-weight: bold;">return</span> f(n, sum(nums, f));
  };
  <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>nums.empty() ? combine() : 0;
}
</pre>
</div>
<ul class="org-ul">
<li>start by pulling out the operation as a new function input
</li>
<li>the template will figure out that F needs to be a function
</li>
</ul>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">F</span>&gt;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">nums</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">init</span>, <span style="color: #d26937;">F</span> <span style="color: #599cab;">f</span>) {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">combine</span> = [nums, f]() <span style="color: #195466; font-weight: bold;">mutable</span> {
   <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span> = nums.front();
   nums.erase(nums.begin());
   <span style="color: #195466; font-weight: bold;">return</span> sum(nums, f(n, init), f));
  };
  <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>nums.empty() ? combine() : init;
}
</pre>
</div>
<ul class="org-ul">
<li>next, pull out the zero as the default
</li>
<li>the default on recursive calls becomes the previous result
</li>
</ul>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">F</span>&gt;
<span style="color: #d26937;">A</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">A</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">A</span>&gt;&gt; <span style="color: #599cab;">nums</span>, <span style="color: #d26937;">A</span> <span style="color: #599cab;">init</span>, <span style="color: #d26937;">F</span> <span style="color: #599cab;">f</span>) {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">combine</span> = [nums]() {
   <span style="color: #d26937;">A</span> <span style="color: #599cab;">n</span> = nums.front();
   nums.erase(nums.begin());
   <span style="color: #195466; font-weight: bold;">return</span> sum(nums, f(n, init), f));
  };
  <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>nums.empty() ? combine() : init;
}
</pre>
</div>
<ul class="org-ul">
<li>generalize over the type in the vector
</li>
<li>the allocator&lt;A&gt; needs to be there because C++ is stupid
</li>
</ul>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">B</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">F</span>&gt;
<span style="color: #d26937;">B</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">A</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">A</span>&gt;&gt; <span style="color: #599cab;">nums</span>, <span style="color: #d26937;">B</span> <span style="color: #599cab;">init</span>, <span style="color: #d26937;">F</span> <span style="color: #599cab;">f</span>) {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">combine</span> = [nums, init, f]() <span style="color: #195466; font-weight: bold;">mutable</span> {
   <span style="color: #d26937;">A</span> <span style="color: #599cab;">n</span> = nums.front();
   nums.erase(nums.begin());
   <span style="color: #195466; font-weight: bold;">return</span> sum(nums, f(n, init), f);
  };
  <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>nums.empty() ? combine() : init;
}
</pre>
</div>
<ul class="org-ul">
<li>allow the vector to be folded into a new type
</li>
</ul>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">B</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">F</span>&gt;
<span style="color: #d26937;">B</span> <span style="color: #599cab;">accumulate</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">A</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">A</span>&gt;&gt; <span style="color: #599cab;">nums</span>, <span style="color: #d26937;">B</span> <span style="color: #599cab;">init</span>, <span style="color: #d26937;">F</span> <span style="color: #599cab;">f</span>) {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">combine</span> = [nums, init, f]() <span style="color: #195466; font-weight: bold;">mutable</span> {
   <span style="color: #d26937;">A</span> <span style="color: #599cab;">n</span> = nums.front();
   nums.erase(nums.begin());
   <span style="color: #195466; font-weight: bold;">return</span> accumulate(nums, f(n, init), f);
  };
  <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>nums.empty() ? combine() : init;
}
</pre>
</div>
<ul class="org-ul">
<li>give it a more general sounding name
</li>
<li>done! 
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-11-3" class="outline-3">
<h3 id="sec-11-3"><span class="section-number-3">11.3</span> accumulate example</h3>
<div class="outline-text-3" id="text-11-3">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">numbers</span> = {1,2,3,4,5};

<span style="color: #d26937;">int</span> <span style="color: #599cab;">result</span> = accumulate&lt;<span style="color: #d26937;">int</span>&gt;(numbers, 0,
  [](<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>) { <span style="color: #195466; font-weight: bold;">return</span> x + y });
<span style="color: #245361;">// </span><span style="color: #245361;">result = 15</span>

</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11-4" class="outline-3">
<h3 id="sec-11-4"><span class="section-number-3">11.4</span> intersperse</h3>
<div class="outline-text-3" id="text-11-4">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>&gt;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">intersperse</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">T</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">T</span>&gt;&gt; <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">T</span> <span style="color: #599cab;">item</span>) 
-&gt;<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">T</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">T</span>&gt;&gt;
{
  <span style="color: #195466; font-weight: bold;">return</span> accumulate(elems, vector&lt;T, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">T</span>&gt;&gt;{},
   [item](<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">elem</span>, <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">result</span>) {
      <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">add</span> = [elem, result, item]() <span style="color: #195466; font-weight: bold;">mutable</span> {
              result.insert(result.begin(), item);
              result.insert(result.begin(), elem);
              <span style="color: #195466; font-weight: bold;">return</span> result;
         };

      <span style="color: #245361;">// </span><span style="color: #245361;">We need case to not add the item to the end</span>
      <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">dont_add</span> = [elem, result]() <span style="color: #195466; font-weight: bold;">mutable</span> {
          result.insert(result.begin(), elem);
          <span style="color: #195466; font-weight: bold;">return</span> result;

      };

      <span style="color: #195466; font-weight: bold;">return</span> result.empty() ? dont_add() : add();
  });
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11-5" class="outline-3">
<h3 id="sec-11-5"><span class="section-number-3">11.5</span> intersperse example</h3>
<div class="outline-text-3" id="text-11-5">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">words</span> = { <span style="color: #2aa889;">"hello"</span>, <span style="color: #2aa889;">"there"</span>, <span style="color: #2aa889;">"my"</span>, <span style="color: #2aa889;">"friend"</span> };
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">commas</span> = intersperse&lt;<span style="color: #d26937;">string</span>&gt;(words, <span style="color: #2aa889;">", "</span>);
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">result</span> = accumulate(commas, string(<span style="color: #2aa889;">""</span>),
        [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">string</span> <span style="color: #599cab;">y</span>) { <span style="color: #195466; font-weight: bold;">return</span> x + y; });
<span style="color: #245361;">// </span><span style="color: #245361;">result = "hello, there, my, friend"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11-6" class="outline-3">
<h3 id="sec-11-6"><span class="section-number-3">11.6</span> map</h3>
<div class="outline-text-3" id="text-11-6">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span>&lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">B</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">F</span>&gt;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">map</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">A</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">A</span>&gt;&gt; <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">F</span> <span style="color: #599cab;">f</span>) 
        -&gt; <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">B</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">B</span>&gt;&gt; 
{
  <span style="color: #195466; font-weight: bold;">return</span> accumulate(elems, vector&lt;B,<span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">B</span>&gt;&gt; {}, 
    [f](<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">elem</span>, <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">result</span>) {
      result.insert(result.end(), f(elem));
      <span style="color: #195466; font-weight: bold;">return</span> result;
  });
}       
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11-7" class="outline-3">
<h3 id="sec-11-7"><span class="section-number-3">11.7</span> map example</h3>
<div class="outline-text-3" id="text-11-7">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">words</span> = { <span style="color: #2aa889;">"hello"</span>, <span style="color: #2aa889;">"there"</span>, <span style="color: #2aa889;">"my"</span>, <span style="color: #2aa889;">"friend"</span> };
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">excited</span> = map&lt;<span style="color: #d26937;">string</span>&gt;(words, [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>) { <span style="color: #195466; font-weight: bold;">return</span> s + <span style="color: #2aa889;">"!"</span>; });
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">commas</span> = intersperse&lt;<span style="color: #d26937;">string</span>&gt;(words, <span style="color: #2aa889;">", "</span>);
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">result</span> = accumulate(commas, string(<span style="color: #2aa889;">""</span>),
        [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">string</span> <span style="color: #599cab;">y</span>) { <span style="color: #195466; font-weight: bold;">return</span> x + y; });
<span style="color: #245361;">// </span><span style="color: #245361;">result is "hello!,there!, my!, friend!</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11-8" class="outline-3">
<h3 id="sec-11-8"><span class="section-number-3">11.8</span> filter</h3>
<div class="outline-text-3" id="text-11-8">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span>&lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">F</span>&gt;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">filter</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">A</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">A</span>&gt;&gt; <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">F</span> <span style="color: #599cab;">f</span>) 
        -&gt; <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">A</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">A</span>&gt;&gt; 
{
  <span style="color: #195466; font-weight: bold;">return</span> accumulate(elems, vector&lt;A, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">A</span>&gt;&gt;{},
    [f](<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">elem</span>, <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">result</span>) {
      <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">pass</span> = [elem, result]() <span style="color: #195466; font-weight: bold;">mutable</span> {
        result.insert(result.end(), elem);
        <span style="color: #195466; font-weight: bold;">return</span> result;
      };
      <span style="color: #195466; font-weight: bold;">return</span> f(elem) ? pass() : result;
  });
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11-9" class="outline-3">
<h3 id="sec-11-9"><span class="section-number-3">11.9</span> filter example</h3>
<div class="outline-text-3" id="text-11-9">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">numbers</span> = { 1, 2, 3, 4, 5 };
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">evens</span> = filter(numbers
  [](<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) { <span style="color: #195466; font-weight: bold;">return</span> n % 2 == 0; });
<span style="color: #245361;">// </span><span style="color: #245361;">evens = { 2, 4 }</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11-10" class="outline-3">
<h3 id="sec-11-10"><span class="section-number-3">11.10</span> range</h3>
<div class="outline-text-3" id="text-11-10">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">range</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">start</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">stop</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">continue_range</span> = [start, stop]() {

                <span style="color: #245361;">// </span><span style="color: #245361;">Calculate the rest of the range</span>
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = range(start + 1, stop);

                <span style="color: #245361;">// </span><span style="color: #245361;">Insert the current number before</span>
                <span style="color: #245361;">// </span><span style="color: #245361;">the rest</span>
                rest.insert(rest.begin(), start);

                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };

        <span style="color: #195466; font-weight: bold;">return</span> start &lt; stop ? continue_range() : <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; {start};
}
</pre>
</div>

<p>
<img src="./images/recursion-with-vectors/range-example/range-example-1.png" class="img-responsive" alt="range-example-1.png">
start with the inital function call
</p>
<p>
<img src="./images/recursion-with-vectors/range-example/range-example-2.png" class="img-responsive" alt="range-example-2.png">
replace the call with range's definition, fill in the variables
</p>
<p>
<img src="./images/recursion-with-vectors/range-example/range-example-3.png" class="img-responsive" alt="range-example-3.png">
expand out the recursive call for range by again replacing it with the definition
</p>
<p>
<img src="./images/recursion-with-vectors/range-example/range-example-4.png" class="img-responsive" alt="range-example-4.png">
one more time, we can stop here because we know it will be 3 long
</p>
<p>
<img src="./images/recursion-with-vectors/range-example/range-example-5.png" class="img-responsive" alt="range-example-5.png">
start evaluating the tree
</p>
<p>
<img src="./images/recursion-with-vectors/range-example/range-example-6.png" class="img-responsive" alt="range-example-6.png">
result is true
</p>
<p>
<img src="./images/recursion-with-vectors/range-example/range-example-7.png" class="img-responsive" alt="range-example-7.png">
pick the first value
</p>
<p>
<img src="./images/recursion-with-vectors/range-example/range-example-8.png" class="img-responsive" alt="range-example-8.png">
eliminate the other path
</p>
<p>
<img src="./images/recursion-with-vectors/range-example/range-example-9.png" class="img-responsive" alt="range-example-9.png">
evaluate the second choice
</p>
<p>
<img src="./images/recursion-with-vectors/range-example/range-example-10.png" class="img-responsive" alt="range-example-10.png">
result is true
</p>
<p>
<img src="./images/recursion-with-vectors/range-example/range-example-11.png" class="img-responsive" alt="range-example-11.png">
pick the first value
</p>
<p>
<img src="./images/recursion-with-vectors/range-example/range-example-12.png" class="img-responsive" alt="range-example-12.png">
eliminate the second choice
</p>
<p>
<img src="./images/recursion-with-vectors/range-example/range-example-13.png" class="img-responsive" alt="range-example-13.png">
evaluate the third choice
</p>
<p>
<img src="./images/recursion-with-vectors/range-example/range-example-14.png" class="img-responsive" alt="range-example-14.png">
result is false
</p>
<p>
<img src="./images/recursion-with-vectors/range-example/range-example-15.png" class="img-responsive" alt="range-example-15.png">
pick the second value
</p>
<p>
<img src="./images/recursion-with-vectors/range-example/range-example-16.png" class="img-responsive" alt="range-example-16.png">
eliminate the first path
</p>
<p>
<img src="./images/recursion-with-vectors/range-example/range-example-17.png" class="img-responsive" alt="range-example-17.png">
start evaluating the inserts
</p>

<figure>
<p><img src="./images/recursion-with-vectors/range-example/range-example-18.png" class="img-responsive" alt="range-example-18.png">
</p>
</figure>

<figure>
<p><img src="./images/recursion-with-vectors/range-example/range-example-19.png" class="img-responsive" alt="range-example-19.png">
</p>
</figure>

<figure>
<p><img src="./images/recursion-with-vectors/range-example/range-example-20.png" class="img-responsive" alt="range-example-20.png">
</p>
</figure>
</div>
</div>

<div id="outline-container-sec-11-11" class="outline-3">
<h3 id="sec-11-11"><span class="section-number-3">11.11</span> generalizing range</h3>
<div class="outline-text-3" id="text-11-11">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">range</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">start</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">stop</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">continue_range</span> = [start, stop]() {

                <span style="color: #245361;">// </span><span style="color: #245361;">Calculate the rest of the range</span>
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = range(start + 1, stop);

                <span style="color: #245361;">// </span><span style="color: #245361;">Insert the current number before</span>
                <span style="color: #245361;">// </span><span style="color: #245361;">the rest</span>
                rest.insert(rest.begin(), start);

                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };

        <span style="color: #195466; font-weight: bold;">return</span> start &lt; stop ? continue_range() : <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; {start};
}
</pre>
</div>
<ul class="org-ul">
<li>Original
</li>
</ul>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Check</span>&gt;
<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">range</span>(<span style="color: #d26937;">Check</span> <span style="color: #599cab;">cond</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">start</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">stop</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">continue_range</span> = [start, stop]() {

                <span style="color: #245361;">// </span><span style="color: #245361;">Calculate the rest of the range</span>
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = range(start + 1, stop);

                <span style="color: #245361;">// </span><span style="color: #245361;">Insert the current number before</span>
                <span style="color: #245361;">// </span><span style="color: #245361;">the rest</span>
                rest.insert(rest.begin(), start);

                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };

        <span style="color: #195466; font-weight: bold;">return</span> cond(start, stop) ? continue_range() : <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; {start};
}
</pre>
</div>
<ul class="org-ul">
<li>pull out the condition 
</li>
</ul>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Check</span>&gt;
<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">range</span>(<span style="color: #d26937;">Check</span> <span style="color: #599cab;">cond</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">start</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">continue_range</span> = [cond, start]() {

                <span style="color: #245361;">// </span><span style="color: #245361;">Calculate the rest of the range</span>
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = range(start + 1);

                <span style="color: #245361;">// </span><span style="color: #245361;">Insert the current number before</span>
                <span style="color: #245361;">// </span><span style="color: #245361;">the rest</span>
                rest.insert(rest.begin(), start);

                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };

        <span style="color: #195466; font-weight: bold;">return</span> cond(start) ? continue_range() : <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; {start};
}
</pre>
</div>
<ul class="org-ul">
<li>stop can be hard coded into cond since it never changes 
</li>
</ul>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Check</span>&gt;
<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">range</span>(<span style="color: #d26937;">Check</span> <span style="color: #599cab;">cond</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">start</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">continue_range</span> = [cond, start]() {

            <span style="color: #d26937;">int</span> <span style="color: #599cab;">next_start</span> = start + 1;

                <span style="color: #245361;">// </span><span style="color: #245361;">Calculate the rest of the range</span>
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = range(cond, next_start);

                <span style="color: #245361;">// </span><span style="color: #245361;">Insert the current number before</span>
                <span style="color: #245361;">// </span><span style="color: #245361;">the rest</span>
                rest.insert(rest.begin(), start);

                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };

        <span style="color: #195466; font-weight: bold;">return</span> cond(start) ? continue_range() : <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; {start};
}
</pre>
</div>
<ul class="org-ul">
<li>pull creating the next start into it's own step 
</li>
</ul>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Expand</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Check</span>&gt;
<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">range</span>(<span style="color: #d26937;">Expand</span> <span style="color: #599cab;">f</span>, <span style="color: #d26937;">Check</span> <span style="color: #599cab;">cond</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">start</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">continue_range</span> = [f, cond, start]() {

            <span style="color: #d26937;">int</span> <span style="color: #599cab;">next_start</span> = f(start);

                <span style="color: #245361;">// </span><span style="color: #245361;">Calculate the rest of the range</span>
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = range(cond, next_start);

                <span style="color: #245361;">// </span><span style="color: #245361;">Insert the current number before</span>
                <span style="color: #245361;">// </span><span style="color: #245361;">the rest</span>
                rest.insert(rest.begin(), start);

                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };

        <span style="color: #195466; font-weight: bold;">return</span> cond(start) ? continue_range() : <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; {start};
}
</pre>
</div>
<ul class="org-ul">
<li>generalize over the operation to make the next start 
</li>
</ul>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Expand</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Check</span>&gt;
<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">A</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">A</span>&gt;&gt; <span style="color: #599cab;">range</span>(<span style="color: #d26937;">Expand</span> <span style="color: #599cab;">f</span>, <span style="color: #d26937;">Check</span> <span style="color: #599cab;">cond</span>, <span style="color: #d26937;">A</span> <span style="color: #599cab;">start</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">continue_range</span> = [f, cond, start]() {

            <span style="color: #d26937;">A</span> <span style="color: #599cab;">next_start</span> = f(start);

                <span style="color: #245361;">// </span><span style="color: #245361;">Calculate the rest of the range</span>
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = range(f, cond, next_start);

                <span style="color: #245361;">// </span><span style="color: #245361;">Insert the current A before</span>
                <span style="color: #245361;">// </span><span style="color: #245361;">the rest</span>
                rest.insert(rest.begin(), start);

                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };

        <span style="color: #195466; font-weight: bold;">return</span> cond(start) ? continue_range() : 
        <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">A</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">A</span>&gt;&gt; {start};
}
</pre>
</div>
<ul class="org-ul">
<li>generalize over the type of the container
</li>
<li>again, allocator&lt;A&gt; must be added because C++
</li>
</ul>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">B</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Expand</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Check</span>&gt;
<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">B</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">B</span>&gt;&gt; <span style="color: #599cab;">range</span>(<span style="color: #d26937;">Expand</span> <span style="color: #599cab;">f</span>, <span style="color: #d26937;">Check</span> <span style="color: #599cab;">cond</span>, <span style="color: #d26937;">A</span> <span style="color: #599cab;">start</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">continue_range</span> = [f, cond, start]() {

            <span style="color: #d26937;">pair</span>&lt;<span style="color: #d26937;">B</span>,<span style="color: #d26937;">A</span>&gt; <span style="color: #599cab;">next_start</span> = f(start);

                <span style="color: #245361;">// </span><span style="color: #245361;">Calculate the rest of the range</span>
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = range&lt;<span style="color: #d26937;">B</span>&gt;(f, cond, get&lt;1&gt;(next_start));

                <span style="color: #245361;">// </span><span style="color: #245361;">Insert the current B before</span>
                <span style="color: #245361;">// </span><span style="color: #245361;">the rest</span>
                rest.insert(rest.begin(), get&lt;0&gt;(next_start));

                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };

        <span style="color: #195466; font-weight: bold;">return</span> cond(start) ? continue_range() : 
        <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">B</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">B</span>&gt;&gt; {start};
}
</pre>
</div>
<ul class="org-ul">
<li>generalize over what the expansion step generates
</li>
<li>make it create a new element for the list <b>and</b> a new start
</li>
<li>get&lt;n&gt; lets you grab the nth item from a tuple or pair
</li>
<li>we need to tell range what the resulting type is cause C++
</li>
</ul>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span>&lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">B</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Expand</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Check</span>&gt;
<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">B</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">B</span>&gt;&gt; <span style="color: #599cab;">unfold</span>(<span style="color: #d26937;">Expand</span> <span style="color: #599cab;">f</span>, <span style="color: #d26937;">Check</span> <span style="color: #599cab;">cond</span>, <span style="color: #d26937;">A</span> <span style="color: #599cab;">seed</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">expand</span> = [f, cond, seed]() {
                <span style="color: #d26937;">pair</span>&lt;<span style="color: #d26937;">B</span>, <span style="color: #d26937;">A</span>&gt; <span style="color: #599cab;">result</span> = f(seed);
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = unfold&lt;<span style="color: #d26937;">B</span>&gt;(f, cond, get&lt;1&gt;(result));
                rest.insert(rest.begin(), get&lt;0&gt;(result));
                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };
        <span style="color: #195466; font-weight: bold;">return</span> cond(seed) ? expand() : 
        <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">B</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">B</span>&gt;&gt;{};
}
</pre>
</div>
<ul class="org-ul">
<li>and finally, make the names a bit more generic
</li>
<li>done!
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-11-12" class="outline-3">
<h3 id="sec-11-12"><span class="section-number-3">11.12</span> unfold example</h3>
<div class="outline-text-3" id="text-11-12">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">range</span> = unfold&lt;<span style="color: #d26937;">int</span>&gt;(
  [](<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>) { <span style="color: #195466; font-weight: bold;">return</span> make_pair(x, x+1); },
  [](<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>) { <span style="color: #195466; font-weight: bold;">return</span> x &lt;= 10; },
  1);

<span style="color: #245361;">// </span><span style="color: #245361;">range = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11-13" class="outline-3">
<h3 id="sec-11-13"><span class="section-number-3">11.13</span> using everything</h3>
<div class="outline-text-3" id="text-11-13">
<p>
generate a string which contains a comma seperated list of all of the even multiples of three from 0 to 50 
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">numbers</span> = unfold&lt;<span style="color: #d26937;">int</span>&gt;(
        [](<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>) { <span style="color: #195466; font-weight: bold;">return</span> make_pair(x, x + 1); },
        [](<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>) { <span style="color: #195466; font-weight: bold;">return</span> x &lt; 50; },
        1);

<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">threes</span> = map&lt;<span style="color: #d26937;">int</span>&gt;(numbers,
        [](<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) { <span style="color: #195466; font-weight: bold;">return</span> n * 3; }); 

<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">evens</span> = filter(threes,
        [](<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) { <span style="color: #195466; font-weight: bold;">return</span> n % 2 == 0; });

<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">str_nums</span> = map&lt;<span style="color: #d26937;">string</span>&gt;(threes, to_string);

<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">commas</span> = intersperse&lt;<span style="color: #d26937;">string</span>&gt;(str_nums, <span style="color: #2aa889;">", "</span>);

<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">result</span> = accumulate(commas, string(<span style="color: #2aa889;">""</span>),
  [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>, <span style="color: #d26937;">string</span> <span style="color: #599cab;">result</span>) { <span style="color: #195466; font-weight: bold;">return</span> s + result; });

<span style="color: #245361;">// </span><span style="color: #245361;">result 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, ... </span>
</pre>
</div>
</div>
</div>
</div>
</div><div class="col-md-3"><nav id="table-of-contents">
<div id="text-table-of-contents" class="bs-docs-sidebar">
<ul class="nav">
<li><a href="#sec-1">1. Representing Data</a>
<ul class="nav">
<li><a href="#sec-1-1">1.1. Constants</a></li>
<li><a href="#sec-1-2">1.2. Functions</a></li>
<li><a href="#sec-1-3">1.3. templates</a></li>
<li><a href="#sec-1-4">1.4. Summary</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Math Tools</a>
<ul class="nav">
<li><a href="#sec-2-1">2.1. basic math functions</a></li>
<li><a href="#sec-2-2">2.2. char math</a></li>
<li><a href="#sec-2-3">2.3. string math</a></li>
</ul>
</li>
<li><a href="#sec-3">3. String Tools</a>
<ul class="nav">
<li><a href="#sec-3-1">3.1. find length of string</a></li>
<li><a href="#sec-3-2">3.2. accessing parts of a string</a></li>
<li><a href="#sec-3-3">3.3. modifying a string</a></li>
<li><a href="#sec-3-4">3.4. searching a string</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Choice and Decision Tools</a>
<ul class="nav">
<li><a href="#sec-4-1">4.1. how to make a decision?</a></li>
<li><a href="#sec-4-2">4.2. using comparisons to change result of function</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Variables and Scope</a>
<ul class="nav">
<li><a href="#sec-5-1">5.1. A Name and a Box</a></li>
<li><a href="#sec-5-2">5.2. The auto Keyword</a></li>
<li><a href="#sec-5-3">5.3. Assignment</a></li>
<li><a href="#sec-5-4">5.4. Variables can be Assigned to Eachother</a></li>
<li><a href="#sec-5-5">5.5. Function Evaluation and Scope</a></li>
<li><a href="#sec-5-6">5.6. References</a></li>
<li><a href="#sec-5-7">5.7. Pointers</a></li>
<li><a href="#sec-5-8">5.8. Side effects</a></li>
<li><a href="#sec-5-9">5.9. When to use Variables?</a></li>
<li><a href="#sec-5-10">5.10. When to not use Variables</a></li>
</ul>
</li>
<li><a href="#sec-6">6. Functions as Values</a>
<ul class="nav">
<li><a href="#sec-6-1">6.1. C++ function variables</a></li>
<li><a href="#sec-6-2">6.2. lambda capture</a></li>
<li><a href="#sec-6-3">6.3. passing functions to other functions</a></li>
<li><a href="#sec-6-4">6.4. what are the uses of lambdas?</a></li>
</ul>
</li>
<li><a href="#sec-7">7. Collections of Fixed Size</a>
<ul class="nav">
<li><a href="#sec-7-1">7.1. accessing array elements</a></li>
<li><a href="#sec-7-2">7.2. modifying array elements</a></li>
<li><a href="#sec-7-3">7.3. warning</a></li>
<li><a href="#sec-7-4">7.4. Better array type</a></li>
</ul>
</li>
<li><a href="#sec-8">8. Recursion</a>
<ul class="nav">
<li><a href="#sec-8-1">8.1. Finding the do-nothing step and input</a></li>
<li><a href="#sec-8-2">8.2. Breaking off the front</a></li>
<li><a href="#sec-8-3">8.3. Making the problem smaller</a></li>
<li><a href="#sec-8-4">8.4. Combining Results</a></li>
<li><a href="#sec-8-5">8.5. Summary</a></li>
</ul>
</li>
<li><a href="#sec-9">9. Recursion with Arrays</a>
<ul class="nav">
<li><a href="#sec-9-1">9.1. Typical pattern</a></li>
<li><a href="#sec-9-2">9.2. all</a></li>
</ul>
</li>
<li><a href="#sec-10">10. Collections of Unfixed Size</a>
<ul class="nav">
<li><a href="#sec-10-1">10.1. vectors</a></li>
<li><a href="#sec-10-2">10.2. what can vectors do</a></li>
</ul>
</li>
<li><a href="#sec-11">11. New Recursion Techniques</a>
<ul class="nav">
<li><a href="#sec-11-1">11.1. Examining past problems</a></li>
<li><a href="#sec-11-2">11.2. Generalizing sum</a></li>
<li><a href="#sec-11-3">11.3. accumulate example</a></li>
<li><a href="#sec-11-4">11.4. intersperse</a></li>
<li><a href="#sec-11-5">11.5. intersperse example</a></li>
<li><a href="#sec-11-6">11.6. map</a></li>
<li><a href="#sec-11-7">11.7. map example</a></li>
<li><a href="#sec-11-8">11.8. filter</a></li>
<li><a href="#sec-11-9">11.9. filter example</a></li>
<li><a href="#sec-11-10">11.10. range</a></li>
<li><a href="#sec-11-11">11.11. generalizing range</a></li>
<li><a href="#sec-11-12">11.12. unfold example</a></li>
<li><a href="#sec-11-13">11.13. using everything</a></li>
</ul>
</li>
</ul>
</div>
</nav>
</div></div></div>
</body>
</html>
