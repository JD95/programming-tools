#+TITLE: Recursion with Vectors
#+STARTUP: hidestar
#+STARTUP: indent

# latex options
#+OPTIONS: author:nil date:nil num:nil 
#+LATEX_HEADER: \usepackage[margin=1.5in]{geometry}
#+LATEX_HEADER: \usepackage{apacite}
#+LATEX_HEADER: \usepackage{setspace}

- Recursion is hard
- It's complicated
- Can we do better?

** Examining past problems

#+REVEAL: split
#+BEGIN_SRC cpp
int sum(vector<int> nums) {
  auto combine = [nums]() mutable {
   int n = nums.front();
   nums.erase(nums.begin());
   return n + sum(nums);
  };
  return !nums.empty() ? combine() : 0;
}
#+END_SRC

#+BEGIN_SRC cpp
int product(vector<int> nums) mutable {
  auto combine = [nums]() {
   int n = nums.front();
   nums.erase(nums.begin());
   return n * sum(nums);
  };
  return !nums.empty() ? combine() : 0;
}
#+END_SRC

#+REVEAL: split
The functions only differ by the operation that combines the elements of the collection.

#+REVEAL: split
Can this be generalized?

** Generalizing sum

This is the original
#+BEGIN_SRC cpp
int sum(vector<int> nums) {
  auto combine = [nums]() mutable {
   int n = nums.front();
   nums.erase(nums.begin());
   return n + sum(nums);
  };
  return !nums.empty() ? combine() : 0;
}
#+END_SRC

Following from the five steps for recursion:
|----------------------+--------------------------|
| do-nothing input     | nums.empty()             |
| do-nothing step      | + 0                      |
| break off the front  | nums.front()             |
| make problem smaller | nums.erase(nums.begin()) |
| combine results      | n + sum(nums)            |
|----------------------+--------------------------|

Because our breaking off the front requires modifying =nums=, we need to use a =mutable= on-the-spot function for it.

The first thing that can be generalized in =sum= is the operation used to actually combine all of the =int= values. If we allow for the function to be passed in rather than hard coded, =sum= can be used for more cases. To pull out the function we can add a template parameter =F= to represent the function and replace calls to =+= with =f=.

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename F>
int sum(vector<int> nums, F f) {
  auto combine = [nums, f]() mutable {
   int n = nums.front();
   nums.erase(nums.begin());
   return f(n, sum(nums, f));
  };
  return !nums.empty() ? combine() : 0;
}
#+END_SRC

Now our recursion steps look like this:
|----------------------+--------------------------|
| do-nothing input     | nums.empty()             |
| do-nothing step      | f(n, 0)                  |
| break off the front  | nums.front()             |
| make problem smaller | nums.erase(nums.begin()) |
| combine results      | f(n, sum(nums))          |
|----------------------+--------------------------|

If we wanted to use this for a product of numbers instead of a summation, we'll have to change what the default value is, since anything times =0= is zero. Instead, we can just make that value an input as well.

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename F>
int sum(vector<int> nums, int init, F f) {
  auto combine = [nums, f]() mutable {
   int n = nums.front();
   nums.erase(nums.begin());
   return sum(nums, f(n, init), f));
  };
  return !nums.empty() ? combine() : init;
}
#+END_SRC

By making the default value an input we can actually use that input to "accumulate" our result rather than having to wait until the rest of the vector has been processed before combinging results. In some langauges this can allow for faster and less memory intensive code, but unfortunately C++ doesn't make that optimization. However, it's a good habit to get into the practice of.

Now our recursion steps look like this:
|----------------------+--------------------------|
| do-nothing input     | nums.empty()             |
| do-nothing step      | init                     |
| break off the front  | nums.front()             |
| make problem smaller | nums.erase(nums.begin()) |
| combine results      | f(n, int)                |
|----------------------+--------------------------|

The next bit of generalizing possible is allowing for the "sum" of types other than only =int=. There are lots of times when a collection might need to be combined into a single value.

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename A, typename F>
A sum(vector<A, allocator<A>> nums, A init, F f) {
  auto combine = [nums]() {
   A n = nums.front();
   nums.erase(nums.begin());
   return sum(nums, f(n, init), f));
  };
  return !nums.empty() ? combine() : init;
}

#+END_SRC

Note the ugly =vector<A, allocator<A>>= type now being used. This is another unfortunate wart of C++. Allocators are a complicated topic, but just know that when you want to generalize over the type of a vector, you'll have to add in the =allocator= business.

What we have so far is fairly general. It can use a function to combine all the elements of a vetor of any type by accumulating results in the =init= input. However, there is one last generalization that can be made here. What if we want the accumulated result to be a different type than what was initially in the collection? Imagine that you have a =vector<int>= and want to create a comma seperated =string= of all the numbers. In that case we'd want to accumulate the results into a =string= rather than an =int=. We can accomplish this by adding one more type parameter to =sum=.

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename B, typename A, typename F>
B sum(vector<A, allocator<A>> nums, B init, F f) {
  auto combine = [nums, init, f]() mutable {
   A n = nums.front();
   nums.erase(nums.begin());
   return sum(nums, f(n, init), f);
  };
  return !nums.empty() ? combine() : init;
}
#+END_SRC

There we go! From our initial definition, we now have a recursive function which can combine the elements of any vector into some accumulated value! Infact, the name "sum" doesn't really do justice to what's going on here. In C++, there is actually a version of this function called accumulate.

#+BEGIN_SRC cpp
#include <numeric>
using namespace std;

int main(){
  vector<int> numbers = {1,2,3,4,5};
  
  cout << accumulate(numbers.begin(), numbers.end(), 0,
    [](int x, int y) { return x + y });
  
  cout << "\n";
  return 0;
}
#+END_SRC

The above code would output "15". The difference between our derived version of accumulate and C++'s version is that =std::accumulate= can actually accumulate chunks of the vector rather than the whole collection. The chunk is specified through the first two inputs. Normally, though, we want to accumulate the whole collection so =.begin()= and =.end()= are used.

** range
#+BEGIN_SRC cpp
vector<int> range(int start, int stop) {
	auto continue_range = [start, stop]() {

		// Calculate the rest of the range
		auto rest = range(start + 1, stop);

		// Insert the current number before
		// the rest
		rest.insert(rest.begin(), start);

		return rest;
	};

	return start < stop ? continue_range() : vector<int> {start};
}
#+END_SRC

Start with the function and it's inputs.
[[./images/recursion-with-vectors/range-example/range-example-1.png]]
Replace the function call with its definition and swap out the variables with the given inputs.
[[./images/recursion-with-vectors/range-example/range-example-2.png]]
Evaluate the choice on =1 < 3=. Its true so pick the first value.
[[./images/recursion-with-vectors/range-example/range-example-3.png]]
Replace the next call to =range= with its definition and the variables swapped out.
[[./images/recursion-with-vectors/range-example/range-example-4.png]]
Evaluate the choice on =2 < 3=. Its true, so pick the first value.
[[./images/recursion-with-vectors/range-example/range-example-5.png]]
Replace the next call to =range= with its definition and the variables swapped out.
[[./images/recursion-with-vectors/range-example/range-example-6.png]]
Evaluate the choice on =3 < 3=. Its false, so pick the second value, the vector with only 3 as an element.
[[./images/recursion-with-vectors/range-example/range-example-7.png]]
Evaluate the second insert, resulting in the vector ={2, 3}=.
[[./images/recursion-with-vectors/range-example/range-example-8.png]]
Evluate the first insert, resulting in the vector ={1, 2, 3}=. 
[[./images/recursion-with-vectors/range-example/range-example-9.png]]

As we can see, range is more of less the opposite of =sum= from before. Instead of combining all numbers in a vector down to a single result, we use a "seed" value =start= to grow a vector of =int= values while some condition is true.

** generalizing range

Given our success with generalizing =sum= into the function =accumulate=, it stands to reason that we can do the same for this function as well.

#+BEGIN_SRC cpp
vector<int> range(int start, int stop) {
	auto continue_range = [start, stop]() {

		// Calculate the rest of the range
		auto rest = range(start + 1, stop);

		// Insert the current number before
		// the rest
		rest.insert(rest.begin(), start);

		return rest;
	};

	return start < stop ? continue_range() : vector<int> {start};
}
#+END_SRC

In range, the first thing to generalize is the check for when to stop growing out the list. Note that =range= only builds lists in the positive direction. If the check is pulled out as a paramter, then it would be possible to use it to grow descending lists as well.

#+BEGIN_SRC cpp
template <typename Check>
vector<int> range(Check cond, int start, int stop) {
	auto continue_range = [start, stop]() {

		// Calculate the rest of the range
		auto rest = range(start + 1, stop);

		// Insert the current number before
		// the rest
		rest.insert(rest.begin(), start);

		return rest;
	};

	return cond(start, stop) ? continue_range() : vector<int> {start};
}
#+END_SRC

Notice that the stop value is never actually used in any part of =range= except for the check. This implies that we don't actually need to pass it in and can instead assume that =cond= will already know when it should stop.

#+BEGIN_SRC cpp
template <typename Check>
vector<int> range(Check cond, int start) {
	auto continue_range = [cond, start]() {

		// Calculate the rest of the range
		auto rest = range(start + 1);

		// Insert the current number before
		// the rest
		rest.insert(rest.begin(), start);

		return rest;
	};

	return cond(start) ? continue_range() : vector<int> {start};
}
#+END_SRC

#+BEGIN_SRC cpp
template <typename Check>
vector<int> range(Check cond, int start) {
	auto continue_range = [cond, start]() {

            int next_start = start + 1;
            
		// Calculate the rest of the range
		auto rest = range(cond, next_start);

		// Insert the current number before
		// the rest
		rest.insert(rest.begin(), start);

		return rest;
	};

	return cond(start) ? continue_range() : vector<int> {start};
}
#+END_SRC

In order to make things clearer for the next step, lets pull out creating the next input for =start= into its own step. Since we don't *always* want to use =+1= to generate the next value for =start=, we should pull out that step as another function.

#+BEGIN_SRC cpp
template <typename Expand, typename Check>
vector<int> range(Expand f, Check cond, int start) {
	auto continue_range = [f, cond, start]() {

            int next_start = f(start);
            
		// Calculate the rest of the range
		auto rest = range(cond, next_start);

		// Insert the current number before
		// the rest
		rest.insert(rest.begin(), start);

		return rest;
	};

	return cond(start) ? continue_range() : vector<int> {start};
}
#+END_SRC

Next, we can generalize over the type inside the =vector=. Just like last time, we need to add on the bit for =allocator<A>=.

#+BEGIN_SRC cpp
template <typename A, typename Expand, typename Check>
vector<A, allocator<A>> range(Expand f, Check cond, A start) {
	auto continue_range = [f, cond, start]() {

            A next_start = f(start);
            
		// Calculate the rest of the range
		auto rest = range(f, cond, next_start);

		// Insert the current A before
		// the rest
		rest.insert(rest.begin(), start);

		return rest;
	};

	return cond(start) ? continue_range() : 
        vector<A, allocator<A>> {start};
}
#+END_SRC

In order to make =range= as general as possible we'll need to allow it to grow values of a different type than the original seed given. Just like how accumulate can reduce a collection into a different type, the same capability is useful when growing collections. However, this is a bit more complicated than with accumulate in that, our function for generating the next value for the collection would now have to return *two* values.

For example, if we wanted to generate a list of strings with numbers like ={"1", "2", "3", "4"}=, we'd want our starting value to be an =int= value. Given the start though, we'd have to generate a string via =to_string()= in order to make the next element for the list, but we can't then pass that =string= as the next input for start, because it must be an =int=. This implies that our expand step needs to generate *both* a new value for the collection *and* the next start/seed value.

In order to capture both values we can use the =pair= type from the standard library. You can make values into a pair by using the function =make_pair()=. It is a templated function that will take any two values and turn them into a pair. We can then use the =get()= function from the standard library to access the parts of the pair. =get()= is templated over the position of the item you want in the pair and is used like this:

#+BEGIN_SRC cpp
int main() {
  pair<int, string> p = make_pair(5, "five");
  cout << "The first item was the int " << get<0>(p) << "\n";
  cout << "The second item was the string " << get<1>(p) << "\n";
  return 0;
}
#+END_SRC

Note that positions for =get()= work the same as all other positions, they start from 0. Knowing this, we can modify =range=.

#+BEGIN_SRC cpp
template <typename B, typename A, typename Expand, typename Check>
vector<B, allocator<B>> range(Expand f, Check cond, A start) {
	auto continue_range = [f, cond, start]() {

            pair<B,A> next_start = f(start);
            
		// Calculate the rest of the range
		auto rest = range<B>(f, cond, get<1>(next_start));

		// Insert the current B before
		// the rest
		rest.insert(rest.begin(), get<0>(next_start));

		return rest;
	};

	return cond(start) ? continue_range() : 
        vector<B, allocator<B>> {start};
}
#+END_SRC

Unfortunately, there is no equivalent of this generalized range function in the C++ standard library. As such we'll give our own name to the function in order to better reflect what it actually does.

#+BEGIN_SRC cpp
template<typename B, typename A, typename Expand, typename Check>
vector<B, allocator<B>> grow(A seed, Check cond, Expand f) {
	auto expand = [f, cond, seed]() {
		pair<B, A> result = f(seed);
		auto rest = unfold<B>(f, cond, get<1>(result));
		rest.insert(rest.begin(), get<0>(result));
		return rest;
	};
	return cond(seed) ? expand() : 
        vector<B, allocator<B>>{};
}
#+END_SRC

To summarize what =grow= does, it geneates a =vector= using some starting "seed" value. It accomplishes this by constantly checking if the seed can continue to grow using =cond=. If the seed can still be grown it will use the expanding function =f= to generate a new value for the collection and the new seed for the next step. This process will continue until =cond= fails, in which case it will stop and return a =vector= of what ever values it grew so far.

#+BEGIN_SRC cpp
vector<int> range = unfold<int>(1,
  [](int x) { return x <= 10; },
  [](int x) { return make_pair(x, x+1); });

// 1  2  3  4  5  6  7  8  9  10 
for_each(range.begin(), range.end(),
  [](auto e) { cout << e << " "; });
#+END_SRC

** 
