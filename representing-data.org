#+TITLE: Representing Data
#+STARTUP: hidestar
#+STARTUP: indent

# latex options
#+OPTIONS: author:nil date:nil num:nil 
#+LATEX_HEADER: \usepackage[margin=1.5in]{geometry}
#+LATEX_HEADER: \usepackage{apacite}
#+LATEX_HEADER: \usepackage{setspace}

Programming is the process of breaking down problems into pieces that a computer can understand. The most challenging aspect of this process is changing the way we thinking about problems and, on a more philosophical note, the world around us. Computers have no concept of what a tree is or how to render a webpage until we as the programmers define what these terms mean. In many ways, this is similar to translating from your native language into another, more formal, one.

At its most basic level, programming can be summed up in two questions: how can we represent the problem's nouns and how can we represent the problem's verbs? Nouns tell us *what* we're working with. Verbs tell us *what to do* with the nouns or how to make them.

More generally, there are quite a few useful similarities between langauge and programming:
 
|-----------+-----------------------|
| language  | programming           |
|-----------+-----------------------|
| noun      | data                  |
| verb      | function              |
| adverb    | higher order function |
| pronoun   | object                |
| adjective | interface             |
|-----------+-----------------------|

** Nouns

In programming nouns can take several forms depending on how much you know about the noun beforehand. 

*** constants

If a value already known ahead of time, it can be represented with a constant. Constants are specific values like the number =5= or the word ="Hello"=. These are directly stated as part of the program and are the most constrained form of a noun.

Most programming languages, including C++, categorize different values in the following way:

| real world | C++ type |
|------------+----------|
| numbers    | int      |
| decimals   | float    |
| letters    | char     |
| text/words | string   |

Each of these different categories of values are called a =Type=. Types help tell the program what can and cannot be done with certain values. It wouldn't make sense for a person to try and send a text message with a bicycle and we'd like the same to be true in our programs as well. The four types listed above are not the only types we can work with while programming, but they are some the most primitive. All other types are combinations of these four types.

The first of these types =int= represents positive and negative whole numbers and can be expressed in a program like this:

#+BEGIN_SRC cpp
0
-1
4
239458459823459246
-123493952395923592359
#+END_SRC

=int= values are great for counting things or representing amounts. A few examples of real world =int= values are: ages, years, stars in a movie review, students in a classroom, etc.

The next category of values are =float= values. These values represent decimal numbers and can be expressed like this:

#+BEGIN_SRC cpp
0.0
.05
-1.214253235
12435.234
#+END_SRC

=float= values are great for representing percentages, positions, fractions, etc. Concepts like height, discounts, and money can be representing with this type.

Numbers are not the only values which can be represented on a computer. Any symbol on your keyboard can be represented using the =char= type. Typically, =char= values are used to represent letters and single digits. Any symbol surrounded by single quotes is a =char=. For example:

#+BEGIN_SRC cpp
'a'
'9'
'$'
'>'
':'
#+END_SRC

By grouping =char= values together we can make a =string=. The =string= type allows us to represent any amount of text within our programs. Names, addresses, dates, etc. are typically represented using this type. You can express a =string= by wrapping the text in double quotes like so:

#+BEGIN_SRC cpp
"Hello there fellow humans!"
"cost: 50, tax:96%, discount:0.5"
"<(-.-)>  (@_o)!!!"
#+END_SRC

Strings have a special value to represent no text, otherwise known as the "empty string" or =""=. There is no space between the quotes and is the same as an empty chat dialogue box or an empty searchbar.

Programs are essentially text files which people (mostly you) will have to read. In order to make our programs as easy to understand for humans, it is often useful to give better names for the values we want to use so they better capture the real world noun they are meant to represent. For example, instead of just saying =int=, one could say =Age=.

In C++, you can tell the computer to interpet a word as a type via the =using= keyword. The term =keyword= in programming refers to words that have predefined meanings within the given programming language. These keywords cannot be redefiend by the user.

Here we can see examples of =using= usage:

#+BEGIN_SRC cpp
using MarbleCount = int;
using StudentName = string;
using Discount = float;
using PlayerSymbol = char;
...
#+END_SRC

There are five parts to defining our own name for a =type=. The first part is the =using= keyword which tells the program that we intend to define a new name. The second part is the name we want to use. The third part is the $=$ sign. The fourth is the existing type which the name to the left of the $=$ symbol will actually mean. The final bit of syntax for this kind of statement is the =;=. Any kind of statement or step in a program will end in a semi-colon.  

Note that any names you add into your program cannot have any spaces or strange symbols. The rules for new names are as follows:
- the name *must* begin with a letter
- the name can only consist of letters, numbers, or the =_= symbol

Although, these primitive types can represent quite a bit on their own, they cannot represent *everything* we might want to program. In order to represent more complicated nouns like people or places, we'll need a way to group these values together into a new type.

#+BEGIN_SRC cpp
// definition of a struct
struct Person {
  int age;
  double height;
  string first_name;
  char middle_initial;
  string last_name;
  bool employed;
};

// creating a struct value
Person {30, 5.11, "Captain", 'J', "Sparrow", true}
#+END_SRC

In the first section of the above code we see a new type of statement. Here the code defines a =struct= or a collection of values. The syntax for =struct= definitions are as folows:
- the =struct= keyword
- the name of the new type (typically in upper case).
- the ={= symbol
- the different values in the =struct= which follow the pattern =type= then =name= ended with a =;=
- close the ={= with the =}= symbol
- semi-colon

The names given to the values within the =struct= are there so you can access the individual parts of a struct later on. The second part of the code above defines a constant =Person= value. Constructing a value of any =struct= can be done by giving a value for each of the different members of the type. Note that the order is important, it is the same as they are defined. First the age, which is an =int=, then the hieght, which is a =double=, etc. The ={}= symbols are generally associated with groups of values and are used in both definitions and expressions.

** function inputs
- value will be known later
- constrained by type

Questions to ask when designing a function:
- What values does it need to produce an answer?
- What is the result this function will produce?
- What am I going to name it?

everything has a type

#+BEGIN_SRC haskell
5 : int
'a' : char
3.14 : float
#+END_SRC

verbs let us transform values into other values

#+BEGIN_SRC haskell
add_one : int -> int
to_upper : char -> char
round : float -> float
length : string -> int
#+END_SRC

verbs don't have to only work on a single value

#+BEGIN_SRC haskell
add : (int, int) -> int
append : (string, string) -> int
#+END_SRC

*** function type signatures in C++

#+BEGIN_SRC cpp
// pseudo code
doNothing : int -> int

// syntax
<return type> <function name>(<input type> <input name>); 

// example
int doNothing(int input); 
#+END_SRC

*** function definition syntax

#+BEGIN_SRC cpp
// syntax
<return type> <function name>(<input type> <input name>) {
  return <return value>;
}

// example
int doNothing(int input) {
  return input;
}
#+END_SRC

*** function call syntax

#+BEGIN_SRC cpp
//syntax
<function name>(<input name>);

//example
doNothing(5);
#+END_SRC

** templates
- value and type will be known later
- least constrained

#+BEGIN_SRC cpp
int add_ints(int x, int y) {
  return x + y;
}

int add_floats(int x, int y) {
  return x + y;
}

int add_strs(int x, int y) {
  return x + y;
}
#+END_SRC
All of the functions are practically the same!

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename T>
T add(T x, T y) {
  return x + y;
}
#+END_SRC
- Templates are functions of types
- They take a type and return functions/data

*** use cases
#+BEGIN_SRC cpp
template <typename T1, typename T2>
struct Pair {
  T1 first;
  T2 second;
};
#+END_SRC
A generic pair which can group *any* two values

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename T, typename A, typename B>
Pair<T, B> over_first(const Pair<A,T> p, const function<B(A)> f) {
  return { f(p.first), p.second };
}

template <typename T, typename A, typename B>
Pair<T, B> over_second(const Pair<T,A> p, const function<B(A)> f) {
  return { p.first, f(p.second) };
}
#+END_SRC

#+REVEAL: split
#+BEGIN_SRC cpp
struct HumanUnit {
  int attack;
  ...
};

struct OrcUnit {
  int defense;
  ...
};

bool orc_atk_human_success(OrcUnit o, HumanUnit h) {
  return o.attack > h.defense;
}

bool human_atk_orc_success(HumanUnit h, OrchUnit o) {
  return h.attack > o.defense;
}
#+END_SRC
Notice we've basically written the same thing twice!

#+REVEAL: split
#+BEGIN_SRC cpp
struct HumanUnit {
  int attack;
  ...
};

struct OrcUnit {
  int defense;
  ...
};

template <typename Unit1, typename Unit2>
bool atk_success(Unit1 a, Unit2 b) {
  return a.attack > b.defense;
}
#+END_SRC

#+REVEAL: split
#+BEGIN_SRC cpp
// takes damage for any type T that has
// .hp
template <typename T>
T take_damage(T unit, int dmg) {
  unit.hp = unit.hp - dmg;
  return unit;
} 

template <typename T1, typename T2>
Pair<T1, T2> combat(T1 attacker, T2 defender) {
  return { attacker 
         , atk_success(attacker, defender) ? 
             take_damage(defender, 5) : 
             defender 
         };
}
#+END_SRC

*** What if you need to do something several times?
#+BEGIN_SRC cpp
template <typename T>
function<T(T)> apply_twice(function<T(T)> f) {
  return [f](T x) { return f(f(x)); };
};
#+END_SRC

Transforms a function into one that is applied twice
