#+TITLE: Representing Data
#+STARTUP: hidestar
#+STARTUP: indent

# latex options
#+OPTIONS: author:nil date:nil num:nil 
#+LATEX_HEADER: \usepackage[margin=1.5in]{geometry}
#+LATEX_HEADER: \usepackage{apacite}
#+LATEX_HEADER: \usepackage{setspace}

** using a programming language
- in order to program, we have to talk to the computer in a language it understands
- trying to directly state our problems in programming languages is usually impossible
- we need a way to change how we talk about problems in order to make them fit into programming languages

** how is information represented?

*** information
1. facts provided or learned about something or someone. 
2. what is conveyed or represented by a particular arrangement or sequence of things.

*** instructions break down into verbs and nouns
- nouns tell us *what* we're working with
- verbs tell us *what to do* with the nouns

*** programming has two parts
- take the parts of speech and break into simplier terms until directly expressible in a programming language
- use the programming language to put the pieces back together into the final program
  
*** language vs programming
|-----------+-----------------------|
| language  | programming           |
|-----------+-----------------------|
| noun      | data                  |
| pronoun   | object                |
| adjective | interface             |
| verb      | function              |
| adverb    | higher order function |
|-----------+-----------------------|

*** what is known about the data?

**** constants
- value already known
- most constrained


**** primitive types
| real world | C++    |
|------------+--------|
| numbers    | int    |
| decimals   | float  |
| letters    | char   |
| text/words | string |

***** int
- positive and negative numbers

#+BEGIN_SRC cpp
0
-1
4
239458459823459246
-123493952395923592359
#+END_SRC

***** float
- decimal numbers
- fractions
- percentages

#+BEGIN_SRC cpp
0.0
.05
-1.214253235
12435.234
#+END_SRC

***** char
- any single symbol you can type on the keyboard
- written using single quotes around the symbol

#+BEGIN_SRC cpp
'a'
'9'
'$'
'>'
':'
#+END_SRC

***** string
- a collection of characters
- sentences or phrases
- written using double quotes around the symbols

#+BEGIN_SRC cpp
"Hello there fellow humans!"
"cost: 50, tax:96%, discount:0.5"
"<(-.-)>  (@_o)!!!"
#+END_SRC

***** the using keyword
- helps associate the type with the real world thing its representing

#+BEGIN_SRC cpp
using MarbleCount = int;
using StudentName = string;
using Discount = float;
using PlayerSymbol = char;
...
#+END_SRC

***** grouping types

#+BEGIN_SRC cpp

// definition of a struct
struct Person {
  int age;
  double height;
  string first_name;
  char middle_initial;
  string last_name;
  bool employed;
};

// use of the parts of a struct
string full_name(Person p) {
  return p.first_name + p.last_name.insert(0,1, p.middle_inital);
}

// creating a struct value
full_name({22, 6.4, "Jeffrey", 'M', "Dwyer", true});

  
#+END_SRC

#+BEGIN_SRC cpp

using Age = int;
using Name = string;
struct Person { Age age; Name name; };

using TeamName = string;
struct Team { 
  TeamName name; 
  Person coach;
  Person quater_back;
  Person wide_reciever;
  ...
};
#+END_SRC

** function inputs
- value will be known later
- constrained by type

Questions to ask when designing a function:
- What values does it need to produce an answer?
- What is the result this function will produce?
- What am I going to name it?

everything has a type

#+BEGIN_SRC haskell
5 : int
'a' : char
3.14 : float
#+END_SRC

verbs let us transform values into other values

#+BEGIN_SRC haskell
add_one : int -> int
to_upper : char -> char
round : float -> float
length : string -> int
#+END_SRC

verbs don't have to only work on a single value

#+BEGIN_SRC haskell
add : (int, int) -> int
append : (string, string) -> int
#+END_SRC

*** function type signatures in C++

#+BEGIN_SRC cpp
// pseudo code
doNothing : int -> int

// syntax
<return type> <function name>(<input type> <input name>); 

// example
int doNothing(int input); 
#+END_SRC

*** function definition syntax

#+BEGIN_SRC cpp
// syntax
<return type> <function name>(<input type> <input name>) {
  return <return value>;
}

// example
int doNothing(int input) {
  return input;
}
#+END_SRC

*** function call syntax

#+BEGIN_SRC cpp
//syntax
<function name>(<input name>);

//example
doNothing(5);
#+END_SRC

** templates
- value and type will be known later
- least constrained

#+BEGIN_SRC cpp
int add_ints(int x, int y) {
  return x + y;
}

int add_floats(int x, int y) {
  return x + y;
}

int add_strs(int x, int y) {
  return x + y;
}
#+END_SRC
All of the functions are practically the same!

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename T>
T add(T x, T y) {
  return x + y;
}
#+END_SRC
- Templates are functions of types
- They take a type and return functions/data

*** use cases
#+BEGIN_SRC cpp
template <typename T1, typename T2>
struct Pair {
  T1 first;
  T2 second;
};
#+END_SRC
A generic pair which can group *any* two values

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename T, typename A, typename B>
Pair<T, B> over_first(const Pair<A,T> p, const function<B(A)> f) {
  return { f(p.first), p.second };
}

template <typename T, typename A, typename B>
Pair<T, B> over_second(const Pair<T,A> p, const function<B(A)> f) {
  return { p.first, f(p.second) };
}
#+END_SRC

#+REVEAL: split
#+BEGIN_SRC cpp
struct HumanUnit {
  int attack;
  ...
};

struct OrcUnit {
  int defense;
  ...
};

bool orc_atk_human_success(OrcUnit o, HumanUnit h) {
  return o.attack > h.defense;
}

bool human_atk_orc_success(HumanUnit h, OrchUnit o) {
  return h.attack > o.defense;
}
#+END_SRC
Notice we've basically written the same thing twice!

#+REVEAL: split
#+BEGIN_SRC cpp
struct HumanUnit {
  int attack;
  ...
};

struct OrcUnit {
  int defense;
  ...
};

template <typename Unit1, typename Unit2>
bool atk_success(Unit1 a, Unit2 b) {
  return a.attack > b.defense;
}
#+END_SRC

#+REVEAL: split
#+BEGIN_SRC cpp
// takes damage for any type T that has
// .hp
template <typename T>
T take_damage(T unit, int dmg) {
  unit.hp = unit.hp - dmg;
  return unit;
} 

template <typename T1, typename T2>
Pair<T1, T2> combat(T1 attacker, T2 defender) {
  return { attacker 
         , atk_success(attacker, defender) ? 
             take_damage(defender, 5) : 
             defender 
         };
}
#+END_SRC

*** What if you need to do something several times?
#+BEGIN_SRC cpp
template <typename T>
function<T(T)> apply_twice(function<T(T)> f) {
  return [f](T x) { return f(f(x)); };
};
#+END_SRC

Transforms a function into one that is applied twice
