#+TITLE: Recursion with Vectors
#+STARTUP: hidestar
#+STARTUP: indent

# latex options
#+OPTIONS: author:nil date:nil num:nil 
#+LATEX_HEADER: \usepackage[margin=1.5in]{geometry}
#+LATEX_HEADER: \usepackage{apacite}
#+LATEX_HEADER: \usepackage{setspace}

- Recursion is hard
- It's complicated
- Can we do better?

** Examining past problems

#+REVEAL: split
#+BEGIN_SRC cpp
int sum(vector<int> nums) {
  auto combine = [nums]() mutable {
   int n = nums.front();
   nums.erase(nums.begin());
   return n + sum(nums);
  };
  return !nums.empty() ? combine() : 0;
}
#+END_SRC

#+BEGIN_SRC cpp
int product(vector<int> nums) mutable {
  auto combine = [nums]() {
   int n = nums.front();
   nums.erase(nums.begin());
   return n * sum(nums);
  };
  return !nums.empty() ? combine() : 0;
}
#+END_SRC

#+REVEAL: split
The functions only differ by the operation that combines the elements of the collection.

#+REVEAL: split
Can this be generalized?

** Generalizing sum

This is the original
#+BEGIN_SRC cpp
int sum(vector<int> nums) {
  auto combine = [nums]() mutable {
   int n = nums.front();
   nums.erase(nums.begin());
   return n + sum(nums);
  };
  return !nums.empty() ? combine() : 0;
}
#+END_SRC

Following from the five steps for recursion:
|----------------------+--------------------------|
| do-nothing input     | nums.empty()             |
| do-nothing step      | + 0                      |
| break off the front  | nums.front()             |
| make problem smaller | nums.erase(nums.begin()) |
| combine results      | n + sum(nums)            |
|----------------------+--------------------------|

Because our breaking off the front requires modifying =nums=, we need to use a =mutable= on-the-spot function for it.

The first thing that can be generalized in =sum= is the operation used to actually combine all of the =int= values. If we allow for the function to be passed in rather than hard coded, =sum= can be used for more cases. To pull out the function we can add a template parameter =F= to represent the function and replace calls to =+= with =f=.

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename F>
int sum(vector<int> nums, F f) {
  auto combine = [nums, f]() mutable {
   int n = nums.front();
   nums.erase(nums.begin());
   return f(n, sum(nums, f));
  };
  return !nums.empty() ? combine() : 0;
}
#+END_SRC

Now our recursion steps look like this:
|----------------------+--------------------------|
| do-nothing input     | nums.empty()             |
| do-nothing step      | f(n, 0)                  |
| break off the front  | nums.front()             |
| make problem smaller | nums.erase(nums.begin()) |
| combine results      | f(n, sum(nums))          |
|----------------------+--------------------------|

If we wanted to use this for a product of numbers instead of a summation, we'll have to change what the default value is, since anything times =0= is zero. Instead, we can just make that value an input as well.

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename F>
int sum(vector<int> nums, int init, F f) {
  auto combine = [nums, f]() mutable {
   int n = nums.front();
   nums.erase(nums.begin());
   return sum(nums, f(n, init), f));
  };
  return !nums.empty() ? combine() : init;
}
#+END_SRC

By making the default value an input we can actually use that input to "accumulate" our result rather than having to wait until the rest of the vector has been processed before combinging results. In some langauges this can allow for faster and less memory intensive code, but unfortunately C++ doesn't make that optimization. However, it's a good habit to get into the practice of.

Now our recursion steps look like this:
|----------------------+--------------------------|
| do-nothing input     | nums.empty()             |
| do-nothing step      | init                     |
| break off the front  | nums.front()             |
| make problem smaller | nums.erase(nums.begin()) |
| combine results      | f(n, int)                |
|----------------------+--------------------------|

The next bit of generalizing possible is allowing for the "sum" of types other than only =int=. There are lots of times when a collection might need to be combined into a single value.

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename A, typename F>
A sum(vector<A, allocator<A>> nums, A init, F f) {
  auto combine = [nums]() {
   A n = nums.front();
   nums.erase(nums.begin());
   return sum(nums, f(n, init), f));
  };
  return !nums.empty() ? combine() : init;
}

#+END_SRC

Note the ugly =vector<A, allocator<A>>= type now being used. This is another unfortunate wart of C++. Allocators are a complicated topic, but just know that when you want to generalize over the type of a vector, you'll have to add in the =allocator= business.

What we have so far is fairly general. It can use a function to combine all the elements of a vetor of any type by accumulating results in the =init= input. However, there is one last generalization that can be made here. What if we want the accumulated result to be a different type than what was initially in the collection? Imagine that you have a =vector<int>= and want to create a comma seperated =string= of all the numbers. In that case we'd want to accumulate the results into a =string= rather than an =int=. We can accomplish this by adding one more type parameter to =sum=.

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename B, typename A, typename F>
B sum(vector<A, allocator<A>> nums, B init, F f) {
  auto combine = [nums, init, f]() mutable {
   A n = nums.front();
   nums.erase(nums.begin());
   return sum(nums, f(n, init), f);
  };
  return !nums.empty() ? combine() : init;
}
#+END_SRC

There we go! From our initial definition, we now have a recursive function which can combine the elements of any vector into some accumulated value! Infact, the name "sum" doesn't really do justice to what's going on here. In C++, there is actually a version of this function called accumulate.

** accumulate example

#+BEGIN_SRC cpp
#include <numeric>
using namespace std;

int main(){
  vector<int> numbers = {1,2,3,4,5};
  
  cout << accumulate(numbers.begin(), numbers.end(), 0,
    [](int x, int y) { return x + y });
  
  cout << "\n";
  return 0;
}
#+END_SRC

The above code would output "15". The difference between our derived version of accumulate and C++'s version is that =std::accumulate= can actually accumulate chunks of the vector rather than the whole collection. The chunk is specified through the first two inputs. Normally, though, we want to accumulate the whole collection so =.begin()= and =.end()= are used.

** range
#+BEGIN_SRC cpp
vector<int> range(int start, int stop) {
	auto continue_range = [start, stop]() {

		// Calculate the rest of the range
		auto rest = range(start + 1, stop);

		// Insert the current number before
		// the rest
		rest.insert(rest.begin(), start);

		return rest;
	};

	return start < stop ? continue_range() : vector<int> {start};
}
#+END_SRC

#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-1.png]]
start with the inital function call
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-2.png]]
replace the call with range's definition, fill in the variables
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-3.png]]
expand out the recursive call for range by again replacing it with the definition
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-4.png]]
one more time, we can stop here because we know it will be 3 long
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-5.png]]
start evaluating the tree
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-6.png]]
result is true
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-7.png]]
pick the first value
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-8.png]]
eliminate the other path
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-9.png]]
evaluate the second choice
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-10.png]]
result is true
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-11.png]]
pick the first value
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-12.png]]
eliminate the second choice
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-13.png]]
evaluate the third choice
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-14.png]]
result is false
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-15.png]]
pick the second value
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-16.png]]
eliminate the first path
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-17.png]]
start evaluating the inserts
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-18.png]]
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-19.png]]
#+REVEAL: split
[[./images/recursion-with-vectors/range-example/range-example-20.png]]

** generalizing range

#+BEGIN_SRC cpp
vector<int> range(int start, int stop) {
	auto continue_range = [start, stop]() {

		// Calculate the rest of the range
		auto rest = range(start + 1, stop);

		// Insert the current number before
		// the rest
		rest.insert(rest.begin(), start);

		return rest;
	};

	return start < stop ? continue_range() : vector<int> {start};
}
#+END_SRC
- Original

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename Check>
vector<int> range(Check cond, int start, int stop) {
	auto continue_range = [start, stop]() {

		// Calculate the rest of the range
		auto rest = range(start + 1, stop);

		// Insert the current number before
		// the rest
		rest.insert(rest.begin(), start);

		return rest;
	};

	return cond(start, stop) ? continue_range() : vector<int> {start};
}
#+END_SRC
- pull out the condition 

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename Check>
vector<int> range(Check cond, int start) {
	auto continue_range = [cond, start]() {

		// Calculate the rest of the range
		auto rest = range(start + 1);

		// Insert the current number before
		// the rest
		rest.insert(rest.begin(), start);

		return rest;
	};

	return cond(start) ? continue_range() : vector<int> {start};
}
#+END_SRC
- stop can be hard coded into cond since it never changes 

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename Check>
vector<int> range(Check cond, int start) {
	auto continue_range = [cond, start]() {

            int next_start = start + 1;
            
		// Calculate the rest of the range
		auto rest = range(cond, next_start);

		// Insert the current number before
		// the rest
		rest.insert(rest.begin(), start);

		return rest;
	};

	return cond(start) ? continue_range() : vector<int> {start};
}
#+END_SRC
- pull creating the next start into it's own step 

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename Expand, typename Check>
vector<int> range(Expand f, Check cond, int start) {
	auto continue_range = [f, cond, start]() {

            int next_start = f(start);
            
		// Calculate the rest of the range
		auto rest = range(cond, next_start);

		// Insert the current number before
		// the rest
		rest.insert(rest.begin(), start);

		return rest;
	};

	return cond(start) ? continue_range() : vector<int> {start};
}
#+END_SRC
- generalize over the operation to make the next start 

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename A, typename Expand, typename Check>
vector<A, allocator<A>> range(Expand f, Check cond, A start) {
	auto continue_range = [f, cond, start]() {

            A next_start = f(start);
            
		// Calculate the rest of the range
		auto rest = range(f, cond, next_start);

		// Insert the current A before
		// the rest
		rest.insert(rest.begin(), start);

		return rest;
	};

	return cond(start) ? continue_range() : 
        vector<A, allocator<A>> {start};
}
#+END_SRC
- generalize over the type of the container
- again, allocator<A> must be added because C++

#+REVEAL: split
#+BEGIN_SRC cpp
template <typename B, typename A, typename Expand, typename Check>
vector<B, allocator<B>> range(Expand f, Check cond, A start) {
	auto continue_range = [f, cond, start]() {

            pair<B,A> next_start = f(start);
            
		// Calculate the rest of the range
		auto rest = range<B>(f, cond, get<1>(next_start));

		// Insert the current B before
		// the rest
		rest.insert(rest.begin(), get<0>(next_start));

		return rest;
	};

	return cond(start) ? continue_range() : 
        vector<B, allocator<B>> {start};
}
#+END_SRC
- generalize over what the expansion step generates
- make it create a new element for the list *and* a new start
- get<n> lets you grab the nth item from a tuple or pair
- we need to tell range what the resulting type is cause C++

#+REVEAL: split
#+BEGIN_SRC cpp
template<typename B, typename A, typename Expand, typename Check>
vector<B, allocator<B>> unfold(Expand f, Check cond, A seed) {
	auto expand = [f, cond, seed]() {
		pair<B, A> result = f(seed);
		auto rest = unfold<B>(f, cond, get<1>(result));
		rest.insert(rest.begin(), get<0>(result));
		return rest;
	};
	return cond(seed) ? expand() : 
        vector<B, allocator<B>>{};
}
#+END_SRC
- and finally, make the names a bit more generic
- done!

** unfold example
#+BEGIN_SRC cpp
vector<int> range = unfold<int>(
  [](int x) { return make_pair(x, x+1); },
  [](int x) { return x <= 10; },
  1);

// range = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
#+END_SRC

** using everything

generate a string which contains a comma seperated list of all of the even multiples of three from 0 to 50 

#+BEGIN_SRC cpp
auto numbers = unfold<int>(
	[](int x) { return make_pair(x, x + 1); },
	[](int x) { return x < 50; },
	1);

auto threes = map<int>(numbers,
	[](int n) { return n * 3; }); 

auto evens = filter(threes,
	[](int n) { return n % 2 == 0; });

auto str_nums = map<string>(threes, to_string);

auto commas = intersperse<string>(str_nums, ", ");

auto result = accumulate(commas, string(""),
  [](string s, string result) { return s + result; });

// result 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, ... 
#+END_SRC
