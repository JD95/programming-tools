<!doctype html>
<html lang="en">
<head>
<title>Programming Tools</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="generator" content="Org-mode">
<meta name="author" content="Jeffrey Dwyer">

<link  href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>
<style type="text/css">
/* org mode styles on top of twbs */

html {
    position: relative;
    min-height: 100%;
}

body {
    font-size: 18px;
    margin-bottom: 105px;
}

footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 101px;
    background-color: #f5f5f5;
}

footer > div {
    padding: 10px;
}

footer p {
    margin: 0 0 5px;
    text-align: center;
    font-size: 16px;
}

#table-of-contents {
    margin-top: 20px;
    margin-bottom: 20px;
}

blockquote p {
    font-size: 18px;
}

pre {
    font-size: 16px;
}

.footpara {
    display: inline-block;
}

figcaption {
  font-size: 16px;
  color: #666;
  font-style: italic;
  padding-bottom: 15px;
}

/* from twbs docs */

.bs-docs-sidebar.affix {
    position: static;
}
@media (min-width: 768px) {
    .bs-docs-sidebar {
        padding-left: 20px;
    }
}

/* All levels of nav */
.bs-docs-sidebar .nav > li > a {
    display: block;
    padding: 4px 20px;
    font-size: 14px;
    font-weight: 500;
    color: #999;
}
.bs-docs-sidebar .nav > li > a:hover,
.bs-docs-sidebar .nav > li > a:focus {
    padding-left: 19px;
    color: #A1283B;
    text-decoration: none;
    background-color: transparent;
    border-left: 1px solid #A1283B;
}
.bs-docs-sidebar .nav > .active > a,
.bs-docs-sidebar .nav > .active:hover > a,
.bs-docs-sidebar .nav > .active:focus > a {
    padding-left: 18px;
    font-weight: bold;
    color: #A1283B;
    background-color: transparent;
    border-left: 2px solid #A1283B;
}

/* Nav: second level (shown on .active) */
.bs-docs-sidebar .nav .nav {
    display: none; /* Hide by default, but at >768px, show it */
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 30px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav > li > a:focus {
    padding-left: 29px;
}
.bs-docs-sidebar .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav > .active:focus > a {
    padding-left: 28px;
    font-weight: 500;
}

/* Nav: third level (shown on .active) */
.bs-docs-sidebar .nav .nav .nav {
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 40px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav .nav > li > a:focus {
    padding-left: 39px;
}
.bs-docs-sidebar .nav .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav .nav > .active:focus > a {
    padding-left: 38px;
    font-weight: 500;
}

/* Show and affix the side nav when space allows it */
@media (min-width: 992px) {
    .bs-docs-sidebar .nav > .active > ul {
        display: block;
    }
    /* Widen the fixed sidebar */
    .bs-docs-sidebar.affix,
    .bs-docs-sidebar.affix-bottom {
        width: 213px;
    }
    .bs-docs-sidebar.affix {
        position: fixed; /* Undo the static from mobile first approach */
        top: 20px;
    }
    .bs-docs-sidebar.affix-bottom {
        position: absolute; /* Undo the static from mobile first approach */
    }
    .bs-docs-sidebar.affix .bs-docs-sidenav,.bs-docs-sidebar.affix-bottom .bs-docs-sidenav {
        margin-top: 0;
        margin-bottom: 0
    }
}
@media (min-width: 1200px) {
    /* Widen the fixed sidebar again */
    .bs-docs-sidebar.affix-bottom,
    .bs-docs-sidebar.affix {
        width: 263px;
    }
}
</style>
<style>body { margin-bottom: 0px; }</style><script type="text/javascript">
$(function() {
    'use strict';

    $('.bs-docs-sidebar li').first().addClass('active');

    $(document.body).scrollspy({target: '.bs-docs-sidebar'});

    $('.bs-docs-sidebar').affix();
});
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  displayAlign: "center",
  displayIndent: "2em",
  messageStyle: "none",
  "HTML-CSS": {
    scale: 100,
    styles: {
      ".MathJax_Display": {
        "font-size": "100%"
      }
    }
  },
  "SVG": {
    scale: 100,
    styles: {
      ".MathJax_SVG_Display": {
        "font-size": "100%",
        "margin-left": "-2.281em"
      }
    }
  }
});
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG"></script>
</head>
<body>
<div id="content" class="container">
<div class="row"><div class="col-md-9"><h1 class="title">Programming Tools</h1>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Representing Data</h2>
<div class="outline-text-2" id="text-1">
<p>
Programming is the process of breaking down problems into pieces that a computer can understand. The most challenging aspect of this process is changing the way we thinking about problems and, on a more philosophical note, the world around us. Computers have no concept of what a tree is or how to render a webpage until we as the programmers define what these terms mean. In many ways, this is similar to translating from your native language into another, more formal, one.
</p>

<p>
At its most basic level, programming can be summed up in two questions: how can we represent the problem's nouns and how can we represent the problem's verbs? Nouns tell us <b>what</b> we're working with. Verbs tell us <b>what to do</b> with the nouns or how to make them.
</p>

<p>
More generally, there are quite a few useful similarities between langauge and programming:
</p>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">language</th>
<th scope="col" class="text-left">programming</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">noun</td>
<td class="text-left">data</td>
</tr>

<tr>
<td class="text-left">verb</td>
<td class="text-left">function</td>
</tr>

<tr>
<td class="text-left">adverb</td>
<td class="text-left">higher order function</td>
</tr>

<tr>
<td class="text-left">pronoun</td>
<td class="text-left">object</td>
</tr>

<tr>
<td class="text-left">adjective</td>
<td class="text-left">interface</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Constants</h3>
<div class="outline-text-3" id="text-1-1">
<p>
In programming nouns can take several forms depending on how much you know about the noun beforehand. If a value already known ahead of time, it can be represented with a constant. Constants are specific values like the number <code>5</code> or the word <code>"Hello"</code>. These are directly stated as part of the program and are the most constrained form of a noun.
</p>

<p>
Most programming languages, including C++, categorize different values in the following way:
</p>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">real world</th>
<th scope="col" class="text-left">C++ type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">numbers</td>
<td class="text-left">int</td>
</tr>

<tr>
<td class="text-left">decimals</td>
<td class="text-left">float</td>
</tr>

<tr>
<td class="text-left">letters</td>
<td class="text-left">char</td>
</tr>

<tr>
<td class="text-left">text/words</td>
<td class="text-left">string</td>
</tr>
</tbody>
</table>

<p>
Each of these different categories of values are called a <code>Type</code>. Types help tell the program what can and cannot be done with certain values. It wouldn't make sense for a person to try and send a text message with a bicycle and we'd like the same to be true in our programs as well. The four types listed above are not the only types we can work with while programming, but they are some the most primitive. All other types are combinations of these four types.
</p>

<p>
The first of these types <code>int</code> represents positive and negative whole numbers and can be expressed in a program like this:
</p>

<div class="org-src-container">

<pre class="src src-cpp">0
-1
4
239458459823459246
-123493952395923592359
</pre>
</div>

<p>
<code>int</code> values are great for counting things or representing amounts. A few examples of real world <code>int</code> values are: ages, years, stars in a movie review, students in a classroom, etc.
</p>

<p>
The next category of values are <code>float</code> values. These values represent decimal numbers and can be expressed like this:
</p>

<div class="org-src-container">

<pre class="src src-cpp">0.0
.05
-1.214253235
12435.234
</pre>
</div>

<p>
<code>float</code> values are great for representing percentages, positions, fractions, etc. Concepts like height, discounts, and money can be representing with this type.
</p>

<p>
Numbers are not the only values which can be represented on a computer. Any symbol on your keyboard can be represented using the <code>char</code> type. Typically, <code>char</code> values are used to represent letters and single digits. Any symbol surrounded by single quotes is a <code>char</code>. For example:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #2aa889;">'a'</span>
<span style="color: #2aa889;">'9'</span>
<span style="color: #2aa889;">'$'</span>
<span style="color: #2aa889;">'&gt;'</span>
<span style="color: #2aa889;">':'</span>
</pre>
</div>

<p>
By grouping <code>char</code> values together we can make a <code>string</code>. The <code>string</code> type allows us to represent any amount of text within our programs. Names, addresses, dates, etc. are typically represented using this type. You can express a <code>string</code> by wrapping the text in double quotes like so:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #2aa889;">"Hello there fellow humans!"</span>
<span style="color: #2aa889;">"cost: 50, tax:96%, discount:0.5"</span>
<span style="color: #2aa889;">"&lt;(-.-)&gt;  (@_o)!!!"</span>
</pre>
</div>

<p>
Strings have a special value to represent no text, otherwise known as the "empty string" or <code>""</code>. There is no space between the quotes and is the same as an empty chat dialogue box or an empty searchbar.
</p>

<p>
Programs are essentially text files which people (mostly you) will have to read. In order to make our programs as easy to understand for humans, it is often useful to give better names for the values we want to use so they better capture the real world noun they are meant to represent. For example, instead of just saying <code>int</code>, one could say <code>Age</code>.
</p>

<p>
In C++, you can tell the computer to interpet a word as a type via the <code>using</code> keyword. The term <code>keyword</code> in programming refers to words that have predefined meanings within the given programming language. These keywords cannot be redefiend by the user.
</p>

<p>
Here we can see examples of <code>using</code> usage:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">MarbleCount</span> = <span style="color: #d26937;">int</span>;
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">StudentName</span> = string;
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">Discount</span> = <span style="color: #d26937;">float</span>;
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">PlayerSymbol</span> = <span style="color: #d26937;">char</span>;
...
</pre>
</div>

<p>
There are five parts to defining our own name for a <code>type</code>. The first part is the <code>using</code> keyword which tells the program that we intend to define a new name. The second part is the name we want to use. The third part is the \(=\) sign. The fourth is the existing type which the name to the left of the \(=\) symbol will actually mean. The final bit of syntax for this kind of statement is the <code>;</code>. Any kind of statement or step in a program will end in a semi-colon.  
</p>

<p>
Note that any names you add into your program cannot have any spaces or strange symbols. The rules for new names are as follows:
</p>
<ul class="org-ul">
<li>the name <b>must</b> begin with a letter
</li>
<li>the name can only consist of letters, numbers, or the <code>_</code> symbol
</li>
</ul>

<p>
Although, these primitive types can represent quite a bit on their own, they cannot represent <b>everything</b> we might want to program. In order to represent more complicated nouns like people or places, we'll need a way to group these values together into a new type.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">definition of a struct</span>
<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Person</span> {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">age</span>;
  <span style="color: #d26937;">double</span> <span style="color: #599cab;">height</span>;
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">first_name</span>;
  <span style="color: #d26937;">char</span> <span style="color: #599cab;">middle_initial</span>;
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">last_name</span>;
  <span style="color: #d26937;">bool</span> <span style="color: #599cab;">employed</span>;
};

<span style="color: #245361;">// </span><span style="color: #245361;">creating a struct value</span>
Person {30, 5.11, <span style="color: #2aa889;">"Captain"</span>, <span style="color: #2aa889;">'J'</span>, <span style="color: #2aa889;">"Sparrow"</span>, <span style="color: #33859e; font-weight: bold;">true</span>}
</pre>
</div>

<p>
In the first section of the above code we see a new type of statement. Here the code defines a <code>struct</code> or a collection of values. The syntax for <code>struct</code> definitions are as folows:
</p>
<ul class="org-ul">
<li>the <code>struct</code> keyword
</li>
<li>the name of the new type (typically in upper case).
</li>
<li>the <code>{</code> symbol
</li>
<li>the different values in the <code>struct</code> which follow the pattern <code>type</code> then <code>name</code> ended with a <code>;</code>
</li>
<li>close the <code>{</code> with the <code>}</code> symbol
</li>
<li>semi-colon
</li>
</ul>

<p>
The names given to the values within the <code>struct</code> are there so you can access the individual parts of a struct later on.
</p>

<p>
For example, if we assumed that the name \(p\) referred to a <code>Person</code> value, we could access its members like this:
</p>

<div class="org-src-container">

<pre class="src src-cpp">p.age
p.height
p.first_name
</pre>
</div>

<p>
The dot expressions can be read as <code>p's age</code> or <code>p's first_name</code>. While the dot value <code>.age</code> could potentially refer to the age of any <code>Person</code>, it has to be paired with a particular <code>Person</code> in order to be used.
</p>

<p>
The second part of the code above defines a constant <code>Person</code> value. Constructing a value of any <code>struct</code> can be done by giving a value for each of the different members of the type. Note that the order is important, it is the same as they are defined. First the age, which is an <code>int</code>, then the hieght, which is a <code>double</code>, etc. The <code>{}</code> symbols are generally associated with groups of values and are used in both definitions and expressions.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Functions</h3>
<div class="outline-text-3" id="text-1-2">
<p>
When a value isn't known ahead of time we can express it as a <code>function</code>. Functions are both a less specific version of a constant as well as a way to represent verbs.
</p>

<p>
In maths, functions represent "mappings" from some domain into some range/co-domain. For our purposes we can think of the "domain" as the types of values that are needed to create the value we want (the co-domain). For example, addition can be thought of as a function that takes two <code>int</code> values and creates another <code>int</code> value.
</p>

<p>
\[addition(x,y) = x + y\]
</p>

<p>
In order to translate this definition into C++ we need to follow these steps:
</p>
<ul class="org-ul">
<li>determine what <code>type</code> of value you want to construct later on
</li>
<li>come up with some name for the process of making the value (the function)
</li>
<li>determine what other values might be needed and their <code>type</code>
</li>
<li>write out an expression that, given all the inputs, will construct the value you want
</li>
</ul>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">addition</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> x + y;
}
</pre>
</div>

<p>
The above code is the implementation to the earlier math expression. The first part of the definition is the <code>type</code> of the value we'll construct later once we know what the inputs are. The second part is the name of the function so we can refer to our definition later. The third part is a comma seperated list of all the input values needed to make our result. 
</p>

<p>
These parts so far make up the "signature" of the function. This indicates all the information needed to use the function we've defined. It is a good idea first design the signature before trying to come up with the expression for the next part, the implementation.
</p>

<p>
The implementation of a function is the part surrounded by the curly braces. This section of the function defines the steps needed to construct the result. When the value is constructed we indicate this by using a <code>return</code> statement.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">plus_five</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> x + 5;
}

plus_five(10)
</pre>
</div>

<p>
The above function specifices a way to construct an <code>int</code> value from another <code>int</code>. Once the value \(x\) is known, <code>plus_five</code> will construct another <code>int</code> by adding five to \(x\).
</p>

<p>
The second part uses the defined function to construct the value <code>15</code>. This is refered to as "calling" the function. Note that all which is needed to use the function is its name and a comma seperated list of the inputs.
</p>

<div class="org-src-container">

<pre class="src src-cpp">addition(1,2)
</pre>
</div>

<p>
The above uses our previous defition of addition to construct <code>3</code>. The useful thing about functions is that they can work with data that doesn't exist until the program actual runs.
</p>

<p>
Functions are needed when certain values aren't known ahead of time. These unknown values become the inputs to the functions and the process of constructing these values are how <code>verbs</code> are represented in programming. All programs do is construct new values out of other values. For example, games construct images at 60 fps from values like player health, position, camera angles, etc. Many tasks within programming are similar and by defining more abstract expressions with functions we can end up reusing those definitions.
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> templates</h3>
<div class="outline-text-3" id="text-1-3">
<p>
The final level of abstraction in C++ can be achieved with <code>templates</code>. These kinds of values are needed when nothing is known about a value except that you need a value. This allows for the definition of very abstract concepts like a pair.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">B</span>&gt;
<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Pair</span> {
  <span style="color: #d26937;">A</span> <span style="color: #599cab;">first</span>;
  <span style="color: #d26937;">B</span> <span style="color: #599cab;">second</span>;
};

<span style="color: #195466; font-weight: bold;">template</span>&lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>&gt;
<span style="color: #d26937;">T</span> <span style="color: #599cab;">add_pair</span>(<span style="color: #d26937;">Pair</span>&lt;<span style="color: #d26937;">T</span>&gt; <span style="color: #599cab;">p</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> p.first + p.second;
}

</pre>
</div>

<p>
<code>template</code> values can be thought of as functions which take a <code>type</code> and return other <code>types</code>. In the above code we define a struct <code>Pair</code> which can hold a pair of <b>any</b> two types.
</p>

<p>
There are three parts to a template definition:
</p>
<ul class="org-ul">
<li>the keyword <code>template</code>
</li>
<li>a comma seperated list of <code>types</code>, with each of the types preceeded by the keyword <code>typename</code>
</li>
<li>the definition that uses the input types
</li>
</ul>

<p>
Templates are often used to define either very abstract concepts or used to make tools for programmers. Most programming languages will have a collection of templated functions and types which save the programmer time by defining concepts beforehand. For example, the <code>string</code> type in C++ is actually provided by a library.
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Summary</h3>
<div class="outline-text-3" id="text-1-4">
<p>
The first part of programming is determing how to break down a problem and then deciding how to represent the pieces. Any values which are known ahead of time can be defined with a constant. Any values which can't be constructed until other values are known (possibly when the program is run) can be defined by functions. Any values for which not even the <code>type</code> is known ahead of time can be defined by <code>templates</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Math Tools</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> basic math functions</h3>
<div class="outline-text-3" id="text-2-1">
<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">operation</th>
<th scope="col" class="text-left">function</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">addition</td>
<td class="text-left">\(+\)</td>
</tr>

<tr>
<td class="text-left">subtraction</td>
<td class="text-left">\(-\)</td>
</tr>

<tr>
<td class="text-left">multiplication</td>
<td class="text-left">\(*\)</td>
</tr>

<tr>
<td class="text-left">division</td>
<td class="text-left">\(/\)</td>
</tr>

<tr>
<td class="text-left">modulus</td>
<td class="text-left">\(\%\)</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>note that the word "operator" might show up in the place of function at some point.
</li>
<li>an operator is just a function with a funny symbol instead of a word for a name.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> representing expressions</h3>
<div class="outline-text-3" id="text-2-2">
<p>
The following expression can be translated into C++ like so:
</p>

<p>
\[\frac{2x + 5y}{3z}\]
</p>

<p>
Because we do not know the values of \(x\), \(y\), or \(z\) we'll have to make a function with those values as inputs.
</p>

<div class="org-src-container">

<pre class="src src-cpp">??? f(??? x, ??? y, ??? z) {
  <span style="color: #195466; font-weight: bold;">return</span> ???; 
}
</pre>
</div>

<p>
What type should be chosen for the inputs and result? Given that the expression contains division, it would make sense to allow for decimal numbers. Thus, <code>float</code> makes the most sense.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">float</span> <span style="color: #599cab;">f</span>(<span style="color: #d26937;">float</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">float</span> <span style="color: #599cab;">y</span>, <span style="color: #d26937;">float</span> <span style="color: #599cab;">z</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> ???; 
}
</pre>
</div>

<p>
Using the above table we can write out the expression.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">float</span> <span style="color: #599cab;">f</span>(<span style="color: #d26937;">float</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">float</span> <span style="color: #599cab;">y</span>, <span style="color: #d26937;">float</span> <span style="color: #599cab;">z</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> 2*x + 5*y / z;
}
</pre>
</div>

<p>
However, this expression is incorrect because of the standard order of operations:
</p>
<ol class="org-ol">
<li>Parenthesis
</li>
<li>Exponents
</li>
<li>Multiplication
</li>
<li>Division
</li>
<li>Addition
</li>
<li>Subtraction
</li>
</ol>

<p>
If the implicit parenthesis are added back, we get:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">float</span> <span style="color: #599cab;">f</span>(<span style="color: #d26937;">float</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">float</span> <span style="color: #599cab;">y</span>, <span style="color: #d26937;">float</span> <span style="color: #599cab;">z</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> (2*x) + ((5*y) / z);
}
</pre>
</div>

<p>
So if left as is, the expression will divide \(5y\) by \(z\) instead of \(2x + 5y\). To correct this we can just add in the parenthesis ourselves to ensure the correct order.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">float</span> <span style="color: #599cab;">f</span>(<span style="color: #d26937;">float</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">float</span> <span style="color: #599cab;">y</span>, <span style="color: #d26937;">float</span> <span style="color: #599cab;">z</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> (2*x + 5*y) / z;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> cmath</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Not all math operations are defined by default in C++. Many useful math functions need a library to work. For example, in order to represent \(x^2\) we'd need the <code>pow</code> function from <code>&lt;cmath&gt;</code>. 
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;iostream&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;cmath&gt;</span>
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #195466; font-weight: bold;">namespace</span> <span style="color: #33859e; font-weight: bold;">std</span>;

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  cout &lt;&lt; pow(2, 3);  
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">operation</th>
<th scope="col" class="text-left">function</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">logorithm</td>
<td class="text-left">log</td>
</tr>

<tr>
<td class="text-left">square root</td>
<td class="text-left">sqrt</td>
</tr>

<tr>
<td class="text-left">sin</td>
<td class="text-left">sin</td>
</tr>

<tr>
<td class="text-left">cos</td>
<td class="text-left">cos</td>
</tr>

<tr>
<td class="text-left">tan</td>
<td class="text-left">tan</td>
</tr>

<tr>
<td class="text-left">round up</td>
<td class="text-left">ceil</td>
</tr>

<tr>
<td class="text-left">round down</td>
<td class="text-left">floor</td>
</tr>

<tr>
<td class="text-left">round nearest to nearest</td>
<td class="text-left">trunc</td>
</tr>
</tbody>
</table>

<p>
There are many more functions defined in <code>&lt;cmath&gt;</code>. A complete list can be found at <a href="http://en.cppreference.com/w/cpp/header/cmath">here</a>.
</p>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> char math</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>remember that characters are represented as numbers in an ascii table
</li>
<li>every value of <code>char</code> is a number that corresponds to a symbol
</li>
<li>because <code>char</code> values are secretly numbers, you can actually do math with them
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">This converts a character letter (between 'A-Z') to its lower case</span>
<span style="color: #245361;">// </span><span style="color: #245361;">version by adding the difference between 'a' and 'A' since the number</span>
<span style="color: #245361;">// </span><span style="color: #245361;">for 'a' is greater than for 'A'</span>
<span style="color: #d26937;">char</span> <span style="color: #599cab;">lower_case</span>(<span style="color: #d26937;">char</span> <span style="color: #599cab;">c</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> c + (<span style="color: #2aa889;">'a'</span> - <span style="color: #2aa889;">'A'</span>);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> type conversions</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Below is a table of possible conversions for some value \(x\). Begin with a row for the starting type and go to the column for the desired type. The conversion \(int \rightarrow float\) is not the same as \(float \rightarrow int\) . Note that if a conversion isn't possible it will be labeled with NA for "not available".
</p>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">

<col  class="left">

<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">&#xa0;</th>
<th scope="col" class="text-left">int</th>
<th scope="col" class="text-left">float</th>
<th scope="col" class="text-left">char</th>
<th scope="col" class="text-left">string</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">int</td>
<td class="text-left">\(x\)</td>
<td class="text-left">\(x\)</td>
<td class="text-left">\(x\)</td>
<td class="text-left">\(to\_string(x)\)</td>
</tr>

<tr>
<td class="text-left">float</td>
<td class="text-left">\(trunc(x)\)</td>
<td class="text-left">\(x\)</td>
<td class="text-left">NA</td>
<td class="text-left">\(to\_string(x)\)</td>
</tr>

<tr>
<td class="text-left">char (digit)</td>
<td class="text-left">\(x\)</td>
<td class="text-left">NA</td>
<td class="text-left">\(x\)</td>
<td class="text-left">\(string(1, x)\)</td>
</tr>

<tr>
<td class="text-left">string</td>
<td class="text-left">\(stoi(x)\)</td>
<td class="text-left">\(stof(x)\)</td>
<td class="text-left">NA</td>
<td class="text-left">\(x\)</td>
</tr>
</tbody>
</table>

<p>
Several of these conversions, \(int \rightarrow float\) for example, will happen automatically. So if we have a function like:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">add_one</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> x + 1;
}
</pre>
</div>

<p>
Then if we attempt to use it with a <code>float</code> value, the float will automatically truncate into an <code>int</code>. Another conversion that happens implicitly is the conversion between a <code>char</code> and an <code>int</code>.
</p>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> string math</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>strings can be combined using <code>+</code>
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">combine("pop", "tart") would return "poptart"</span>
<span style="color: #d26937;">string</span> <span style="color: #599cab;">combine</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">first</span>, <span style="color: #d26937;">string</span> <span style="color: #599cab;">second</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> first + second;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> String Tools</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> find length of string</h3>
<div class="outline-text-3" id="text-3-1">
<p>
get the length
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">get_length</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> s.length();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> accessing parts of a string</h3>
<div class="outline-text-3" id="text-3-2">
</div><div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> front</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
gets the first character
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">get_first("hello") returns 'h'</span>
<span style="color: #d26937;">char</span> <span style="color: #599cab;">get_first</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> s.front();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> back</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
gets the last character
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">get_last("hello") returns 'o'</span>
<span style="color: #d26937;">char</span> <span style="color: #599cab;">get_last</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> s.back();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3"><span class="section-number-4">3.2.3</span> at</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
gets the character at a certain spot
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">get_at(1, "hello") returns 'e'</span>
<span style="color: #245361;">// </span><span style="color: #245361;">get_at(0, "hello") = get_front("hello")</span>
<span style="color: #245361;">// </span><span style="color: #245361;">get_at(4, "hello") = get_last("hello")</span>
<span style="color: #d26937;">char</span> <span style="color: #599cab;">get_at</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">spot</span>, <span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> s.at(spot);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2-4" class="outline-4">
<h4 id="sec-3-2-4"><span class="section-number-4">3.2.4</span> substr</h4>
<div class="outline-text-4" id="text-3-2-4">
<p>
gets the characters between some starting and ending spot
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">get_substr(1,4, "hello") returns "ello"</span>
<span style="color: #d26937;">string</span> <span style="color: #599cab;">get_substr</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">begin</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">end</span>, <span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> s.substr(begin, end);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> modifying a string</h3>
<div class="outline-text-3" id="text-3-3">
</div><div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1"><span class="section-number-4">3.3.1</span> insert</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
adds a character(s) into a string at a certain spot
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">insert_word("hello", 4, " world") returns "hello world"</span>
<span style="color: #245361;">// </span><span style="color: #245361;">insert_word(" really", 1, "I love cookies") returns "I really love cookies"</span>
<span style="color: #d26937;">string</span> <span style="color: #599cab;">insert_word</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">word</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">at</span>, <span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> s.insert(at, word);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2"><span class="section-number-4">3.3.2</span> erase</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
removes a character(s) at a certain spot
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">remove_word(2, 6, "I don't love cookies") returns "I love cookies"</span>
<span style="color: #d26937;">string</span> <span style="color: #599cab;">remove_word</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">at</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">length</span>, <span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> s.erase(at, length);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> searching a string</h3>
<div class="outline-text-3" id="text-3-4">
<p>
finds first occurence of substring
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">find_cake("Hello cake") returns 6</span>
<span style="color: #245361;">// </span><span style="color: #245361;">find_cake("hello friendo") returns -1</span>
<span style="color: #d26937;">int</span> <span style="color: #599cab;">find_cake</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> s.find(<span style="color: #2aa889;">"cake"</span>);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Choice and Decision Tools</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> how to make a decision?</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>empty the bag if it is full
</li>
<li>take the cake out of the oven when the timer is done
</li>
<li>bring me the biggest pumpkin 
</li>
<li>does this test belong to me?
</li>
<li>is this my car?
</li>
</ul>
</div>

<div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> a new type!</h4>
<div class="outline-text-4" id="text-4-1-1">
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #599cab;">bool</span> <span style="color: #599cab;">=</span> true <span style="color: #599cab;">|</span> false
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> some new combinators!</h4>
<div class="outline-text-4" id="text-4-1-2">
<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">meaning</th>
<th scope="col" class="text-left">operator</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">less than</td>
<td class="text-left">&lt;</td>
</tr>

<tr>
<td class="text-left">greater than</td>
<td class="text-left">&gt;</td>
</tr>

<tr>
<td class="text-left">equal to</td>
<td class="text-left">==</td>
</tr>

<tr>
<td class="text-left">less than or equal to</td>
<td class="text-left">&lt;=</td>
</tr>

<tr>
<td class="text-left">greater than or equal to</td>
<td class="text-left">&gt;=</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-4-1-3" class="outline-4">
<h4 id="sec-4-1-3"><span class="section-number-4">4.1.3</span> useful logic functions</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
not = !
or  = ||
and = &amp;&amp;
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> using comparisons to change result of function</h3>
<div class="outline-text-3" id="text-4-2">
</div><div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1"><span class="section-number-4">4.2.1</span> the ternary operator</h4>
<div class="outline-text-4" id="text-4-2-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #245361;">// </span><span style="color: #245361;">breaking up the problem doesn't help</span>
<span style="color: #d26937;">int</span> <span style="color: #599cab;">add_if_even_and_divisible_by_three</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">input</span>){
  <span style="color: #195466; font-weight: bold;">return</span> (even(input) &amp;&amp; divisible_by_three(input)) ? input + 5 : input;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-2" class="outline-4">
<h4 id="sec-4-2-2"><span class="section-number-4">4.2.2</span> reading the ternary operator</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
condition ? value1 : value2
</p>

<ul class="org-ul">
<li>evaluate the condition before <code>?</code> 
</li>
<li>if it evaluates to true, then value1 is the answer
</li>
<li>otherwise value2 is the answer
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Variables and Scope</h2>
<div class="outline-text-2" id="text-5">
<p>
We need to understand how C++ goes about representing the values which are passed back and forth between functions.
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> A Name and a Box</h3>
<div class="outline-text-3" id="text-5-1">
<p>
In mathematics, a variable is simply a name for a value which has not been given yet.
</p>

<p>
Examples:
</p>
<ul class="org-ul">
<li>area of circle: \[area(r) = \pi r^2\]
</li>
<li>area of triangle: \[area(b,h) = \frac{1}{2} bh\]
</li>
<li>line formula: \[y(m,x,b) = mx + b\]
</li>
</ul>

<p>
In all of these examples, the names \(x\), \(r\), \(b\), etc. are all placeholders which are swapped out when the values are eventually known. Functions are simply names for expressions and can be swapped out with their definitions. While this method is simple for humans to understand and work with, it is inefficent for a computer to perfectly emulate.
</p>

<p>
On a computer, a variable is name which refers to a box holding a value of some type.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 5;
</pre>
</div>


<figure>
<p><img src="./images/variables-and-scope/variable-with-type-with-value.png" class="img-responsive" alt="variable-with-type-with-value.png">
</p>
</figure>

<p>
There are three parts to defining a variable to work with in C++:
</p>
<ul class="org-ul">
<li>The type of the variables (int, bool, float, string, etc.)
</li>
<li>The name of the variable
</li>
<li>The value in the box (must match the type)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> The auto Keyword</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Writing out the types can be annoying (sometimes impossible). An alternative to explicitly writing out the type for a variable is to use the keyword <code>auto</code> in place of the actual type.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">MySuperLongAnnoyingNameForMyType</span> {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">thing1</span>;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">thing2</span>;
};

<span style="color: #d26937;">MySuperLongAnnoyingNameForMyType</span> <span style="color: #599cab;">add_numbers</span>(...) { ... } 

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">x</span> = 5;
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">word</span> = <span style="color: #33859e; font-weight: bold;">true</span>;
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">result</span> = add_numbers(...);
  ...
}
</pre>
</div>

<p>
In the above example, the function <code>add_numbers</code> returns a <code>MySuperLongAnnoyingNameForMyType</code>. Instead of having to write out the type for the variable, <code>auto</code> will tell C++ to look at the return type of <code>add_numbers</code> to figure out what the type of <code>result</code> is. 
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Assignment</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Unlike in maths, once the box has been filled with a value it can be changed as many times as we want.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 5;
cout &lt;&lt; <span style="color: #2aa889;">"before: "</span> &lt;&lt; x &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
x = 6;
cout &lt;&lt; <span style="color: #2aa889;">"after: "</span> &lt;&lt; x &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
</pre>
</div>


<figure>
<p><img src="./images/variables-and-scope/assignment.png" class="img-responsive" alt="assignment.png">
</p>
</figure>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> Variables can be Assigned to Eachother</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Because the variable is a name which refers to a value, these names can be used anywhere a value of that type would have been accepted. For example, if we wanted to fill one variable's box with a value, we could use the value of another variable to fill it.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 5;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span> = 10;
x = y;
cout &lt;&lt; x &lt;&lt; <span style="color: #2aa889;">" "</span> &lt;&lt; y &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
</pre>
</div>


<figure>
<p><img src="./images/variables-and-scope/assignment-with-another-variable.png" class="img-responsive" alt="assignment-with-another-variable.png">
</p>
</figure>

<p>
Notice that after the assignment there remains two separate boxes. With normal variables, <b>assignment does not result in two names refering to the same box</b>. The contents of one box is copied into the other box. If \(y\) is assigned to \(x\), later changing \(x\) does not affect \(y\).
</p>
</div>
</div>

<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> Function Evaluation and Scope</h3>
<div class="outline-text-3" id="text-5-5">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">line</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">m</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">b</span>){
  <span style="color: #195466; font-weight: bold;">return</span> (m * x) + b;
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">m</span> = 5;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 4;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">b</span> = 3;
  cout &lt;&lt; line(m,x,b);
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
When the program is evaluated it starts from the first line of <code>main()</code> and runs the program, line by line, until it reaches the <code>return 0;</code>. Every line with a variable creates a new box which the name refers to. When a function is called, we jump to the first line of that function (in this case <code>line()</code>). New variables are created for each of the inputs and filled with the values passed in when the function was called.
</p>

<p>
What happens if the inputs to a function have the same names as existing variables? Fortunately, this isn't a problem because functions create their own <b>scope</b>.
</p>


<figure>
<p><img src="./images/variables-and-scope/line-example/line-example.png" class="img-responsive" alt="line-example.png">
</p>
</figure>

<p>
A scope can be thought of as a room. Imagine a school with multiple people who have the same name. If all of the students were looking down and they heard their name called, they would be confused as to whether it was them being called on. However, this isn't a problem if none of them are in the same room.
</p>

<p>
This is how the problem of many variables with the same name is solved. A name can only be used by one variable at a time in each scope. So long as variables are in different scopes, their names do not conflict.
</p>
</div>
</div>

<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> References</h3>
<div class="outline-text-3" id="text-5-6">
<p>
While the default for variables is for a name to refer to its own unique box, it is possible for a name to refer to an existing box.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">line</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">m</span>, <span style="color: #d26937;">int</span>&amp; <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">b</span>){
  <span style="color: #195466; font-weight: bold;">return</span> (m * x) + b;
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">m</span> = 5;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 4;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">b</span> = 3;
  cout &lt;&lt; line(m,x,b);
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>


<figure>
<p><img src="./images/variables-and-scope/line-example/line-example-reference-1.png" class="img-responsive" alt="line-example-reference-1.png">
</p>
</figure>

<p>
This means that what ever operations are done to the name \(x\) within line will also affect the box of the \(x\) inside of main.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">line</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">m</span>, <span style="color: #d26937;">int</span>&amp; <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span>&amp; <span style="color: #599cab;">b</span>){
  <span style="color: #195466; font-weight: bold;">return</span> (m * x) + b;
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">m</span> = 5;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 4;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">b</span> = 3;
  cout &lt;&lt; line(m,b,b);
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>


<figure>
<p><img src="./images/variables-and-scope/line-example/line-example-reference-2.png" class="img-responsive" alt="line-example-reference-2.png">
</p>
</figure>

<p>
If the same box is passed in for both references, the names \(x\) and \(b\) will refer to the <b>same</b> box.
</p>
</div>
</div>

<div id="outline-container-sec-5-7" class="outline-3">
<h3 id="sec-5-7"><span class="section-number-3">5.7</span> Pointers</h3>
<div class="outline-text-3" id="text-5-7">
<p>
While references can refer to existing boxes, pointers are special variables which have a box that holds <b>references</b> to other values. 
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 5;
  <span style="color: #d26937;">int</span>* <span style="color: #599cab;">y</span> = &amp;x;
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>


<figure>
<p><img src="./images/variables-and-scope/pointer-example/1.png" class="img-responsive" alt="1.png">
</p>
</figure>

<p>
Pointers cannot be used as normal variables unless they are dereferenced.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">add</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">a</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">b</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> a + b;
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 5;
  <span style="color: #d26937;">int</span>* <span style="color: #599cab;">y</span> = &amp;x;
  cout &lt;&lt; add(x, (*y));
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
Dereferencing a pointer tells C++ to "follow" the reference to the box it's pointing at. This is what happens with normal variables and references, except neither can actually change which box they are refering to.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">add</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">a</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">b</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> a + b;
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 5;
  <span style="color: #d26937;">int</span>* <span style="color: #599cab;">y</span> = &amp;x;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">z</span> = 10;
  y = &amp;z;
  cout &lt;&lt; add(x, (*y));
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>


<figure>
<p><img src="./images/variables-and-scope/pointer-example/2.png" class="img-responsive" alt="2.png">
</p>
</figure>

<p>
Pointers are needed when unknown amounts of data are created at runtime. For example, if a file is loaded into memory, the program can't know ahead of time how the contents are. If the size cannot be known ahead of time, then it is impossible to use a normal variable for it. To get around this, the memory is reserved when the file is loaded and the result is a pointer to this data.
</p>

<p>
When initially created, pointers will refer to a speciall value called <code>Null</code>. If a pointer is set to <code>Null</code> it means it does not currently refer to any existing value. If you attempt to dereference a null pointer it will cause the program to crash.
</p>
</div>
</div>

<div id="outline-container-sec-5-8" class="outline-3">
<h3 id="sec-5-8"><span class="section-number-3">5.8</span> Side effects</h3>
<div class="outline-text-3" id="text-5-8">
<p>
References and pointers are dangerous to work with given that they can manipulate values which are outside of the scope they exist in. Misuse of these tools can lead to problems that are difficult to track down <b>if</b> you can even correctly detect where the problem is happening. Pointers especially have a tendency to blow up some time after they are actually created due to the <code>Null</code> value.
</p>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">

<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">variable type</th>
<th scope="col" class="text-left">symbol</th>
<th scope="col" class="text-left">example</th>
<th scope="col" class="text-left">when to use</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">value</td>
<td class="text-left">(none)</td>
<td class="text-left">int</td>
<td class="text-left">most of the time, it is the safest option</td>
</tr>

<tr>
<td class="text-left">reference</td>
<td class="text-left">&amp;</td>
<td class="text-left">int&amp;</td>
<td class="text-left">with <b>big</b> values that are too expensive to be copied</td>
</tr>

<tr>
<td class="text-left">pointers</td>
<td class="text-left">*</td>
<td class="text-left">int*</td>
<td class="text-left">when working with data whose size is unknown beforehand</td>
</tr>
</tbody>
</table>

<p>
In modern practice, there are several alternatives to using "raw" pointers. While they will not be discussed here, you can find more information about "smart pointers" at these links:
</p>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one">https://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one</a>
</li>
<li><a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">http://en.cppreference.com/w/cpp/memory/unique_ptr</a>
</li>
<li><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">http://en.cppreference.com/w/cpp/memory/shared_ptr</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-9" class="outline-3">
<h3 id="sec-5-9"><span class="section-number-3">5.9</span> When to use Variables?</h3>
<div class="outline-text-3" id="text-5-9">
<p>
Variables can come in handy when writing functions that use the same result in more than one place.
</p>

<p>
Lets write a function that transforms names from first, middle, then last to last, first middle with a comma after the last name.
</p>
<pre class="example">
"Robert Milton Jones" -&gt; "Jones, Robert Milton"
"Tom Marvolo Riddle" -&gt; "Riddle, Tom Marvolo"
"John Jacob Jingleheimer" -&gt; "Jingleheimer, Jon Jacob"
</pre>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">name_swap</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>){
  <span style="color: #195466; font-weight: bold;">return</span> (name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length() - 1))
         .substr(
           (name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length()-1)
             .find(<span style="color: #2aa889;">' '</span>) + 1), 
           (name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length()-1))
             .length() - 1)
       + <span style="color: #2aa889;">", "</span>
       + (name.substr(0, name.find(<span style="color: #2aa889;">' '</span>) - 1))
       + <span style="color: #2aa889;">" "</span>
       + (name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length() - 1))
         .substr(
           0, 
           ((name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length() - 1))
         .find(<span style="color: #2aa889;">' '</span>) - 1))
       ;
}
</pre>
</div>
<p>
if we follow the normal algorithm, we get this disgusting mess
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">first_name</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> name.substr(0, name.find(<span style="color: #2aa889;">' '</span>) - 1);
}
<span style="color: #d26937;">string</span> <span style="color: #599cab;">middle_name</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> (name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length() - 1))
         .substr(
           0, 
           ((name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length() - 1))
         .find(<span style="color: #2aa889;">' '</span>) - 1;
}
<span style="color: #d26937;">string</span> <span style="color: #599cab;">last_name</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> (name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length() - 1))
         .substr(
           (name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length()-1)
             .find(<span style="color: #2aa889;">' '</span>) + 1), 
           (name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length()-1))
             .length() - 1);
}
<span style="color: #d26937;">string</span> <span style="color: #599cab;">name_swap</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>){
  <span style="color: #195466; font-weight: bold;">return</span> last_name(name) 
       + <span style="color: #2aa889;">", "</span>
       + first_name(name)
       + <span style="color: #2aa889;">" "</span>
       + middle_name(name);
}
</pre>
</div>
<p>
we could try making seperate functions to get each name, but that just moves the problem
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">first_name</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> name.substr(0, name.find(<span style="color: #2aa889;">' '</span>) - 1);
}
<span style="color: #d26937;">string</span> <span style="color: #599cab;">middle_last</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length() - 1);
}
<span style="color: #d26937;">string</span> <span style="color: #599cab;">middle_name</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> middle_last(name) 
         .substr(0, middle_last(name).find(<span style="color: #2aa889;">' '</span>) - 1);
}
<span style="color: #d26937;">string</span> <span style="color: #599cab;">last_name</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> middle_last(name).substr(
           middle_last(name).find(<span style="color: #2aa889;">' '</span>) + 1, 
           middle_last(name).length() - 1);
}
<span style="color: #d26937;">string</span> <span style="color: #599cab;">name_swap</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>){
  <span style="color: #195466; font-weight: bold;">return</span> last_name(name) 
       + <span style="color: #2aa889;">", "</span>
       + first_name(name)
       + <span style="color: #2aa889;">" "</span>
       + middle_name(name);
}
</pre>
</div>

<p>
If you see the same pattern more than twice, you should make a function, however it's a bit annoying to have to write out new functions in C++'s bulky syntax all the time. If these functions will never be used again, then it would be preferable to just define variables within the function to hold onto the intermediate results.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">name_swap</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>){

  <span style="color: #d26937;">string</span> <span style="color: #599cab;">first_name</span> = name.substr(0, name.find(<span style="color: #2aa889;">' '</span>) - 1);

  <span style="color: #d26937;">string</span> <span style="color: #599cab;">middle_last</span> = 
    name.substr(name.find(<span style="color: #2aa889;">' '</span>) + 1, name.length() - 1);

  <span style="color: #d26937;">string</span> <span style="color: #599cab;">middle_name</span> = 
    middle_last.substr(0, middle_last.find(<span style="color: #2aa889;">' '</span>) - 1);

  <span style="color: #d26937;">string</span> <span style="color: #599cab;">last_name</span> = 
    middle_last.substr(
       middle_last.find(<span style="color: #2aa889;">' '</span>) + 1, 
       middle_last.length() - 1);

  <span style="color: #195466; font-weight: bold;">return</span> last_name + <span style="color: #2aa889;">", "</span> + first_name + <span style="color: #2aa889;">" "</span> + middle_name; 
}
</pre>
</div>

<p>
This is safe so long as we don't change what the variables hold and if the order in which the results are used doesn't matter.
</p>
</div>
</div>

<div id="outline-container-sec-5-10" class="outline-3">
<h3 id="sec-5-10"><span class="section-number-3">5.10</span> When to not use Variables</h3>
<div class="outline-text-3" id="text-5-10">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">division</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>){
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">result</span> = x / y;
  <span style="color: #195466; font-weight: bold;">return</span> y == 0 ? <span style="color: #2aa889;">"fail!"</span> : to_string(result);
}
</pre>
</div>

<p>
In this case it is unsafe to store the result in a variable because it is calculated before the safety check! Remember that programs execute statements in order, so if \(y\) happens to be zero, it will attempt the division and crash the program before the check can catch it.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Functions as Values</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> C++ function variables</h3>
<div class="outline-text-3" id="text-6-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">add</span> = [] (<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>)  { <span style="color: #195466; font-weight: bold;">return</span>  x + y; };
</pre>
</div>


<figure>
<p><img src="./images/functions-as-values/lambda-value.png" class="img-responsive" alt="lambda-value.png">
</p>
</figure>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">add</span> = [] (<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>)  { <span style="color: #195466; font-weight: bold;">return</span>  x + y; };
<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = add(5,5);
</pre>
</div>


<figure>
<p><img src="./images/functions-as-values/lambda-no-capture-eval-1.png" class="img-responsive" alt="lambda-no-capture-eval-1.png">
</p>
</figure>


<figure>
<p><img src="./images/functions-as-values/lambda-no-capture-eval-2.png" class="img-responsive" alt="lambda-no-capture-eval-2.png">
</p>
</figure>


<figure>
<p><img src="./images/functions-as-values/lambda-no-capture-eval-3.png" class="img-responsive" alt="lambda-no-capture-eval-3.png">
</p>
</figure>


<figure>
<p><img src="./images/functions-as-values/lambda-no-capture-eval-4.png" class="img-responsive" alt="lambda-no-capture-eval-4.png">
</p>
</figure>


<figure>
<p><img src="./images/functions-as-values/lambda-no-capture-eval-5.png" class="img-responsive" alt="lambda-no-capture-eval-5.png">
</p>
</figure>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> lambda capture</h3>
<div class="outline-text-3" id="text-6-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 10;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">addX</span> = [x](<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>) { <span style="color: #195466; font-weight: bold;">return</span> x + y; };
</pre>
</div>


<figure>
<p><img src="./images/functions-as-values/lambda-capture-by-value.png" class="img-responsive" alt="lambda-capture-by-value.png">
</p>
</figure>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 10;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">addX</span> = [&amp;x](<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>) { <span style="color: #195466; font-weight: bold;">return</span> x + y; };
</pre>
</div>


<figure>
<p><img src="./images/functions-as-values/lambda-capture-by-reference.png" class="img-responsive" alt="lambda-capture-by-reference.png">
</p>
</figure>
</div>

<div id="outline-container-sec-6-2-1" class="outline-4">
<h4 id="sec-6-2-1"><span class="section-number-4">6.2.1</span> Capture Practice 1</h4>
<div class="outline-text-4" id="text-6-2-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 10;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span> = 5;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">z</span> = 22;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">f</span> = [???]() { <span style="color: #195466; font-weight: bold;">return</span> x + y + z; };
</pre>
</div>
<p>
What needs to be captured?
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 10;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span> = 5;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">z</span> = 22;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">f</span> = [x,y,z]() { <span style="color: #195466; font-weight: bold;">return</span> x + y + z; };
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-2-2" class="outline-4">
<h4 id="sec-6-2-2"><span class="section-number-4">6.2.2</span> Capture Practice 2</h4>
<div class="outline-text-4" id="text-6-2-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 10;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span> = 5;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">z</span> = 22;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">f</span> = [???](<span style="color: #d26937;">int</span> <span style="color: #599cab;">a</span>) { <span style="color: #195466; font-weight: bold;">return</span> a + y + z; };
</pre>
</div>
<p>
What needs to be captured?
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 10;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span> = 5;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">z</span> = 22;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">f</span> = [y,z](<span style="color: #d26937;">int</span> <span style="color: #599cab;">a</span>) { <span style="color: #195466; font-weight: bold;">return</span> a + y + z; };
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-2-3" class="outline-4">
<h4 id="sec-6-2-3"><span class="section-number-4">6.2.3</span> Capture Practice 3</h4>
<div class="outline-text-4" id="text-6-2-3">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 10;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span> = 5;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">z</span> = 22;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">f</span> = [???](<span style="color: #d26937;">int</span> <span style="color: #599cab;">a</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>) { <span style="color: #195466; font-weight: bold;">return</span> a + y + z; };
</pre>
</div>
<p>
What needs to be captured?
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span> = 10;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span> = 5;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">z</span> = 22;
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">f</span> = [z](<span style="color: #d26937;">int</span> <span style="color: #599cab;">a</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>) { <span style="color: #195466; font-weight: bold;">return</span> a + y + z; };
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> passing functions to other functions</h3>
<div class="outline-text-3" id="text-6-3">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;functional&gt;</span>

<span style="color: #245361;">// </span><span style="color: #245361;">the functional header is needed for the function type</span>
<span style="color: #d26937;">int</span> <span style="color: #599cab;">do_math</span>(<span style="color: #d26937;">function</span>&lt;<span style="color: #d26937;">int</span>(<span style="color: #d26937;">int</span>,<span style="color: #d26937;">int</span>)&gt; <span style="color: #599cab;">op</span>, <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">int</span>&amp; <span style="color: #599cab;">x</span>, <span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">int</span>&amp; <span style="color: #599cab;">y</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> op(x,y);
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">add</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>) { <span style="color: #195466; font-weight: bold;">return</span> x + y; };

do_math(add, 7, 3); <span style="color: #245361;">// </span><span style="color: #245361;">10</span>
</pre>
</div>


<figure>
<p><img src="./images/functions-as-values/passing-functions-1.png" class="img-responsive" alt="passing-functions-1.png">
</p>
</figure>

<figure>
<p><img src="./images/functions-as-values/passing-functions-2.png" class="img-responsive" alt="passing-functions-2.png">
</p>
</figure>

<figure>
<p><img src="./images/functions-as-values/passing-functions-3.png" class="img-responsive" alt="passing-functions-3.png">
</p>
</figure>

<figure>
<p><img src="./images/functions-as-values/passing-functions-4.png" class="img-responsive" alt="passing-functions-4.png">
</p>
</figure>

<figure>
<p><img src="./images/functions-as-values/passing-functions-5.png" class="img-responsive" alt="passing-functions-5.png">
</p>
</figure>

<figure>
<p><img src="./images/functions-as-values/passing-functions-6.png" class="img-responsive" alt="passing-functions-6.png">
</p>
</figure>
</div>
</div>

<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> what are the uses of lambdas?</h3>
<div class="outline-text-3" id="text-6-4">
</div><div id="outline-container-sec-6-4-1" class="outline-4">
<h4 id="sec-6-4-1"><span class="section-number-4">6.4.1</span> less repetition in code</h4>
<div class="outline-text-4" id="text-6-4-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">Tag</span> = string;
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">HP</span> = <span style="color: #d26937;">int</span>;

<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Action</span> {
  ...
};

<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Unit</span> {
  ...
};

<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">AiUnit</span> {
  <span style="color: #d26937;">Tag</span> <span style="color: #599cab;">id</span>;
  <span style="color: #d26937;">HP</span> <span style="color: #599cab;">hp</span>;
  <span style="color: #d26937;">Unit</span>* <span style="color: #599cab;">target</span>;
  <span style="color: #d26937;">function</span>&lt;Action(<span style="color: #599cab;">Unit</span>*, <span style="color: #d26937;">HP</span>)&gt; <span style="color: #599cab;">behavior</span>;
};
</pre>
</div>

<p>
The AiUnit can have its individual behavior swapped out by simply assigning a new function
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Collections of Fixed Size</h2>
<div class="outline-text-2" id="text-7">
<p>
in C++, arrays represent fixed length collections
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">char</span> <span style="color: #599cab;">letters</span>[5] = {<span style="color: #2aa889;">'a'</span>,<span style="color: #2aa889;">'b'</span>,<span style="color: #2aa889;">'c'</span>,<span style="color: #2aa889;">'d'</span>,<span style="color: #2aa889;">'e'</span>};
</pre>
</div>


<figure>
<p><img src="./images/array-introduction/array-in-memory.png" class="img-responsive" alt="array-in-memory.png">
</p>
</figure>

<p>
Previously, if we wanted to talk about a collecction, we'd have to make a big struct
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">Age</span> = <span style="color: #d26937;">int</span>;
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">Name</span> = string;
<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Person</span> { <span style="color: #d26937;">Age</span> <span style="color: #599cab;">age</span>; <span style="color: #d26937;">Name</span> <span style="color: #599cab;">name</span>; };

<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">TeamName</span> = string;
<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Team</span> { 
  <span style="color: #d26937;">TeamName</span> <span style="color: #599cab;">name</span>; 
  <span style="color: #d26937;">Person</span> <span style="color: #599cab;">coach</span>;
  <span style="color: #d26937;">Person</span> <span style="color: #599cab;">quater_back</span>;
  <span style="color: #d26937;">Person</span> <span style="color: #599cab;">wide_reciever</span>;
  ...
};
</pre>
</div>

<p>
Now we can represent collections with arrays
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">Age</span> = <span style="color: #d26937;">int</span>;
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">Name</span> = string;
<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Person</span> { <span style="color: #d26937;">Age</span> <span style="color: #599cab;">age</span>; <span style="color: #d26937;">Name</span> <span style="color: #599cab;">name</span>; };

<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">TeamName</span> = string;
<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Team</span> { 
  <span style="color: #d26937;">TeamName</span> <span style="color: #599cab;">name</span>; 
  <span style="color: #d26937;">Person</span> <span style="color: #599cab;">captain</span>;

  <span style="color: #245361;">// </span><span style="color: #245361;">instead of having a value for each player</span>
  <span style="color: #245361;">// </span><span style="color: #245361;">use an array to represent the team</span>
  <span style="color: #d26937;">Person</span> <span style="color: #599cab;">players</span>[11];
};
</pre>
</div>
</div>

<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> accessing array elements</h3>
<div class="outline-text-3" id="text-7-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>&gt;
<span style="color: #d26937;">T</span> <span style="color: #599cab;">first_of_five</span>(<span style="color: #d26937;">T</span> <span style="color: #599cab;">stuff</span>[5]) {
  <span style="color: #195466; font-weight: bold;">return</span> stuff[0];
}

<span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>&gt;
<span style="color: #d26937;">T</span> <span style="color: #599cab;">second_of_five</span>(<span style="color: #d26937;">T</span> <span style="color: #599cab;">stuff</span>[5]) {
  <span style="color: #195466; font-weight: bold;">return</span> stuff[1];
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">numbers</span>[5] = { 1,2,3,4,5 };
first_of_five(numbers); <span style="color: #245361;">// </span><span style="color: #245361;">1</span>

<span style="color: #d26937;">int</span> <span style="color: #599cab;">truths</span>[5] = { <span style="color: #33859e; font-weight: bold;">true</span>, <span style="color: #33859e; font-weight: bold;">false</span>, <span style="color: #33859e; font-weight: bold;">true</span>, <span style="color: #33859e; font-weight: bold;">true</span>, <span style="color: #33859e; font-weight: bold;">false</span> };
second_of_five(truths); <span style="color: #245361;">// </span><span style="color: #245361;">false</span>
</pre>
</div>

<ul class="org-ul">
<li>arrays start from 0
</li>
<li>the index represents spaces from the start
</li>
</ul>


<figure>
<p><img src="./images/array-introduction/array-assignment-1.png" class="img-responsive" alt="array-assignment-1.png">
</p>
</figure>

<figure>
<p><img src="./images/array-introduction/array-assignment-2.png" class="img-responsive" alt="array-assignment-2.png">
</p>
</figure>

<figure>
<p><img src="./images/array-introduction/array-assignment-3.png" class="img-responsive" alt="array-assignment-3.png">
</p>
</figure>
</div>
</div>

<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> modifying array elements</h3>
<div class="outline-text-3" id="text-7-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">char</span> <span style="color: #599cab;">letters</span>[5] = {<span style="color: #2aa889;">'a'</span>, <span style="color: #2aa889;">'b'</span>, <span style="color: #2aa889;">'c'</span>, <span style="color: #2aa889;">'d'</span>, <span style="color: #2aa889;">'e'</span>};
<span style="color: #d26937;">int</span> <span style="color: #599cab;">i</span> = 0;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">j</span> = 3;
letters[i] = letters[j];
</pre>
</div>


<figure>
<p><img src="./images/array-introduction/modifying-array-1.png" class="img-responsive" alt="modifying-array-1.png">
</p>
</figure>

<figure>
<p><img src="./images/array-introduction/modifying-array-2.png" class="img-responsive" alt="modifying-array-2.png">
</p>
</figure>

<figure>
<p><img src="./images/array-introduction/modifying-array-3.png" class="img-responsive" alt="modifying-array-3.png">
</p>
</figure>

<figure>
<p><img src="./images/array-introduction/modifying-array-4.png" class="img-responsive" alt="modifying-array-4.png">
</p>
</figure>
</div>
</div>

<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> warning</h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li>arrays are always passed by reference
</li>
<li>there is no way to return a raw array
</li>
<li>cannot use == to compare arrays
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> Better array type</h3>
<div class="outline-text-3" id="text-7-4">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;array&gt;</span>

<span style="color: #33859e; font-weight: bold;">std</span>::<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">int</span>, 5&gt; <span style="color: #599cab;">numbers</span> = { 1,2,3,4,5 };
</pre>
</div>

<ul class="org-ul">
<li>Can return std::array from functions
</li>
<li>Has lots of nice functions like .front, .back, and works with comparison operations
</li>
</ul>

<p>
But how can we use all of the elements of a vector?
</p>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Recursion</h2>
<div class="outline-text-2" id="text-8">
<p>
There are five steps for recursion:
</p>

<ol class="org-ol">
<li>Find the "do nothing" input 
</li>
<li>Find the "do nothing" step 
</li>
<li>Break off the front
</li>
<li>Make the problem smaller
</li>
<li>Combine results
</li>
</ol>
</div>

<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> Finding the do-nothing step and input</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Although we're solving problems with steps that repeat, eventually there is a point where the problem is solved and no more work needs to be done.
</p>

<p>
Consider the problem of adding up all the numbers from some integer <b>10</b> to <b>1</b>. When written out this is what we want to happen:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum_10_to_1</span>(){
  <span style="color: #195466; font-weight: bold;">return</span> 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1;
}
</pre>
</div>

<p>
If we zoom in on the front of the problem we see something like this:
</p>

<div class="org-src-container">

<pre class="src src-cpp">10 + ...
</pre>
</div>

<p>
The integer <b>10</b> plus some other stuff. We are looking for a place where more work is needed so we'll have to go to the other end of the expression:
</p>

<div class="org-src-container">

<pre class="src src-cpp">... 1
</pre>
</div>

<p>
Here we have nothing more to add and conveniently we've also found our do-nothing input. If the problem was add all the numbers from <b>1</b> to <b>1</b>, then the result would just be <b>1</b>. Nothing happens. So how can we simulate doing nothing with additon? Well, adding 0 to any number does nothing, so in this case plus 0 is our do-nothing step.
</p>

<p>
So how can we generalize this to adding up all the numbers from some integer <b>n</b> to <b>1</b>? Well when written out we see something similar to what we had last time:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> n + (n-1) + (n-2) + ... + 1;
}
</pre>
</div>

<p>
Only, in this case, we don't know exactly how many terms we need to add up. That being said, we can see our do-nothing step has not changed. When we are uncertain of how many steps we need to actually repeat we'll have to come up with some kind of check to tell when we've reached the do-nothing step.
</p>

<p>
In this case our check could be:
</p>

<div class="org-src-container">

<pre class="src src-cpp">n == 1
</pre>
</div>

<p>
Common do-nothing inputs are:
</p>
<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">type</th>
<th scope="col" class="text-left">input</th>
<th scope="col" class="text-left">check</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">numbers</td>
<td class="text-left">0 or 1</td>
<td class="text-left">== 0</td>
</tr>

<tr>
<td class="text-left">string</td>
<td class="text-left">""</td>
<td class="text-left">== ""</td>
</tr>

<tr>
<td class="text-left">vector</td>
<td class="text-left">{}</td>
<td class="text-left">.empty()</td>
</tr>
</tbody>
</table>


<p>
Once we've established when no more work has to be done and what the result should be in that case, we can move on to actually doing some of the work.
</p>
</div>
</div>

<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> Breaking off the front</h3>
<div class="outline-text-3" id="text-8-2">
<p>
Because we cannot always know ahead of time how much work has to be done, like in the case of adding all the numbers from <b>n</b> to <b>1</b>, we need to find some way of breaking off a piece of the problem so we only need to program one step at a time.
</p>

<p>
Let's say we wanted to take some <code>string</code>, say <b>"hello"</b> and make it all captials, <b>"HELLO"</b>. This problem as it is cannot be solved using the tools we know so far, however we do know how to make a <code>char</code> upper case using <code>toupper()</code>.
</p>

<p>
In this case, breaking off the front can be taken literally, grab the first character of the <code>string</code> using <code>.front()</code>.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #599cab;">string</span>(<span style="color: #2aa889;">"hello"</span>).front()
</pre>
</div>

<p>
Now that we have a character to work with, we can simply apply <code>toupper()</code> to get the first value of our desired result <b>'H'</b>.
</p>

<div class="org-src-container">

<pre class="src src-cpp">toupper(string(<span style="color: #2aa889;">"hello"</span>).front())
</pre>
</div>

<p>
This can easily be generalized to any string by replace the literal <b>"hello"</b> with a variable, lets say <b>s</b>:
</p>

<div class="org-src-container">

<pre class="src src-cpp">toupper(s.front())
</pre>
</div>

<p>
If we return to the problem of adding numbers from <b>n</b> to <b>1</b> we can see a similar process is used, although it is not as obvious. In this case we aren't literally breaking off the front of the number, instead we are breaking off the front of the expression we want in the end:
</p>

<div class="org-src-container">

<pre class="src src-cpp">n | + (n-1) + (n-2) + ... + 1
</pre>
</div>

<p>
Here, after we break off the front we get the number <b>n</b> all by itself. Sometimes, breaking off the front doesn't have another step as with making the <b>char</b> into uppercase. This is fine because it still helps with the next step.
</p>
</div>
</div>

<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> Making the problem smaller</h3>
<div class="outline-text-3" id="text-8-3">
<p>
The trick to recursion is to solve a piece of the problem, and then make use of the results for a smaller version of the problem. We've already seen how to do the small step by breaking off the front, but we also need to figure out how to make the problem as a whole smaller.
</p>

<p>
For example, when adding up numbers after breaking off the front, we automatically get a smaller version of the problem:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">front</span> = n;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">smaller</span> = (n-1) + (n-2) + ... + 1;
  <span style="color: #195466; font-weight: bold;">return</span> front + smaller;
}
</pre>
</div>

<p>
In order to solve <code>sum(n)</code> we need to figure out how to solve <code>(n-1) + (n-2) + ...</code>, however notice that it has almost exactly the same shape as our original problem. To make this more apparent, we can give a new name to <code>(n-1)</code>.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #599cab;">step</span> 1<span style="color: #d26937;">:</span> assume sum<span style="color: #99d1ce;">(</span>x<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">=</span> x <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>x <span style="color: #599cab;">-</span> 1<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>x <span style="color: #599cab;">-</span> 2<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>x <span style="color: #599cab;">-</span> 3<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #599cab;">...</span> <span style="color: #599cab;">+</span> 1
<span style="color: #599cab;">step</span> 2<span style="color: #d26937;">:</span> given <span style="color: #99d1ce;">(</span>n <span style="color: #599cab;">-</span> 1<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>n <span style="color: #599cab;">-</span> 2<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>n <span style="color: #599cab;">-</span> 3<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #599cab;">...</span> <span style="color: #599cab;">+</span> 1
<span style="color: #599cab;">step</span> 3<span style="color: #d26937;">:</span> <span style="color: #99d1ce;">(</span>n <span style="color: #599cab;">-</span> 1<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>n <span style="color: #599cab;">-</span> 1 <span style="color: #599cab;">-</span> 1<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>n <span style="color: #599cab;">-</span> 1 <span style="color: #599cab;">-</span> 2<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #599cab;">...</span> <span style="color: #599cab;">+</span> 1
<span style="color: #599cab;">step</span> 4<span style="color: #d26937;">:</span> <span style="color: #195466; font-weight: bold;">let</span> m <span style="color: #599cab;">=</span> n <span style="color: #599cab;">-</span> 1
<span style="color: #599cab;">step</span> 5<span style="color: #d26937;">:</span> m <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>m <span style="color: #599cab;">-</span> 1<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>m <span style="color: #599cab;">-</span> 2<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>m <span style="color: #599cab;">-</span> 3<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #599cab;">...</span> <span style="color: #599cab;">+</span> 1
<span style="color: #599cab;">step</span> 6<span style="color: #d26937;">:</span> using step 1 <span style="color: #599cab;">=&gt;</span> sum<span style="color: #99d1ce;">(</span>m<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">=</span> m <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>m <span style="color: #599cab;">-</span> 1<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>m <span style="color: #599cab;">-</span> 2<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #99d1ce;">(</span>m <span style="color: #599cab;">-</span> 3<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">+</span> <span style="color: #599cab;">...</span> <span style="color: #599cab;">+</span> 1
<span style="color: #599cab;">step</span> 7<span style="color: #d26937;">:</span> using step 4 <span style="color: #599cab;">=&gt;</span> sum<span style="color: #99d1ce;">(</span>m<span style="color: #99d1ce;">)</span> <span style="color: #599cab;">=</span> sum<span style="color: #99d1ce;">(</span>n<span style="color: #599cab;">-</span>1<span style="color: #99d1ce;">)</span>
</pre>
</div>

<p>
If we replace <code>(n-1)</code> with <code>m</code> we can see that our smaller problem has exactly the same shape as our orignal problem! Which means if the solution to <code>n + (n-1) + (n-2) + ... + 1</code> is <code>sum(n)</code> then the solution to <code>(n-1) + (n-2) + (n-3) + ... + 1</code> should be <code>sum(n-1)</code>.
</p>

<p>
<b>This</b> is the key to recursion! Because the steps we need to do are repeated, a smaller version of the problem can be solved in <b>exactly</b> the same way. So the solution of <code>(n-1) + (n-2) + ...</code> is simply <code>sum(n-1)</code>!
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">front</span> = n;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">smaller</span> = sum(n-1);
  <span style="color: #195466; font-weight: bold;">return</span> front + smaller;
}
</pre>
</div>

<p>
However, there is a problem if we stop here. Notice that happens if we do <code>sum(1)</code>, our do-nothing input from before:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(1) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">front</span> = 1;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">smaller</span> = sum(1-1);
  <span style="color: #195466; font-weight: bold;">return</span> front + smaller;
}
</pre>
</div>

<p>
What is the result of <code>sum(0)</code>? We could plug in <b>0</b> for <b>n</b> and find out:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(0) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">front</span> = 0;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">smaller</span> = sum(0-1);
  <span style="color: #195466; font-weight: bold;">return</span> front + smaller;
}
</pre>
</div>

<p>
This isn't good. The smaller version of the problem keeps dropping off towards negative infinity. Instead of getting <code>... + 3 + 2 + 1</code> we get <code>... + 3 + 2 + 1 + 0 + -1 + -2 + ...</code>. Luckily we already figured out how to check for when we've hit the do-nothing step and we can simply use <code>?:</code> to either return our 0 to make it <code>n+1</code> (our do-nothing step) or our smaller version of the problem.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">front</span> = n;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">smaller</span> = n &lt;= 1 ? 0 : sum(n-1);
  <span style="color: #195466; font-weight: bold;">return</span> front + smaller;
}
</pre>
</div>

<p>
Now our function will stop when we reach the do nothing case and simply return our do-nothing input! Conveniently for <code>sum</code> our combine step is obvious, we just need to add our front to our smaller version of the problem, however this isn't always so obvious.
</p>

<p>
Let's go back to the problem of capitalizing the letters of a string.
</p>

<p>
First we have to find the do-nothing step and input. Unlike numbers, the end of work isn't as clear, but think about it, what is the "zero" value of a string? It's the empty string "", the string with no characters in it. This makes sense because when we broke off the front for <b>"hello"</b> we got a character, and we cannot break off the front for <b>""</b> so that must be our do-nothing input.
</p>

<p>
Knowing this, we can start to fill in the function:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>){
  <span style="color: #d26937;">char</span> <span style="color: #599cab;">front</span> = toupper(s.front());
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = s == <span style="color: #2aa889;">""</span> ? <span style="color: #2aa889;">""</span> : all_caps(A?);
  <span style="color: #195466; font-weight: bold;">return</span> B?;
}
</pre>
</div>

<p>
First, we need to fill hole <code>A?</code>. To do this we need to do the inverse of our breaking off the front step. Instead of trying to grab the first character from the string, we need all the character after the front. In otherwords we need the substring of <code>s</code> from position 1 to the end:
</p>

<div class="org-src-container">

<pre class="src src-cpp">s.substr(1, s.length()-1)
</pre>
</div>

<p>
However, there is a problem. What happens if our string is only one character long? For example, in the string <code>"A"</code>, there is no position <b>1</b> and substr would crash our program trying to grab a character that doesn't exist. Moreover, if <b>s</b> is the empty string, then <b>.front()</b> will crash the program as well! This means we'll have to adjust what our do-nothing input is. Since we have to stop when there is only one character left, we can simply adjust our check to test for a string of at most length <b>1</b>.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>){
  <span style="color: #d26937;">char</span> <span style="color: #599cab;">front</span> = toupper(s.front());
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = s.length() &lt;= 1 ? <span style="color: #2aa889;">""</span> : all_caps(s.substr(1, s.length()-1));
  <span style="color: #195466; font-weight: bold;">return</span> B?;
}
</pre>
</div>

<p>
We can test this by simulating several strings: 
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #2aa889;">"hi"</span>){
  <span style="color: #d26937;">char</span> <span style="color: #599cab;">front</span> = toupper(<span style="color: #2aa889;">"hi"</span>.front());
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = <span style="color: #2aa889;">"hi"</span>.length() &lt;= 1 ? <span style="color: #2aa889;">""</span> : all_caps(<span style="color: #2aa889;">"hi"</span>.substr(1, <span style="color: #2aa889;">"hi"</span>.length()-1));
  <span style="color: #195466; font-weight: bold;">return</span> B?;
}

<span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #2aa889;">"hi"</span>){
  <span style="color: #d26937;">char</span> <span style="color: #599cab;">front</span> = <span style="color: #2aa889;">'H'</span>;
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = <span style="color: #33859e; font-weight: bold;">false</span> ? <span style="color: #2aa889;">""</span> : all_caps(<span style="color: #2aa889;">"i"</span>);
  <span style="color: #195466; font-weight: bold;">return</span> B?;
}
</pre>
</div>

<p>
Strings greater than one seem to work!
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #2aa889;">"A"</span>){
  <span style="color: #d26937;">char</span> <span style="color: #599cab;">front</span> = toupper(<span style="color: #2aa889;">"A"</span>.front());
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = <span style="color: #2aa889;">"A"</span>.length() &lt;= 1 ? <span style="color: #2aa889;">""</span> : all_caps(<span style="color: #2aa889;">"A"</span>.substr(1, <span style="color: #2aa889;">"A"</span>.length()-1));
  <span style="color: #195466; font-weight: bold;">return</span> B?;
}

<span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #2aa889;">"A"</span>){
  <span style="color: #d26937;">char</span> <span style="color: #599cab;">front</span> = <span style="color: #2aa889;">'A'</span>;
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = <span style="color: #33859e; font-weight: bold;">true</span> ? <span style="color: #2aa889;">""</span> : all_caps(...);
  <span style="color: #195466; font-weight: bold;">return</span> B?;
}
</pre>
</div>

<p>
Strings of size one work! Now we just have to fill in the hole B?.
</p>
</div>
</div>

<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> Combining Results</h3>
<div class="outline-text-3" id="text-8-4">
<p>
How can we combine a <b>char</b> value with a <b>string</b>? You can't, but converting a <b>char</b> into a <b>string</b> is straightforward. Just wrap the character with <code>string(1, ...)</code>. This will construct a new string with length <b>1</b> using the provided character.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>){
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">front</span> = string(1, toupper(s.front()));
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = s.length() &lt;= 1 ? s : all_caps(s.substr(1, s.length()-1));
  <span style="color: #195466; font-weight: bold;">return</span> B?;
}
</pre>
</div>

<p>
Now that we have two strings we can simply add them together!
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>){
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">front</span> = string(1, toupper(s.front()));
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = s.length() &lt;= 1 ? s : all_caps(s.substr(1, s.length()-1));
  <span style="color: #195466; font-weight: bold;">return</span> front + smaller;
}
</pre>
</div>

<p>
This looks like the correct answer, but just to be safe, lets test it with the empty string <code>""</code>.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #2aa889;">""</span>){
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">front</span> = string(1, toupper(<span style="color: #2aa889;">""</span>.front()));
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = <span style="color: #2aa889;">""</span>.length() &lt;= 1 ? <span style="color: #2aa889;">""</span> : all_caps(<span style="color: #2aa889;">""</span>.substr(1, <span style="color: #2aa889;">""</span>.length()-1));
  <span style="color: #195466; font-weight: bold;">return</span> front + smaller;
}

<span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #2aa889;">""</span>){
  <span style="color: #d26937;">char</span> <span style="color: #599cab;">front</span> = toupper(<span style="color: #2aa889;">""</span>.front());
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">smaller</span> = <span style="color: #2aa889;">""</span>.length() &lt;= 1 ? <span style="color: #2aa889;">""</span> : all_caps(<span style="color: #2aa889;">""</span>.substr(1, <span style="color: #2aa889;">""</span>.length()-1));
  <span style="color: #195466; font-weight: bold;">return</span> front + smaller;
}

...
</pre>
</div>

<p>
Hopefully you've already spotted the problem. <code>"".front()</code> will crash the program, even though we have a check for strings of length <b>1</b> in the smaller step. This isn't world ending, but it means we can't separate the <b>front</b> and <b>smaller</b> values into variables for ease of reading and we'll have to change our do-nothing step.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>){
  <span style="color: #195466; font-weight: bold;">return</span> s.length() &lt;= 1 ? <span style="color: #2aa889;">""</span> : 
    (string(1, toupper(s.front())) + all_caps(s.substr(1, s.length()-1)));
}
</pre>
</div>

<p>
If we simply move the values from variables directly into the <code>return</code>, we'll accidentally drop the last character of the string. If the input is a string of length <b>1</b> it will return <code>""</code> and not the upper case version of it that we want. To solve this, we'll change the <b>false</b> path of the choice into a duplicate of the front.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>){
  <span style="color: #195466; font-weight: bold;">return</span> s.length() &lt;= 1 ? string(1, toupper(s.front())) : 
    (string(1, toupper(s.front())) + all_caps(s.substr(1, s.length()-1)));
}
</pre>
</div>

<p>
But this is ugly, we've duplicated code, <b>and</b> we've reintroduced the problem of calling <code>.front()</code> on an empty string, so lets pull out the step of converting a character into an uppercase string into an on-the-spot function.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>){
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">f</span> = [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">x</span>) { 
    <span style="color: #195466; font-weight: bold;">return</span> string(1, toupper(x.front())); 
  };
  <span style="color: #195466; font-weight: bold;">return</span> s.length() &lt;= 1 ? f(s) : 
    (f(s) + all_caps(s.substr(1, s.length()-1)));
}
</pre>
</div>

<p>
Now that we've pulled out that step, we can add a check in <b>f</b> to make sure we don't call <code>.front()</code> on an empty string.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">all_caps</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>){
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">f</span> = [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">x</span>) { 
    <span style="color: #195466; font-weight: bold;">return</span> x == <span style="color: #2aa889;">""</span> ? <span style="color: #2aa889;">""</span> : string(1, toupper(x.front())); 
  };
  <span style="color: #195466; font-weight: bold;">return</span> s.length() &lt;= 1 ? f(s) : 
    (f(s) + all_caps(s.substr(1, s.length()-1)));
}
</pre>
</div>

<p>
It won't win any beautiful code awards, but it's definitely more robust than before.
</p>
</div>
</div>

<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5"><span class="section-number-3">8.5</span> Summary</h3>
<div class="outline-text-3" id="text-8-5">
<p>
As you have seen, while going through the steps for writing a recursive function you might have to alter your function to actually cover all of the cases. It is an iterative process where you discover more about the problem as you go, but in general, all recursive problems can be solved this way.
</p>

<p>
There is <b>always</b> some kind of do-nothing input or inputs for which your function either does no work or a single step of the work. Drill the function for small, easy to work with numbers until you find the do-nothing input. Once that is taken care of, we can write a check the inputs to the function for when we reach that do-nothing step. Then we can break off the front of the problem so we only have to do a single step of the problem and then later combine the front result with the solution to a smaller version of the problem.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Recursion with Arrays</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> Typical pattern</h3>
<div class="outline-text-3" id="text-9-1">
<p>
Recursion usually follows this pattern
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #599cab;">function</span>(<span style="color: #d26937;">collection</span> <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">function</span> <span style="color: #599cab;">f</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">index</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> stop_check(index) ? <span style="color: #245361;">// </span><span style="color: #245361;">End the recursion?</span>
           f(elems, index) : <span style="color: #245361;">// </span><span style="color: #245361;">Operation on element </span>
           default_value;    <span style="color: #245361;">// </span><span style="color: #245361;">The base case</span>
}
</pre>
</div>

<p>
The above is psuedo code, not real C++
</p>
</div>
</div>

<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> all</h3>
<div class="outline-text-3" id="text-9-2">
<p>
Design a function that checks if all elements of an array pass a test
</p>

<p>
We can start from the template
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #599cab;">all</span>(<span style="color: #d26937;">collection</span> <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">function</span> <span style="color: #599cab;">f</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">index</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> stop_check(index) ? <span style="color: #245361;">// </span><span style="color: #245361;">End the recursion?</span>
           f(elems, index) : <span style="color: #245361;">// </span><span style="color: #245361;">Operation on element </span>
           default_value;    <span style="color: #245361;">// </span><span style="color: #245361;">The base case</span>
}
</pre>
</div>

<p>
We want the results of the test, so 'all' should return a bool
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">bool</span> <span style="color: #599cab;">all</span>(<span style="color: #d26937;">collection</span> <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">function</span> <span style="color: #599cab;">f</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">index</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> stop_check(index) ? <span style="color: #245361;">// </span><span style="color: #245361;">End the recursion?</span>
           f(elems, index) : <span style="color: #245361;">// </span><span style="color: #245361;">Operation on element </span>
           default_value;    <span style="color: #245361;">// </span><span style="color: #245361;">The base case</span>
}
</pre>
</div>

<p>
We know we're working over an array
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>&gt;
<span style="color: #d26937;">bool</span> <span style="color: #599cab;">all</span>(<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">T</span>, n&gt; <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">function</span> <span style="color: #599cab;">f</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">index</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> stop_check(index) ? <span style="color: #245361;">// </span><span style="color: #245361;">End the recursion?</span>
           f(elems, index) : <span style="color: #245361;">// </span><span style="color: #245361;">Operation on element </span>
           default_value;    <span style="color: #245361;">// </span><span style="color: #245361;">The base case</span>
}
</pre>
</div>

<p>
We use the template to generalize over any type of array and also extract to the size so it will work for any sized array
</p>

<p>
The function needs to take an element of the array and test it so it's signature would be <code>bool(T)</code>
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>&gt;
<span style="color: #d26937;">bool</span> <span style="color: #599cab;">all</span>(<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">T</span>, n&gt; <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">function</span>&lt;<span style="color: #d26937;">bool</span>(<span style="color: #d26937;">T</span>)&gt; <span style="color: #599cab;">f</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">index</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> stop_check(index) ? <span style="color: #245361;">// </span><span style="color: #245361;">End the recursion?</span>
           f(elems, index) : <span style="color: #245361;">// </span><span style="color: #245361;">Operation on element </span>
           default_value;    <span style="color: #245361;">// </span><span style="color: #245361;">The base case</span>
}
</pre>
</div>

<p>
The recursion should stop right before index = n
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>&gt;
<span style="color: #d26937;">bool</span> <span style="color: #599cab;">all</span>(<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">T</span>, n&gt; <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">function</span>&lt;<span style="color: #d26937;">bool</span>(<span style="color: #d26937;">T</span>)&gt; <span style="color: #599cab;">f</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">index</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> index &lt; n ?         <span style="color: #245361;">// </span><span style="color: #245361;">End the recursion?</span>
           f(elems, index) : <span style="color: #245361;">// </span><span style="color: #245361;">Operation on element </span>
           default_value;    <span style="color: #245361;">// </span><span style="color: #245361;">The base case</span>
}
</pre>
</div>
<p>
we don't want to go until exactly n because the index is a position
</p>

<p>
If we assumed there were only two elements we could use &amp;&amp; to combine the results
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>&gt;
<span style="color: #d26937;">bool</span> <span style="color: #599cab;">all</span>(<span style="color: #d26937;">T</span> <span style="color: #599cab;">current</span>, <span style="color: #d26937;">T</span> <span style="color: #599cab;">next</span>, <span style="color: #d26937;">function</span>&lt;<span style="color: #d26937;">bool</span>(<span style="color: #d26937;">T</span>)&gt; <span style="color: #599cab;">f</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> f(current) &amp;&amp; f(next);

</pre>
</div>

<p>
So we can do the same in our recursive step
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>&gt;
<span style="color: #d26937;">bool</span> <span style="color: #599cab;">all</span>(<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">T</span>, n&gt; <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">function</span>&lt;<span style="color: #d26937;">bool</span>(<span style="color: #d26937;">T</span>)&gt; <span style="color: #599cab;">f</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">index</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> index &lt; n ? 
           f(elems.at(index)) &amp;&amp; all(elems, cond, index+1) : 
           default_value;    <span style="color: #245361;">// </span><span style="color: #245361;">The base case</span>
}
</pre>
</div>

<p>
The index must be increase so it accesses the next element
</p>

<p>
Finally we add in the default value
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span>&lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">T</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>&gt;
<span style="color: #d26937;">bool</span> <span style="color: #599cab;">all</span>(<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">T</span>, n&gt; <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">function</span>&lt;<span style="color: #d26937;">bool</span>(<span style="color: #d26937;">T</span>)&gt; <span style="color: #599cab;">f</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">index</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> index &lt; n ? 
           f(elems.at(index)) &amp;&amp; all(elems, f, index+1):
           <span style="color: #33859e; font-weight: bold;">true</span>;
}

<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">int</span>, 5&gt; <span style="color: #599cab;">numbers</span> = { 2,4,6,8,10 };
<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">int</span>, 5&gt; <span style="color: #599cab;">others</span> = { 2,4,5,8,10 };
<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">even</span> = [](<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) { <span style="color: #195466; font-weight: bold;">return</span> n % 2 == 0; };

all(numbers, even, 0); <span style="color: #245361;">// </span><span style="color: #245361;">true </span>
all(others, even, 0);  <span style="color: #245361;">// </span><span style="color: #245361;">false</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> Collections of Unfixed Size</h2>
<div class="outline-text-2" id="text-10">
</div><div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> vectors</h3>
<div class="outline-text-3" id="text-10-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;vector&gt;</span>
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #195466; font-weight: bold;">namespace</span> <span style="color: #33859e; font-weight: bold;">std</span>;

<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">Age</span> = <span style="color: #d26937;">int</span>;
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">Name</span> = string;
<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Person</span> { <span style="color: #d26937;">Age</span> <span style="color: #599cab;">age</span>; <span style="color: #d26937;">Name</span> <span style="color: #599cab;">name</span>; };

<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">TeamName</span> = string;
<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Team</span> { 
  <span style="color: #d26937;">TeamName</span> <span style="color: #599cab;">name</span>; 
  <span style="color: #d26937;">Person</span> <span style="color: #599cab;">captain</span>;

  <span style="color: #245361;">// </span><span style="color: #245361;">instead of having a value for each player</span>
  <span style="color: #245361;">// </span><span style="color: #245361;">use an array to represent the team</span>
  <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">Person</span>&gt; <span style="color: #599cab;">players</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2"><span class="section-number-3">10.2</span> what can vectors do</h3>
<div class="outline-text-3" id="text-10-2">
</div><div id="outline-container-sec-10-2-1" class="outline-4">
<h4 id="sec-10-2-1"><span class="section-number-4">10.2.1</span> the familiar</h4>
<div class="outline-text-4" id="text-10-2-1">
<ul class="org-ul">
<li>.find
</li>
<li>.front
</li>
<li>.back
</li>
<li>.size
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-2-2" class="outline-4">
<h4 id="sec-10-2-2"><span class="section-number-4">10.2.2</span> the new</h4>
<div class="outline-text-4" id="text-10-2-2">
<ul class="org-ul">
<li>.empty
</li>
<li>.erase
</li>
<li>.begin
</li>
<li>.end
</li>
<li><code>.push_back</code>
</li>
<li><code>.pop_back</code>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-10-2-3" class="outline-4">
<h4 id="sec-10-2-3"><span class="section-number-4">10.2.3</span> empty</h4>
<div class="outline-text-4" id="text-10-2-3">
<p>
checks if the vector is empty or not
</p>
</div>
</div>

<div id="outline-container-sec-10-2-4" class="outline-4">
<h4 id="sec-10-2-4"><span class="section-number-4">10.2.4</span> erase</h4>
<div class="outline-text-4" id="text-10-2-4">
<ul class="org-ul">
<li>the opposite of insert, removes the element at the specified location
</li>
<li>note, you cannot use numbers for positions while inserting or erasing with a vector
</li>
<li>vectors require something called an "iterator"
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-10-2-5" class="outline-4">
<h4 id="sec-10-2-5"><span class="section-number-4">10.2.5</span> beging and end</h4>
<div class="outline-text-4" id="text-10-2-5">
<ul class="org-ul">
<li>.begin and .end return iterators to the beginning and end of the vector
</li>
<li>to convert a position into an iterator add or subtract it from either
</li>
</ul>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">numbers</span> = { 1,2,3 };
numbers.erase(numbers.begin() + 1);

<span style="color: #245361;">// </span><span style="color: #245361;">numbers = { 1, 3 };</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-10-2-6" class="outline-4">
<h4 id="sec-10-2-6"><span class="section-number-4">10.2.6</span> push back</h4>
<div class="outline-text-4" id="text-10-2-6">
<p>
inserts an element at the end of the vector
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">ns</span> = { 1,2,3,4 };
ns.push_back(5); <span style="color: #245361;">// </span><span style="color: #245361;">1, 2, 3, 4, 5</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-10-2-7" class="outline-4">
<h4 id="sec-10-2-7"><span class="section-number-4">10.2.7</span> pop back</h4>
<div class="outline-text-4" id="text-10-2-7">
<p>
removes the element at the end of a vector
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">ns</span> = { 1,2,3,4,5 };
ns.pop_back(5); <span style="color: #245361;">// </span><span style="color: #245361;">1, 2, 3, 4</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> New Recursion Techniques</h2>
<div class="outline-text-2" id="text-11">
<ul class="org-ul">
<li>Recursion is hard
</li>
<li>It's complicated
</li>
<li>Can we do better?
</li>
</ul>
</div>

<div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> Examining Past Problems</h3>
<div class="outline-text-3" id="text-11-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">nums</span>) {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">combine</span> = [nums]() <span style="color: #195466; font-weight: bold;">mutable</span> {
   <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span> = nums.front();
   nums.erase(nums.begin());
   <span style="color: #195466; font-weight: bold;">return</span> n + sum(nums);
  };
  <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>nums.empty() ? combine() : 0;
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">product</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">nums</span>) <span style="color: #195466; font-weight: bold;">mutable</span> {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">combine</span> = [nums]() {
   <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span> = nums.front();
   nums.erase(nums.begin());
   <span style="color: #195466; font-weight: bold;">return</span> n * sum(nums);
  };
  <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>nums.empty() ? combine() : 0;
}
</pre>
</div>

<p>
The functions only differ by the operation that combines the elements of the collection.
</p>

<p>
Can this be generalized?
</p>
</div>
</div>

<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2"><span class="section-number-3">11.2</span> Generalizing Sum</h3>
<div class="outline-text-3" id="text-11-2">
<p>
This is the original
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">nums</span>) {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">combine</span> = [nums]() <span style="color: #195466; font-weight: bold;">mutable</span> {
   <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span> = nums.front();
   nums.erase(nums.begin());
   <span style="color: #195466; font-weight: bold;">return</span> n + sum(nums);
  };
  <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>nums.empty() ? combine() : 0;
}
</pre>
</div>

<p>
Following from the five steps for recursion:
</p>
<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<tbody>
<tr>
<td class="text-left">do-nothing input</td>
<td class="text-left">nums.empty()</td>
</tr>

<tr>
<td class="text-left">do-nothing step</td>
<td class="text-left">+ 0</td>
</tr>

<tr>
<td class="text-left">break off the front</td>
<td class="text-left">nums.front()</td>
</tr>

<tr>
<td class="text-left">make problem smaller</td>
<td class="text-left">nums.erase(nums.begin())</td>
</tr>

<tr>
<td class="text-left">combine results</td>
<td class="text-left">n + sum(nums)</td>
</tr>
</tbody>
</table>

<p>
Because our breaking off the front requires modifying <code>nums</code>, we need to use a <code>mutable</code> on-the-spot function for it.
</p>

<p>
The first thing that can be generalized in <code>sum</code> is the operation used to actually combine all of the <code>int</code> values. If we allow for the function to be passed in rather than hard coded, <code>sum</code> can be used for more cases. To pull out the function we can add a template parameter <code>F</code> to represent the function and replace calls to <code>+</code> with <code>f</code>.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">F</span>&gt;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">nums</span>, <span style="color: #d26937;">F</span> <span style="color: #599cab;">f</span>) {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">combine</span> = [nums, f]() <span style="color: #195466; font-weight: bold;">mutable</span> {
   <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span> = nums.front();
   nums.erase(nums.begin());
   <span style="color: #195466; font-weight: bold;">return</span> f(n, sum(nums, f));
  };
  <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>nums.empty() ? combine() : 0;
}
</pre>
</div>

<p>
Now our recursion steps look like this:
</p>
<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<tbody>
<tr>
<td class="text-left">do-nothing input</td>
<td class="text-left">nums.empty()</td>
</tr>

<tr>
<td class="text-left">do-nothing step</td>
<td class="text-left">f(n, 0)</td>
</tr>

<tr>
<td class="text-left">break off the front</td>
<td class="text-left">nums.front()</td>
</tr>

<tr>
<td class="text-left">make problem smaller</td>
<td class="text-left">nums.erase(nums.begin())</td>
</tr>

<tr>
<td class="text-left">combine results</td>
<td class="text-left">f(n, sum(nums))</td>
</tr>
</tbody>
</table>

<p>
If we wanted to use this for a product of numbers instead of a summation, we'll have to change what the default value is, since anything times <code>0</code> is zero. Instead, we can just make that value an input as well.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">F</span>&gt;
<span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">nums</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">init</span>, <span style="color: #d26937;">F</span> <span style="color: #599cab;">f</span>) {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">combine</span> = [nums, f]() <span style="color: #195466; font-weight: bold;">mutable</span> {
   <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span> = nums.front();
   nums.erase(nums.begin());
   <span style="color: #195466; font-weight: bold;">return</span> sum(nums, f(n, init), f));
  };
  <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>nums.empty() ? combine() : init;
}
</pre>
</div>

<p>
By making the default value an input we can actually use that input to "accumulate" our result rather than having to wait until the rest of the vector has been processed before combinging results. In some langauges this can allow for faster and less memory intensive code, but unfortunately C++ doesn't make that optimization. However, it's a good habit to get into the practice of.
</p>

<p>
Now our recursion steps look like this:
</p>
<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<tbody>
<tr>
<td class="text-left">do-nothing input</td>
<td class="text-left">nums.empty()</td>
</tr>

<tr>
<td class="text-left">do-nothing step</td>
<td class="text-left">init</td>
</tr>

<tr>
<td class="text-left">break off the front</td>
<td class="text-left">nums.front()</td>
</tr>

<tr>
<td class="text-left">make problem smaller</td>
<td class="text-left">nums.erase(nums.begin())</td>
</tr>

<tr>
<td class="text-left">combine results</td>
<td class="text-left">f(n, int)</td>
</tr>
</tbody>
</table>

<p>
The next bit of generalizing possible is allowing for the "sum" of types other than only <code>int</code>. There are lots of times when a collection might need to be combined into a single value.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">F</span>&gt;
<span style="color: #d26937;">A</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">A</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">A</span>&gt;&gt; <span style="color: #599cab;">nums</span>, <span style="color: #d26937;">A</span> <span style="color: #599cab;">init</span>, <span style="color: #d26937;">F</span> <span style="color: #599cab;">f</span>) {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">combine</span> = [nums]() {
   <span style="color: #d26937;">A</span> <span style="color: #599cab;">n</span> = nums.front();
   nums.erase(nums.begin());
   <span style="color: #195466; font-weight: bold;">return</span> sum(nums, f(n, init), f));
  };
  <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>nums.empty() ? combine() : init;
}

</pre>
</div>

<p>
Note the ugly <code>vector&lt;A, allocator&lt;A&gt;&gt;</code> type now being used. This is another unfortunate wart of C++. Allocators are a complicated topic, but just know that when you want to generalize over the type of a vector, you'll have to add in the <code>allocator</code> business.
</p>

<p>
What we have so far is fairly general. It can use a function to combine all the elements of a vetor of any type by accumulating results in the <code>init</code> input. However, there is one last generalization that can be made here. What if we want the accumulated result to be a different type than what was initially in the collection? Imagine that you have a <code>vector&lt;int&gt;</code> and want to create a comma seperated <code>string</code> of all the numbers. In that case we'd want to accumulate the results into a <code>string</code> rather than an <code>int</code>. We can accomplish this by adding one more type parameter to <code>sum</code>.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">B</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">F</span>&gt;
<span style="color: #d26937;">B</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">A</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">A</span>&gt;&gt; <span style="color: #599cab;">nums</span>, <span style="color: #d26937;">B</span> <span style="color: #599cab;">init</span>, <span style="color: #d26937;">F</span> <span style="color: #599cab;">f</span>) {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">combine</span> = [nums, init, f]() <span style="color: #195466; font-weight: bold;">mutable</span> {
   <span style="color: #d26937;">A</span> <span style="color: #599cab;">n</span> = nums.front();
   nums.erase(nums.begin());
   <span style="color: #195466; font-weight: bold;">return</span> sum(nums, f(n, init), f);
  };
  <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>nums.empty() ? combine() : init;
}
</pre>
</div>

<p>
There we go! From our initial definition, we now have a recursive function which can combine the elements of any vector into some accumulated value! Infact, the name "sum" doesn't really do justice to what's going on here. In C++, there is actually a version of this function called accumulate.
</p>
</div>
</div>

<div id="outline-container-sec-11-3" class="outline-3">
<h3 id="sec-11-3"><span class="section-number-3">11.3</span> Accumulate</h3>
<div class="outline-text-3" id="text-11-3">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;numeric&gt;</span>
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #195466; font-weight: bold;">namespace</span> <span style="color: #33859e; font-weight: bold;">std</span>;

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>(){
  <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">numbers</span> = {1,2,3,4,5};

  cout &lt;&lt; accumulate(numbers.begin(), numbers.end(), 0,
    [](<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">y</span>) { <span style="color: #195466; font-weight: bold;">return</span> x + y });

  cout &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
The above code would output "15". The difference between our derived version of accumulate and C++'s version is that <code>std::accumulate</code> can actually accumulate chunks of the vector rather than the whole collection. The chunk is specified through the first two inputs. Normally, though, we want to accumulate the whole collection so <code>.begin()</code> and <code>.end()</code> are used.
</p>
</div>
</div>

<div id="outline-container-sec-11-4" class="outline-3">
<h3 id="sec-11-4"><span class="section-number-3">11.4</span> Range</h3>
<div class="outline-text-3" id="text-11-4">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">range</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">start</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">stop</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">continue_range</span> = [start, stop]() {

                <span style="color: #245361;">// </span><span style="color: #245361;">Calculate the rest of the range</span>
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = range(start + 1, stop);

                <span style="color: #245361;">// </span><span style="color: #245361;">Insert the current number before</span>
                <span style="color: #245361;">// </span><span style="color: #245361;">the rest</span>
                rest.insert(rest.begin(), start);

                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };

        <span style="color: #195466; font-weight: bold;">return</span> start &lt; stop ? continue_range() : <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; {start};
}
</pre>
</div>

<p>
Start with the function and it's inputs.
<img src="./images/recursion-with-vectors/range-example/range-example-1.png" class="img-responsive" alt="range-example-1.png">
Replace the function call with its definition and swap out the variables with the given inputs.
<img src="./images/recursion-with-vectors/range-example/range-example-2.png" class="img-responsive" alt="range-example-2.png">
Evaluate the choice on <code>1 &lt; 3</code>. Its true so pick the first value.
<img src="./images/recursion-with-vectors/range-example/range-example-3.png" class="img-responsive" alt="range-example-3.png">
Replace the next call to <code>range</code> with its definition and the variables swapped out.
<img src="./images/recursion-with-vectors/range-example/range-example-4.png" class="img-responsive" alt="range-example-4.png">
Evaluate the choice on <code>2 &lt; 3</code>. Its true, so pick the first value.
<img src="./images/recursion-with-vectors/range-example/range-example-5.png" class="img-responsive" alt="range-example-5.png">
Replace the next call to <code>range</code> with its definition and the variables swapped out.
<img src="./images/recursion-with-vectors/range-example/range-example-6.png" class="img-responsive" alt="range-example-6.png">
Evaluate the choice on <code>3 &lt; 3</code>. Its false, so pick the second value, the vector with only 3 as an element.
<img src="./images/recursion-with-vectors/range-example/range-example-7.png" class="img-responsive" alt="range-example-7.png">
Evaluate the second insert, resulting in the vector <code>{2, 3}</code>.
<img src="./images/recursion-with-vectors/range-example/range-example-8.png" class="img-responsive" alt="range-example-8.png">
Evluate the first insert, resulting in the vector <code>{1, 2, 3}</code>. 
<img src="./images/recursion-with-vectors/range-example/range-example-9.png" class="img-responsive" alt="range-example-9.png">
</p>

<p>
As we can see, range is more of less the opposite of <code>sum</code> from before. Instead of combining all numbers in a vector down to a single result, we use a "seed" value <code>start</code> to grow a vector of <code>int</code> values while some condition is true.
</p>
</div>
</div>

<div id="outline-container-sec-11-5" class="outline-3">
<h3 id="sec-11-5"><span class="section-number-3">11.5</span> Generalizing Range</h3>
<div class="outline-text-3" id="text-11-5">
<p>
Given our success with generalizing <code>sum</code> into the function <code>accumulate</code>, it stands to reason that we can do the same for this function as well.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">range</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">start</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">stop</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">continue_range</span> = [start, stop]() {

                <span style="color: #245361;">// </span><span style="color: #245361;">Calculate the rest of the range</span>
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = range(start + 1, stop);

                <span style="color: #245361;">// </span><span style="color: #245361;">Insert the current number before</span>
                <span style="color: #245361;">// </span><span style="color: #245361;">the rest</span>
                rest.insert(rest.begin(), start);

                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };

        <span style="color: #195466; font-weight: bold;">return</span> start &lt; stop ? continue_range() : <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; {start};
}
</pre>
</div>

<p>
In range, the first thing to generalize is the check for when to stop growing out the list. Note that <code>range</code> only builds lists in the positive direction. If the check is pulled out as a paramter, then it would be possible to use it to grow descending lists as well.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Check</span>&gt;
<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">range</span>(<span style="color: #d26937;">Check</span> <span style="color: #599cab;">cond</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">start</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">stop</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">continue_range</span> = [start, stop]() {

                <span style="color: #245361;">// </span><span style="color: #245361;">Calculate the rest of the range</span>
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = range(start + 1, stop);

                <span style="color: #245361;">// </span><span style="color: #245361;">Insert the current number before</span>
                <span style="color: #245361;">// </span><span style="color: #245361;">the rest</span>
                rest.insert(rest.begin(), start);

                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };

        <span style="color: #195466; font-weight: bold;">return</span> cond(start, stop) ? continue_range() : <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; {start};
}
</pre>
</div>

<p>
Notice that the stop value is never actually used in any part of <code>range</code> except for the check. This implies that we don't actually need to pass it in and can instead assume that <code>cond</code> will already know when it should stop.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Check</span>&gt;
<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">range</span>(<span style="color: #d26937;">Check</span> <span style="color: #599cab;">cond</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">start</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">continue_range</span> = [cond, start]() {

                <span style="color: #245361;">// </span><span style="color: #245361;">Calculate the rest of the range</span>
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = range(start + 1);

                <span style="color: #245361;">// </span><span style="color: #245361;">Insert the current number before</span>
                <span style="color: #245361;">// </span><span style="color: #245361;">the rest</span>
                rest.insert(rest.begin(), start);

                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };

        <span style="color: #195466; font-weight: bold;">return</span> cond(start) ? continue_range() : <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; {start};
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Check</span>&gt;
<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">range</span>(<span style="color: #d26937;">Check</span> <span style="color: #599cab;">cond</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">start</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">continue_range</span> = [cond, start]() {

            <span style="color: #d26937;">int</span> <span style="color: #599cab;">next_start</span> = start + 1;

                <span style="color: #245361;">// </span><span style="color: #245361;">Calculate the rest of the range</span>
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = range(cond, next_start);

                <span style="color: #245361;">// </span><span style="color: #245361;">Insert the current number before</span>
                <span style="color: #245361;">// </span><span style="color: #245361;">the rest</span>
                rest.insert(rest.begin(), start);

                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };

        <span style="color: #195466; font-weight: bold;">return</span> cond(start) ? continue_range() : <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; {start};
}
</pre>
</div>

<p>
In order to make things clearer for the next step, lets pull out creating the next input for <code>start</code> into its own step. Since we don't <b>always</b> want to use <code>+1</code> to generate the next value for <code>start</code>, we should pull out that step as another function.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Expand</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Check</span>&gt;
<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">range</span>(<span style="color: #d26937;">Expand</span> <span style="color: #599cab;">f</span>, <span style="color: #d26937;">Check</span> <span style="color: #599cab;">cond</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">start</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">continue_range</span> = [f, cond, start]() {

            <span style="color: #d26937;">int</span> <span style="color: #599cab;">next_start</span> = f(start);

                <span style="color: #245361;">// </span><span style="color: #245361;">Calculate the rest of the range</span>
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = range(cond, next_start);

                <span style="color: #245361;">// </span><span style="color: #245361;">Insert the current number before</span>
                <span style="color: #245361;">// </span><span style="color: #245361;">the rest</span>
                rest.insert(rest.begin(), start);

                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };

        <span style="color: #195466; font-weight: bold;">return</span> cond(start) ? continue_range() : <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; {start};
}
</pre>
</div>

<p>
Next, we can generalize over the type inside the <code>vector</code>. Just like last time, we need to add on the bit for <code>allocator&lt;A&gt;</code>.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Expand</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Check</span>&gt;
<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">A</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">A</span>&gt;&gt; <span style="color: #599cab;">range</span>(<span style="color: #d26937;">Expand</span> <span style="color: #599cab;">f</span>, <span style="color: #d26937;">Check</span> <span style="color: #599cab;">cond</span>, <span style="color: #d26937;">A</span> <span style="color: #599cab;">start</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">continue_range</span> = [f, cond, start]() {

            <span style="color: #d26937;">A</span> <span style="color: #599cab;">next_start</span> = f(start);

                <span style="color: #245361;">// </span><span style="color: #245361;">Calculate the rest of the range</span>
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = range(f, cond, next_start);

                <span style="color: #245361;">// </span><span style="color: #245361;">Insert the current A before</span>
                <span style="color: #245361;">// </span><span style="color: #245361;">the rest</span>
                rest.insert(rest.begin(), start);

                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };

        <span style="color: #195466; font-weight: bold;">return</span> cond(start) ? continue_range() : 
        <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">A</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">A</span>&gt;&gt; {start};
}
</pre>
</div>

<p>
In order to make <code>range</code> as general as possible we'll need to allow it to grow values of a different type than the original seed given. Just like how accumulate can reduce a collection into a different type, the same capability is useful when growing collections. However, this is a bit more complicated than with accumulate in that, our function for generating the next value for the collection would now have to return <b>two</b> values.
</p>

<p>
For example, if we wanted to generate a list of strings with numbers like <code>{"1", "2", "3", "4"}</code>, we'd want our starting value to be an <code>int</code> value. Given the start though, we'd have to generate a string via <code>to_string()</code> in order to make the next element for the list, but we can't then pass that <code>string</code> as the next input for start, because it must be an <code>int</code>. This implies that our expand step needs to generate <b>both</b> a new value for the collection <b>and</b> the next start/seed value.
</p>

<p>
In order to capture both values we can use the <code>pair</code> type from the standard library. You can make values into a pair by using the function <code>make_pair()</code>. It is a templated function that will take any two values and turn them into a pair. We can then use the <code>get()</code> function from the standard library to access the parts of the pair. <code>get()</code> is templated over the position of the item you want in the pair and is used like this:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">pair</span>&lt;<span style="color: #d26937;">int</span>, <span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">p</span> = make_pair(5, <span style="color: #2aa889;">"five"</span>);
  cout &lt;&lt; <span style="color: #2aa889;">"The first item was the int "</span> &lt;&lt; get&lt;0&gt;(p) &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
  cout &lt;&lt; <span style="color: #2aa889;">"The second item was the string "</span> &lt;&lt; get&lt;1&gt;(p) &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
Note that positions for <code>get()</code> work the same as all other positions, they start from 0. Knowing this, we can modify <code>range</code>.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">B</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Expand</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Check</span>&gt;
<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">B</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">B</span>&gt;&gt; <span style="color: #599cab;">range</span>(<span style="color: #d26937;">Expand</span> <span style="color: #599cab;">f</span>, <span style="color: #d26937;">Check</span> <span style="color: #599cab;">cond</span>, <span style="color: #d26937;">A</span> <span style="color: #599cab;">start</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">continue_range</span> = [f, cond, start]() {

            <span style="color: #d26937;">pair</span>&lt;<span style="color: #d26937;">B</span>,<span style="color: #d26937;">A</span>&gt; <span style="color: #599cab;">next_start</span> = f(start);

                <span style="color: #245361;">// </span><span style="color: #245361;">Calculate the rest of the range</span>
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = range&lt;<span style="color: #d26937;">B</span>&gt;(f, cond, get&lt;1&gt;(next_start));

                <span style="color: #245361;">// </span><span style="color: #245361;">Insert the current B before</span>
                <span style="color: #245361;">// </span><span style="color: #245361;">the rest</span>
                rest.insert(rest.begin(), get&lt;0&gt;(next_start));

                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };

        <span style="color: #195466; font-weight: bold;">return</span> cond(start) ? continue_range() : 
        <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">B</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">B</span>&gt;&gt; {start};
}
</pre>
</div>

<p>
Unfortunately, there is no equivalent of this generalized range function in the C++ standard library. As such we'll give our own name to the function in order to better reflect what it actually does.
</p>
</div>
</div>

<div id="outline-container-sec-11-6" class="outline-3">
<h3 id="sec-11-6"><span class="section-number-3">11.6</span> Grow</h3>
<div class="outline-text-3" id="text-11-6">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span>&lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">B</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Expand</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Check</span>&gt;
<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">B</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">B</span>&gt;&gt; <span style="color: #599cab;">grow</span>(<span style="color: #d26937;">A</span> <span style="color: #599cab;">seed</span>, <span style="color: #d26937;">Check</span> <span style="color: #599cab;">cond</span>, <span style="color: #d26937;">Expand</span> <span style="color: #599cab;">f</span>) {
        <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">expand</span> = [f, cond, seed]() {
                <span style="color: #d26937;">pair</span>&lt;<span style="color: #d26937;">B</span>, <span style="color: #d26937;">A</span>&gt; <span style="color: #599cab;">result</span> = f(seed);
                <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">rest</span> = grow&lt;<span style="color: #d26937;">B</span>&gt;(get&lt;1&gt;(result), cond, f);
                rest.insert(rest.begin(), get&lt;0&gt;(result));
                <span style="color: #195466; font-weight: bold;">return</span> rest;
        };
        <span style="color: #195466; font-weight: bold;">return</span> cond(seed) ? expand() : 
        <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">B</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">B</span>&gt;&gt;{};
}
</pre>
</div>

<p>
To summarize what <code>grow</code> does, it geneates a <code>vector</code> using some starting "seed" value. It accomplishes this by constantly checking if the seed can continue to grow using <code>cond</code>. If the seed can still be grown it will use the expanding function <code>f</code> to generate a new value for the collection and the new seed for the next step. This process will continue until <code>cond</code> fails, in which case it will stop and return a <code>vector</code> of what ever values it grew so far.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">range</span> = unfold&lt;<span style="color: #d26937;">int</span>&gt;(1,
  [](<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>) { <span style="color: #195466; font-weight: bold;">return</span> x &lt;= 10; },
  [](<span style="color: #d26937;">int</span> <span style="color: #599cab;">x</span>) { <span style="color: #195466; font-weight: bold;">return</span> make_pair(x, x+1); });

<span style="color: #245361;">// </span><span style="color: #245361;">1  2  3  4  5  6  7  8  9  10 </span>
for_each(range.begin(), range.end(),
  [](<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">e</span>) { cout &lt;&lt; e &lt;&lt; <span style="color: #2aa889;">" "</span>; });
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11-7" class="outline-3">
<h3 id="sec-11-7"><span class="section-number-3">11.7</span> No More Recursion</h3>
<div class="outline-text-3" id="text-11-7">
<p>
These two functions, <code>accumulate</code> and <code>grow</code>, open the doors to something that wasn't quite possible before. Namely, they allow us to complete <b>avoid</b> having to write recursive functions ourselves in most cases. In fact, when used together, the pattern of growing out a vector and then accumulating it into a result can capture a huge chunk of problems. 
</p>

<p>
For example, if we wanted to sum all of the numbers from some start to some stop, we could accomplish this entirely without writing the recursion ourselves:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">start</span> = -5;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">stop</span> = 100;

  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">numbers</span> = grow&lt;<span style="color: #d26937;">int</span>&gt;(start,
    [stop](<span style="color: #d26937;">int</span> <span style="color: #599cab;">seed</span>) { <span style="color: #195466; font-weight: bold;">return</span> seed &lt;= stop; },
    [](<span style="color: #d26937;">int</span> <span style="color: #599cab;">seed</span>) { <span style="color: #195466; font-weight: bold;">return</span> make_pair(seed, stop); });

  cout &lt;&lt; accumulate(numbers.begin(), numbers.end(), 0,
    [](<span style="color: #d26937;">int</span> <span style="color: #599cab;">result</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">next</span>) { <span style="color: #195466; font-weight: bold;">return</span> result + next; });
  cout &lt;&lt; <span style="color: #2aa889;">"\n"</span>;

  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
While perhaps a bit more verbose that the normal recursive solution would have been, this technique scales well into more complicated problems. In general, we can simply look at the expected type of our problem and pick which functions to use.
</p>

<p>
If we see something of the form:
</p>

<p>
\[T \rightarrow vector(T)\]
</p>

<p>
We can solve it using <code>grow</code>. Likewise, if we see a problem which looks like:
</p>

<p>
\[vector(T) \rightarrow T\]
</p>

<p>
We can solve it with accumulate.
</p>
</div>
</div>

<div id="outline-container-sec-11-8" class="outline-3">
<h3 id="sec-11-8"><span class="section-number-3">11.8</span> Problem Solving with Grow and Accumulate</h3>
<div class="outline-text-3" id="text-11-8">
<p>
Lets say that we had some file which specified what contents needed to be on a webpage. An example of the contents of this file might be:
</p>

<pre class="example">
title: My Website
heading: My Friends
list: Abe, Bill, Clarice, Danica, Edgar
image: https://thumbs.dreamstime.com/b/united-two-friends-guys-28277063.jpg
</pre>

<p>
In this case we'd want to translate the lines into the following html:
</p>
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #599cab;">html</span>&gt;
&lt;<span style="color: #599cab;">header</span>&gt;
 &lt;<span style="color: #599cab;">title</span>&gt;<span style="font-weight: bold; text-decoration: underline;"> My Website </span>&lt;/<span style="color: #599cab;">title</span>&gt;
&lt;/<span style="color: #599cab;">header</span>&gt;
&lt;<span style="color: #599cab;">body</span>&gt;
  &lt;<span style="color: #599cab;">h1</span>&gt;<span style="font-weight: bold; text-decoration: underline;"> My Website </span>&lt;/<span style="color: #599cab;">h1</span>&gt;
  &lt;<span style="color: #599cab;">ul</span>&gt; &lt;<span style="color: #599cab;">li</span>&gt;Abe&lt;/<span style="color: #599cab;">li</span>&gt;&lt;<span style="color: #599cab;">li</span>&gt;Bill&lt;/<span style="color: #599cab;">li</span>&gt;&lt;<span style="color: #599cab;">li</span>&gt;Clarice&lt;/<span style="color: #599cab;">li</span>&gt;&lt;<span style="color: #599cab;">li</span>&gt;Danica&lt;/<span style="color: #599cab;">li</span>&gt;&lt;<span style="color: #599cab;">li</span>&gt;Edgar&lt;/<span style="color: #599cab;">li</span>&gt;&lt;/<span style="color: #599cab;">ul</span>&gt;
  &lt;<span style="color: #599cab;">img</span> <span style="color: #599cab;">src</span>=<span style="color: #2aa889;">"https://thumbs.dreamstime.com/b/united-two-friends-guys-28277063.jpg"</span> /&gt;
&lt;/<span style="color: #599cab;">body</span>&gt;
&lt;/<span style="color: #599cab;">html</span>&gt;
</pre>
</div>

<p>
It is important to note that there many be any number of lines with any order of what kind of html to generate. The results <b>cannot</b> be hard coded before hand. How can we even begin to tackle this problem?
</p>

<p>
The first step is to look at it from a birds eye view. If we had a function which did the conversion for us, what would its type look like?
</p>

<p>
Since we begin with the contents of a file, it has to be a <code>string</code> for the input. Because we need to also output html to a file, the result must also be a <code>string</code>, but to be clear in our planning we can alias <code>string</code> with <code>html</code>. So we can shorthand what happens in the function like this:
</p>

<p>
\[string \rightarrow html\]
</p>

<p>
We start with a <code>string</code> and end up with <code>html</code> (which is really <code>string</code>). Since we can't tackle the entire problem all at once, let's break it down. Its true that we get the contents of the file as a single string, but what we really care about are the <b>lines</b> of the file. In other words, the string is technically not a single value, it is many values separated by newline characters <code>"\n"</code>. So <b>if</b> we had a way to break up the initial value into lines, we could more accurately express the problem as:
</p>

<p>
\[string \rightarrow vector(string) \rightarrow html\]
</p>

<p>
Once we have the lines as a collection we could then think about them individually. How could we take a single line from the file and convert it into the proper html? Assuming we could, our program could now resemble something like:
</p>

<p>
\[string \rightarrow vector(string) \rightarrow vector(html) \rightarrow html\]
</p>

<p>
Notice that the two halves of our program match exactly with our recursion replacements! \(string \rightarrow vector(string)\) can be solved using <code>grow</code> and \(vector(html) \rightarrow html\) can be solved using accumulate. This leaves only the middle step from \(vector(string) \rightarrow vector(html)\) as a complete mystery. 
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;numeric&gt;</span>

<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">html</span> = string;

<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">lines</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">spec</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> grow&lt;<span style="color: #d26937;">string</span>&gt;(???);
}

<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">html</span>&gt; <span style="color: #599cab;">to_html</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">ls</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> ???;
}

<span style="color: #d26937;">html</span> <span style="color: #599cab;">combine_html</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">html</span>&gt; <span style="color: #599cab;">elems</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> accumulate(???);
}

<span style="color: #d26937;">html</span> <span style="color: #599cab;">website</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">spec</span>) {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">spec_lines</span> = lines(spec); 
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">html_lines</span> = to_html(spec_lines);
  <span style="color: #195466; font-weight: bold;">return</span> combine_html(html_lines);
}
</pre>
</div>

<p>
First, let's fill out the <code>lines</code> function. Remember that <code>grow</code> needs three inputs:
</p>
<ul class="org-ul">
<li>a starting <code>seed</code> value from which to grow the collection
</li>
<li>a function which can check the <code>seed</code> to determine if it can still grow
</li>
<li>a function which expands the <code>seed</code> into an element for the collection and a new <code>seed</code>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">lines</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">spec</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> grow&lt;<span style="color: #d26937;">string</span>&gt;(???, ???, ???);
}
</pre>
</div>

<p>
Obviously we need to start with <code>spec</code> as there are no other inputs. 
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">lines</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">spec</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> grow&lt;<span style="color: #d26937;">string</span>&gt;(spec, ???, ???);
}
</pre>
</div>

<p>
We know that the file has separate lines and thus, every line inside of the string is separated by <code>"\n"</code>. Just like with normal recursion, it is useful to figure out the do-nothing input. In terms of grow, the do-nothing input will be what seed stops the growing. Our check then should be something along the lines of "if we are not at the do-nothing value".
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">lines</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">spec</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> grow&lt;<span style="color: #d26937;">string</span>&gt;(spec,
    [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">seed</span>) { <span style="color: #195466; font-weight: bold;">return</span> ???; },
    ???);
}
</pre>
</div>

<p>
So the question is, when should we stop growing the collection? Well, remember that <code>spec</code> will contain all of the lines from the file. If there are no more lines in <code>spec</code>, then we shouldn't do any more work. However, with grow we actually want that last line to be included in the collection. If we make our check only for the existence of a <code>"\n"</code>, then it will stop when it hits the last line and not actually include it. To remedy this, we can make our check for the empty string.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">lines</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">spec</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> grow&lt;<span style="color: #d26937;">string</span>&gt;(spec,
    [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">seed</span>) { <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>seed.empty(); },
    ???);
}
</pre>
</div>

<p>
Remember that the check is to see whether the seed should <b>continue</b> to grow, not whether it should stop. For this reason we negate the result of <code>empty</code> using the <code>!</code> operation.
</p>

<p>
The final input for grow has to be our expand function. This function will take a seed value and generate a pair of a new element for the collection and a new seed value. This process is similar to the normal recursion steps of breaking off the front and making the problem smaller. The element for the list is the front while the next seed is the smaller input to the function.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">lines</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">spec</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> grow&lt;<span style="color: #d26937;">string</span>&gt;(spec,
    [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">seed</span>) { <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>seed.empty(); },
    [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">seed</span>) { <span style="color: #195466; font-weight: bold;">return</span> make_pair(Elem?, Next?); });
}
</pre>
</div>

<p>
Now we have two objectives: <code>Elem?</code> and <code>Next?</code>. We can turn them into functions and solve them separately. For our element, we want only the portion of the string up until the first <code>"\n"</code> or the end of the string if there are none. For the next seed we want the inverse, where everything up to the next <code>"\n"</code> is dropped.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">take_line</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">line</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> ???;
}

<span style="color: #d26937;">string</span> <span style="color: #599cab;">drop_line</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">line</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> ???;
} 

<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">lines</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">spec</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> grow&lt;<span style="color: #d26937;">string</span>&gt;(spec,
    [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">seed</span>) { <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>seed.empty(); },
    [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">seed</span>) { <span style="color: #195466; font-weight: bold;">return</span> make_pair(take_line(seed), drop_line(seed)); });
}
</pre>
</div>

<p>
We can now just fill in the take and drop functions like so:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">take_line</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">line</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">new_line</span> = line.find(<span style="color: #2aa889;">"\n"</span>);
  <span style="color: #195466; font-weight: bold;">return</span> new_line == -1 ? line :
    line.substr(0, new_line);
}

<span style="color: #d26937;">string</span> <span style="color: #599cab;">drop_line</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">line</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">new_line</span> = line.find(<span style="color: #2aa889;">"\n"</span>);
  <span style="color: #195466; font-weight: bold;">return</span> new_line == -1 ? <span style="color: #2aa889;">""</span> :
    line.substr(new_line + 1, line.length()-1);
} 

<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">lines</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">spec</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> grow&lt;<span style="color: #d26937;">string</span>&gt;(spec,
    [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">seed</span>) { <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>seed.empty(); },
    [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">seed</span>) { <span style="color: #195466; font-weight: bold;">return</span> make_pair(take_line(seed), drop_line(seed)); });
}
</pre>
</div>

<p>
And with that we've solved the first third of the program! The accumulate step is much simpler than the grow step in this case. <code>accumulate()</code> needs four inputs: 
</p>
<ul class="org-ul">
<li>where in the collection to begin 
</li>
<li>where in the collection to end 
</li>
<li>a starting accumulation value (same type as the desired result)
</li>
<li>a function which takes the result so far and an element from the collection and combines them into a new result
</li>
</ul>

<p>
Typically we'll always want to accumulate from <code>.begin()</code> to <code>.end()</code>.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">html</span> <span style="color: #599cab;">combine_html</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">html</span>&gt; <span style="color: #599cab;">elems</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> accumulate(elems.begin(), elems.end(), ???, ???);
}
</pre>
</div>

<p>
Since we are accumulating some <code>html</code> (remember its actually just a <code>string</code>), we can begin with the empty string. Note that C++ is dumb and can't figure out that by <code>""</code> you want a string and not a <code>char[]</code> in this case, so write the empty string as <code>string("")</code> to fix this.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">html</span> <span style="color: #599cab;">combine_html</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">html</span>&gt; <span style="color: #599cab;">elems</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> accumulate(elems.begin(), elems.end(), string(<span style="color: #2aa889;">""</span>), ???);
}
</pre>
</div>

<p>
That leaves us with the combination function.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">html</span> <span style="color: #599cab;">combine_html</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">html</span>&gt; <span style="color: #599cab;">elems</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> accumulate(elems.begin(), elems.end(), string(<span style="color: #2aa889;">""</span>), 
    [](<span style="color: #d26937;">html</span> <span style="color: #599cab;">result</span>, <span style="color: #d26937;">html</span> <span style="color: #599cab;">e</span>) { <span style="color: #195466; font-weight: bold;">return</span> ???; });
}
</pre>
</div>

<p>
And in this case, we can just add up the result so far with the element!
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">html</span> <span style="color: #599cab;">combine_html</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">html</span>&gt; <span style="color: #599cab;">elems</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> accumulate(elems.begin(), elems.end(), string(<span style="color: #2aa889;">""</span>), 
    [](<span style="color: #d26937;">html</span> <span style="color: #599cab;">result</span>, <span style="color: #d26937;">html</span> <span style="color: #599cab;">e</span>) { <span style="color: #195466; font-weight: bold;">return</span> result + e; });
}
</pre>
</div>

<p>
So we have now solved two thirds of the problem by using <code>grow</code> and <code>accumulate</code>. We can split up the initial spec string into all of it's lines and once we have all of the correct html elements which correspond to the lines, we can just add them back up into the final result. This means that most of the work from our problem is actually in the \(vector(string) \rightarrow vector(html)\) step. 
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;numeric&gt;</span>

<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">html</span> = string;

<span style="color: #d26937;">string</span> <span style="color: #599cab;">take_line</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">line</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">new_line</span> = line.find(<span style="color: #2aa889;">"\n"</span>);
  <span style="color: #195466; font-weight: bold;">return</span> new_line == -1 ? line :
    line.substr(0, new_line);
}

<span style="color: #d26937;">string</span> <span style="color: #599cab;">drop_line</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">line</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">new_line</span> = line.find(<span style="color: #2aa889;">"\n"</span>);
  <span style="color: #195466; font-weight: bold;">return</span> new_line == -1 ? <span style="color: #2aa889;">""</span> :
    line.substr(new_line + 1, line.length()-1);
} 

<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">lines</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">spec</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> grow&lt;<span style="color: #d26937;">string</span>&gt;(spec,
    [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">seed</span>) { <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>seed.empty(); },
    [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">seed</span>) { <span style="color: #195466; font-weight: bold;">return</span> make_pair(take_line(seed), drop_line(seed)); });
}

<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">html</span>&gt; <span style="color: #599cab;">to_html</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">ls</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> ???;
}

<span style="color: #d26937;">html</span> <span style="color: #599cab;">combine_html</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">html</span>&gt; <span style="color: #599cab;">elems</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> accumulate(elems.begin(), elems.end(), string(<span style="color: #2aa889;">""</span>), 
    [](<span style="color: #d26937;">html</span> <span style="color: #599cab;">result</span>, <span style="color: #d26937;">html</span> <span style="color: #599cab;">e</span>) { <span style="color: #195466; font-weight: bold;">return</span> result + e; });
}

<span style="color: #d26937;">html</span> <span style="color: #599cab;">website</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">spec</span>) {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">spec_lines</span> = lines(spec); 
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">html_lines</span> = to_html(spec_lines);
  <span style="color: #195466; font-weight: bold;">return</span> combine_html(html_lines);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11-9" class="outline-3">
<h3 id="sec-11-9"><span class="section-number-3">11.9</span> Transform</h3>
<div class="outline-text-3" id="text-11-9">
<p>
The last piece of the puzzle is the <code>to_html</code> function. So far we haven't encountered any tools which would let use take a collection and return a collection. Luckily there is a cousin of <code>accumulate</code> called <code>transform</code> which solves exactly this problem.
</p>

<p>
<code>transform</code> needs four things:
</p>
<ul class="org-ul">
<li>where in some collection to start transforming
</li>
<li>where in some collection to stop transforming
</li>
<li>a place to put the transformed values
</li>
<li>a function to transform one element
</li>
</ul>

<p>
As an example, lets try to convert a collection of numbers into a collection of strings.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;iostream&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;string&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;algorithm&gt;</span>
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #195466; font-weight: bold;">namespace</span> <span style="color: #33859e; font-weight: bold;">std</span>;

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">nums</span> = {1,2,3,4,5};
  <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">strs</span>;

  transform(???, ???, ???, ???);

  foreach(strs.begin(), strs.end(),
    [](<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">e</span>) { cout &lt;&lt; e &lt;&lt; <span style="color: #2aa889;">" "</span>; });
  cout &lt;&lt; <span style="color: #2aa889;">"\n"</span>;

  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
As usual, we'll transform the whole collection from <code>.begin()</code> to <code>.end()</code>.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;iostream&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;string&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;algorithm&gt;</span>
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #195466; font-weight: bold;">namespace</span> <span style="color: #33859e; font-weight: bold;">std</span>;

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">nums</span> = {1,2,3,4,5};
  <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">strs</span>;

  transform(nums.begin(), nums.end(), ???, ???);

  foreach(strs.begin(), strs.end(),
    [](<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">e</span>) { cout &lt;&lt; e &lt;&lt; <span style="color: #2aa889;">" "</span>; });
  cout &lt;&lt; <span style="color: #2aa889;">"\n"</span>;

  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
We want to put our results into the new vector <code>strs</code>, however, to make the elements in <code>strs</code> have the same order as in <code>nums</code>, we'll need to use the function <code>back_inserter</code> to tell <code>transform</code> this.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;iostream&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;string&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;algorithm&gt;</span>
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #195466; font-weight: bold;">namespace</span> <span style="color: #33859e; font-weight: bold;">std</span>;

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">nums</span> = {1,2,3,4,5};
  <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">strs</span>;

  transform(nums.begin(), nums.end(), 
    back_inserter(strs), 
    ???);

  foreach(strs.begin(), strs.end(),
    [](<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">e</span>) { cout &lt;&lt; e &lt;&lt; <span style="color: #2aa889;">" "</span>; });
  cout &lt;&lt; <span style="color: #2aa889;">"\n"</span>;

  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
Now we simply need to provide the function that converts a single <code>int</code> value into a single <code>string</code> value. <code>transform</code> will take this function and run it on every element in the range we specified and collect the results in the location provided. In this way, <code>transform</code> lets us reduce the problem of transforming an entire collection of <code>int</code> and <code>string</code> values and instead solve a single step of the problem.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;iostream&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;string&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;algorithm&gt;</span>
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #195466; font-weight: bold;">namespace</span> <span style="color: #33859e; font-weight: bold;">std</span>;

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">int</span>&gt; <span style="color: #599cab;">nums</span> = {1,2,3,4,5};
  <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">strs</span>;

  transform(nums.begin(), nums.end(), 
    back_inserter(strs), 
    [](<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) { <span style="color: #195466; font-weight: bold;">return</span> to_string(n); });

  foreach(strs.begin(), strs.end(),
    [](<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">e</span>) { cout &lt;&lt; e &lt;&lt; <span style="color: #2aa889;">" "</span>; });
  cout &lt;&lt; <span style="color: #2aa889;">"\n"</span>;

  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
More generally, <code>transform</code> lets us solve any problem with the form \(vector(A) \rightarrow vector(B)\) by only solving the problem of \(A \rightarrow B\). In this case we just needed a function that did \(int \rightarrow string\). How can this be applied to the previous problem of converting the lines from the spec file into html? In the same way that we only needed to solve the simpler case when converting numbers into strings, using transform only need to solve the problem of converting a single line into the proper html.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;numeric&gt;</span>

<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #d26937;">html</span> = string;

<span style="color: #d26937;">string</span> <span style="color: #599cab;">take_line</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">line</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">new_line</span> = line.find(<span style="color: #2aa889;">"\n"</span>);
  <span style="color: #195466; font-weight: bold;">return</span> new_line == -1 ? line :
    line.substr(0, new_line);
}

<span style="color: #d26937;">string</span> <span style="color: #599cab;">drop_line</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">line</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">new_line</span> = line.find(<span style="color: #2aa889;">"\n"</span>);
  <span style="color: #195466; font-weight: bold;">return</span> new_line == -1 ? <span style="color: #2aa889;">""</span> :
    line.substr(new_line + 1, line.length()-1);
} 

<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">string</span>&gt; <span style="color: #599cab;">lines</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">spec</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> grow&lt;<span style="color: #d26937;">string</span>&gt;(spec,
    [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">seed</span>) { <span style="color: #195466; font-weight: bold;">return</span> <span style="color: #c23127;">!</span>seed.empty(); },
    [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">seed</span>) { <span style="color: #195466; font-weight: bold;">return</span> make_pair(take_line(seed), drop_line(seed)); });
}

<span style="color: #d26937;">html</span> <span style="color: #599cab;">to_html</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">line</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> ???;
}

<span style="color: #d26937;">html</span> <span style="color: #599cab;">combine_html</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">html</span>&gt; <span style="color: #599cab;">elems</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> accumulate(elems.begin(), elems.end(), string(<span style="color: #2aa889;">""</span>), 
    [](<span style="color: #d26937;">html</span> <span style="color: #599cab;">result</span>, <span style="color: #d26937;">html</span> <span style="color: #599cab;">e</span>) { <span style="color: #195466; font-weight: bold;">return</span> result + e; });
}

<span style="color: #d26937;">html</span> <span style="color: #599cab;">website</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">spec</span>) {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">spec_lines</span> = lines(spec);

  transform(spec_lines.begin(), spec_lines.end(),
    spec_lines.begin(),
    [](<span style="color: #d26937;">string</span> <span style="color: #599cab;">line</span>) { <span style="color: #195466; font-weight: bold;">return</span> to_html(line); });

  <span style="color: #195466; font-weight: bold;">return</span> combine_html(spec_lines);
}
</pre>
</div>

<p>
We can new redefine <code>to_html</code> to only handle a single line from the spec file, rather than the entire collection of lines and replace the creation of a new collection in <code>main</code> with a statement where we use <code>transform</code> on <code>spec_lines</code>. Note that because we aren't technically transforming the collection into a new type, we can just reuse <code>spec_lines</code> as the destination for our transform results.
</p>

<p>
With that taken care of, the only part left to solve is converting a single line of the file, which is left as an exercise to the reader. You'll have to do something similar to this process again for list items, whose elements must be separated out and transformed individually before combining them back into the final html for that line.
</p>
</div>
</div>

<div id="outline-container-sec-11-10" class="outline-3">
<h3 id="sec-11-10"><span class="section-number-3">11.10</span> Summary</h3>
<div class="outline-text-3" id="text-11-10">
<p>
Recursion is a powerful technique, but sometimes writing the recursive functions ourselves can be confusing and tedious. Luckily, C++ is expressive enough to let us generalize over certain types of recursive problems and solve them by only providing the necessary pieces. It turns out that most problems will break down into the pattern of <code>grow</code> then <code>transform</code> then <code>accumulate</code>. There are other such functions which cover different cases, but as a start, these functions can be used to plan out larger tasks that involve collections and reduce the actual code we need to write as programmers to the simple cases that only handle one or two elements from the collections at a time.
</p>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">Problem</th>
<th scope="col" class="text-left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">\(T \rightarrow vector(T)\)</td>
<td class="text-left">grow</td>
</tr>

<tr>
<td class="text-left">\(vector(A) \rightarrow vector(B)\)</td>
<td class="text-left">transform</td>
</tr>

<tr>
<td class="text-left">\(vector(T) \rightarrow T\)</td>
<td class="text-left">accumulate</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> C++ Shortcuts</h2>
<div class="outline-text-2" id="text-12">
<p>
While the tools we have covered so far are capable of doing everything we might want, there are certain situations where they make us work harder than need be. The problem isn't necessarily due to a decifiency with the tools, but rather us trying to make a nail out of everything because we have a good hammer. The vector functions like <code>grow</code>, <code>accumulate</code>, etc. are very well suited for creating and manipulating <b>existing</b> vectors, however in certain situations they make us do more work than is necessary.
</p>

<p>
As a quick review, remember the five pieces to any problem with repeated steps:
</p>
<ul class="org-ul">
<li>Checking for a do-nothing input
</li>
<li>A step for when no more work should be done
</li>
<li>Breaking off the front of the problem
</li>
<li>Solving a smaller version of the problem
</li>
<li>Combining the results from the front and smaller version
</li>
</ul>

<p>
This translates into the general format for recursive functions:
</p>


<figure>
<p><img src="./images/cpp-shortcuts/recursion-schema.svg" class="img-responsive" alt="recursion-schema.svg">
</p>
</figure>

<p>
For example, we can sum number from 1 to n using this function:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> n &gt; 0 ? n + sum(n-1) : 0;
}
</pre>
</div>

<p>
In this case, recursion leads to a short and concise solution. While recursion <b>can</b> solve any problem with repeated steps we might come across, we <b>shouldn't</b> reach for it in every situation. Sometimes, most of the time, there are better tools to use.
</p>
</div>

<div id="outline-container-sec-12-1" class="outline-3">
<h3 id="sec-12-1"><span class="section-number-3">12.1</span> while loops</h3>
<div class="outline-text-3" id="text-12-1">
<p>
There is a class of problems where an action is repeated over and over while a condition remains true. For these kinds of problems we can use something called a <code>while</code> loop.
</p>


<figure>
<p><img src="./images/cpp-shortcuts/while-loop-schema.svg" class="img-responsive" alt="while-loop-schema.svg">
</p>
</figure>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">result</span> = 0;
  <span style="color: #195466; font-weight: bold;">while</span> (n &gt; 0) {
    <span style="color: #d26937;">int</span> <span style="color: #599cab;">front</span> = n;
    n = n -1;
    result = front + result;
  }
  <span style="color: #195466; font-weight: bold;">return</span> result;
}
</pre>
</div>

<p>
Which can be simplified
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">result</span> = 0;
  <span style="color: #195466; font-weight: bold;">while</span> (n &gt; 0) {
    result = n + result;
    n = n - 1;
  }
  <span style="color: #195466; font-weight: bold;">return</span> result;
}
</pre>
</div>

<p>
While this version of <code>sum</code> might be a bit more verbose, they actually solve other problems better. For example, we can express our recursion replacements in terms of while loops.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span>&lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">B</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Expand</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">Check</span>&gt;
<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">B</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">B</span>&gt;&gt; <span style="color: #599cab;">grow</span>(<span style="color: #d26937;">A</span> <span style="color: #599cab;">seed</span>, <span style="color: #d26937;">Check</span> <span style="color: #599cab;">cond</span>, <span style="color: #d26937;">Expand</span> <span style="color: #599cab;">f</span>) {
  <span style="color: #d26937;">pair</span>&lt;<span style="color: #d26937;">B</span>,<span style="color: #d26937;">A</span>&gt; <span style="color: #599cab;">expand</span>;
  <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">B</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">B</span>&gt;&gt; <span style="color: #599cab;">result</span>;
  <span style="color: #195466; font-weight: bold;">while</span> (cond(seed)) {
    expand = f(seed);
    seed = get&lt;1&gt;(expand);
    result.push_back(get&lt;0&gt;(expand));
  }
  <span style="color: #195466; font-weight: bold;">return</span> result;
}
</pre>
</div>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">step</th>
<th scope="col" class="text-left">code</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">do-nothing input</td>
<td class="text-left">!cond(seed)</td>
</tr>

<tr>
<td class="text-left">do-nothing step</td>
<td class="text-left">return result</td>
</tr>

<tr>
<td class="text-left">break off front</td>
<td class="text-left">f(seed)</td>
</tr>

<tr>
<td class="text-left">make problem smaller</td>
<td class="text-left">seed = get&lt;1&gt;(exapnd)</td>
</tr>

<tr>
<td class="text-left">combine results</td>
<td class="text-left">result.push_back(get<0>(expand))</td>
</tr>
</tbody>
</table>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">B</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">F</span>&gt;
<span style="color: #d26937;">B</span> <span style="color: #599cab;">accumulate</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">A</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">A</span>&gt;&gt; <span style="color: #599cab;">nums</span>, <span style="color: #d26937;">B</span> <span style="color: #599cab;">init</span>, <span style="color: #d26937;">F</span> <span style="color: #599cab;">f</span>) {
  <span style="color: #d26937;">B</span> <span style="color: #599cab;">result</span> = init;
  <span style="color: #195466; font-weight: bold;">while</span> (<span style="color: #c23127;">!</span>num.empty()) {
    <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">front</span> = nums.front();
    result = f(result, front);
    nums.erase(0);
  }
  <span style="color: #195466; font-weight: bold;">return</span> result;
}
</pre>
</div>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">step</th>
<th scope="col" class="text-left">code</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">do-nothing input</td>
<td class="text-left">num.empty()</td>
</tr>

<tr>
<td class="text-left">do-nothing step</td>
<td class="text-left">return result</td>
</tr>

<tr>
<td class="text-left">break off front</td>
<td class="text-left">nums.front()</td>
</tr>

<tr>
<td class="text-left">make problem smaller</td>
<td class="text-left">nums.erase(0)</td>
</tr>

<tr>
<td class="text-left">combine results</td>
<td class="text-left">f(result, front)</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-12-2" class="outline-3">
<h3 id="sec-12-2"><span class="section-number-3">12.2</span> for loops</h3>
<div class="outline-text-3" id="text-12-2">
<p>
Another class of problems involve counting. 
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">repeat</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> n &gt; 0 ? s + repeat(s, n-1) : <span style="color: #2aa889;">""</span>;
}
</pre>
</div>

<p>
The alternative to writing recursion for problems repeat for some set amount of times is called a <code>for</code> loop. These kinds of loops are shortcuts for solving this while a <code>while</code> loop.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">repeat</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) {
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">result</span> = s;
  <span style="color: #195466; font-weight: bold;">while</span> (n &gt; 0) {
    result = result + s;
    n = n - 1;
  }
  <span style="color: #195466; font-weight: bold;">return</span> result;
}
</pre>
</div>


<figure>
<p><img src="./images/cpp-shortcuts/for-loop-schema.svg" class="img-responsive" alt="for-loop-schema.svg">
</p>
</figure>

<p>
For example, if we wanted to write a function that will raise a number to the power of five, we <b>could</b> try this with normal recursion, but it would mean writing <b>another</b> function which actually had an input which we can count with and then calling that function.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">power_of_five_impl</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">base</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> n &gt; 0 ? base * power_of_five_impl(base, n-1) : 1;
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">power_of_five</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">base</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> power_of_five_impl(base, 5);
}
</pre>
</div>

<p>
That's <b>way</b> more work than we should have to do. So we could then reach for a <code>while</code> loop:
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">power_of_five</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">base</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span> = 5;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">result</span> = base;
  <span style="color: #195466; font-weight: bold;">while</span> (n &gt; 0) {
    result = result * base; 
    n = n - 1;
  }
  <span style="color: #195466; font-weight: bold;">return</span> result;
}
</pre>
</div>

<p>
We didn't have to write another function, but it is still clunky. <code>for</code> loops let us express this kind of problem more concisely than a <code>while</code> loop because it includes dealing with a counter:
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">power_of_five</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">base</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">result</span> = base;
  <span style="color: #195466; font-weight: bold;">for</span> (<span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span> = 5; n &gt; 0; n--){
    result = result * base; 
  }
  <span style="color: #195466; font-weight: bold;">return</span> result;
}
</pre>
</div>

<p>
Much better! The <code>n--</code> is also a short cut for <code>n = n-1</code>. You can write any kind of assignment statement in that position of the <code>for</code> loop but typically it will be <code>--</code> or <code>++</code>. 
</p>

<p>
In the case of the function \(repeat\), we already have a counter in the input <code>n</code> so we don't actually have to include that in the <code>for</code> loop. Note that the semi-colon <b>still</b> has to be included!
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">repeat</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">s</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">n</span>){
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">result</span> = s;
  <span style="color: #195466; font-weight: bold;">for</span> (; n &gt; 0; i--) {
    result = result + s;
  }
  <span style="color: #195466; font-weight: bold;">return</span> result;
}
</pre>
</div>

<p>
There is a cousin of normal <code>for</code> loops which deals explicitly with collections. The <code>range-based for</code> loop allows us to concisely describe performing an action on every element of something like a <code>vector</code> or an <code>array</code>. 
</p>


<figure>
<p><img src="./images/cpp-shortcuts/range-for-schema.svg" class="img-responsive" alt="range-for-schema.svg">
</p>
</figure>

<p>
For example, if we wanted to add up all the elements in an <code>array&lt;int&gt;</code>, we <b>could</b> use a normal for loop and access every spot in the <code>array</code> using the \(at\) function:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum_array</span>(<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">int</span>, 10&gt; <span style="color: #599cab;">elems</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">result</span> = 0;
  <span style="color: #195466; font-weight: bold;">for</span> (<span style="color: #d26937;">int</span> <span style="color: #599cab;">i</span> = 0; i &lt; 10; i++) {
    result = result + elems.at(i);
  }
  <span style="color: #195466; font-weight: bold;">return</span> result;
}
</pre>
</div>

<p>
However, <code>array</code> defines <code>.begin()</code> and <code>.end()</code> which means we can use a <code>range-based for</code> loop.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">sum_array</span>(<span style="color: #d26937;">array</span>&lt;<span style="color: #d26937;">int</span>, 10&gt; <span style="color: #599cab;">elems</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">result</span> = 0;
  <span style="color: #195466; font-weight: bold;">for</span> (<span style="color: #d26937;">int</span> <span style="color: #599cab;">elem</span> : elems) {
    result = result + elem;
  }
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
This makes problems like defining <code>accumulate</code> <b>much</b> easier:
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">template</span> &lt;<span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">B</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">A</span>, <span style="color: #195466; font-weight: bold;">typename</span> <span style="color: #d26937;">F</span>&gt;
<span style="color: #d26937;">B</span> <span style="color: #599cab;">accumulate</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">A</span>, <span style="color: #d26937;">allocator</span>&lt;<span style="color: #d26937;">A</span>&gt;&gt; <span style="color: #599cab;">elems</span>, <span style="color: #d26937;">B</span> <span style="color: #599cab;">init</span>, <span style="color: #d26937;">F</span> <span style="color: #599cab;">f</span>) {
  <span style="color: #d26937;">B</span> <span style="color: #599cab;">result</span> = init;
  <span style="color: #195466; font-weight: bold;">for</span> (<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">elem</span> : elems) {
    result = f(result, elem);
  }
  <span style="color: #195466; font-weight: bold;">return</span> result;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-12-3" class="outline-3">
<h3 id="sec-12-3"><span class="section-number-3">12.3</span> when to use what</h3>
<div class="outline-text-3" id="text-12-3">

<figure>
<p><img src="./images/cpp-shortcuts/repetition-tool-heirarchy.svg" class="img-responsive" alt="repetition-tool-heirarchy.svg">
</p>
</figure>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">I need to&#x2026;</th>
<th scope="col" class="text-left">tool</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">Build a collection out of a single value</td>
<td class="text-left">grow</td>
</tr>

<tr>
<td class="text-left">Use something simple like + to combine elements</td>
<td class="text-left">accumulate</td>
</tr>

<tr>
<td class="text-left">Remove elements from a collection which don't pass a test</td>
<td class="text-left">remove_if</td>
</tr>

<tr>
<td class="text-left">Do something to every element and use the results later</td>
<td class="text-left">transform</td>
</tr>

<tr>
<td class="text-left">Do something for each element of a collection</td>
<td class="text-left">range-based for</td>
</tr>

<tr>
<td class="text-left">Index a collection</td>
<td class="text-left">for</td>
</tr>

<tr>
<td class="text-left">Repeat action while condition is true</td>
<td class="text-left">while</td>
</tr>

<tr>
<td class="text-left">Everything else</td>
<td class="text-left">recursion</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-12-4" class="outline-3">
<h3 id="sec-12-4"><span class="section-number-3">12.4</span> if statements</h3>
<div class="outline-text-3" id="text-12-4">
<p>
Another point convenience is an alternative to the (? :) syntax. For small, single conditions the ternary operation does fine, but for lots of nested conditions, it becomes a mess to deal with. 
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">return</span> (cond1 ? a : (cond2 ? b : (cond3 ? c : ...)));
</pre>
</div>

<p>
A more painful situation is when you need to decide on whether to change variables or not. Because assignment is a statement and not an expression, you can't return that action using (? :). You'd have to create an on-the-spot function to achieve that.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">insert</span> = [collection]() {
  collection.push_back(input);
  <span style="color: #195466; font-weight: bold;">return</span> collection;
}
<span style="color: #195466; font-weight: bold;">return</span> cond ? insert() : collection;
</pre>
</div>

<p>
For these types of situations, it is easier to use an <code>if statement</code>. These kinds of statements are much like the (? :) syntax, except you aren't picking between two values, rather you are picking between two actions.
</p>


<figure>
<p><img src="./images/cpp-shortcuts/if-statement-schema.svg" class="img-responsive" alt="if-statement-schema.svg">
</p>
</figure>

<p>
This solves the first problem by allowing us to write something like:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">if</span> (cond1) { <span style="color: #195466; font-weight: bold;">return</span> a; }
<span style="color: #195466; font-weight: bold;">else</span> <span style="color: #195466; font-weight: bold;">if</span> (cond2) { <span style="color: #195466; font-weight: bold;">return</span> b; }
<span style="color: #195466; font-weight: bold;">else</span> <span style="color: #195466; font-weight: bold;">if</span> (cond3) { <span style="color: #195466; font-weight: bold;">return</span> c; }
<span style="color: #195466; font-weight: bold;">else</span> ...
</pre>
</div>

<p>
In this case, the if statements are clearer than the choice operation. Where the if statement really shines is with our second problem:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">if</span> (cond) {
  collection.push_back(input);
}

<span style="color: #195466; font-weight: bold;">return</span> collection;
</pre>
</div>

<p>
Now you don't have to make a function on the spot in order to conditionally insert elements or otherwise change variables.
</p>
</div>
</div>

<div id="outline-container-sec-12-5" class="outline-3">
<h3 id="sec-12-5"><span class="section-number-3">12.5</span> First example</h3>
<div class="outline-text-3" id="text-12-5">
<pre class="example">
Problem: Given a sales price and the amount paid, calculate and display the amount of each type of currency used for the change.

Example:

price = 125.27
paid = 200.00

Change amount: 74.73
1 fifty
1 twenty
4 ones
2 quarters
2 dimes
3 pennies
</pre>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">goals</th>
<th scope="col" class="text-left">Done?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">sales price</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">amount paid</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">the change</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">amounts for each type of coin/dollar used</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">calculate (the change)</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">display (the amount for each currency used)</td>
<td class="text-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
The obvious choice for representing money would <code>float</code> or <code>double</code> types, however there are <b>serious</b> problems with that approach. For reason I will not go into here, it is advised to <b>never</b> use floating point types for money and to instead use two <code>int</code> values to represent the dollars and coins.
</p>

<p>
The following video and <a href="https://stackoverflow.com/questions/3730019/why-not-use-double-or-float-to-represent-currency/">this stack overflow answer</a> cover the reasons why.
</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/PZRI1IfStY0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

<p>
So we can start by defining a new type <code>Dollars</code> which represents the number of dollars and cents in the money.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Dollars</span> {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">papers</span>;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">coins</span>;
};
</pre>
</div>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">goals</th>
<th scope="col" class="text-left">Done?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">sales price</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">amount paid</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">the change</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">amounts for each type of coin/dollar used</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">calculate (the change)</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">display (the amount for each currency used)</td>
<td class="text-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Since we also need to eventually break apart the change into the various dollar ammounts and coins used, it would be useful to also define a new type to represent a kind of currency.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Currency</span> {
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>;
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">worth</span>;
};
</pre>
</div>

<p>
So what kinds of currency are there? We have dollar bills ranging from the $100 bill to the $1 bill and then several types of coins. For this project, it will be useful to have both the amount and the name for each of these types of currency. We might be tempted to do something like the following:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">Currency</span> <span style="color: #599cab;">hundreds</span> = { <span style="color: #2aa889;">"hundreds"</span>, {100, 0} };
</pre>
</div>

<p>
Going this route would mean a new variable for each type of currency that we might use in our program. It is a rule of thumb that you want to avoid creating variables if you don't have to, even if they are constants. The reason being is these variables are often not treated separately, but rather belong to a collection. For this task it turns out that writing these currencies in a <code>vector</code> will make things easier for us later.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Dollars</span> {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">papers</span>;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">coins</span>;
};

<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Currency</span> {
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>;
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">worth</span>;
};

<span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">Currency</span>&gt; <span style="color: #599cab;">currency</span> = {
  { <span style="color: #2aa889;">"hundreds"</span>, {100, 0} },
  { <span style="color: #2aa889;">"fifties"</span>, {50, 0} },
  { <span style="color: #2aa889;">"twenties"</span>, {20, 0} },
  { <span style="color: #2aa889;">"tens"</span>, {10, 0} },
  { <span style="color: #2aa889;">"fives"</span>, {5, 0} },
  { <span style="color: #2aa889;">"dollars"</span>, {1, 0} },
  { <span style="color: #2aa889;">"quarters"</span>, {0, 25} },
  { <span style="color: #2aa889;">"dimes"</span>, {0, 10} },
  { <span style="color: #2aa889;">"nickles"</span>, {0, 5}},
  { <span style="color: #2aa889;">"pennies"</span>, {0, 1} }
};
</pre>
</div>

<p>
How might one know ahead of time which approach to take? It's impossible to say for certain whether variables or a single collection is better, but typically if the values are associated, they should be in a collection.
</p>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">goals</th>
<th scope="col" class="text-left">Done?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">sales price</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">amount paid</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">the change</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">amounts for each type of coin/dollar used</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">calculate (the change)</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">display (the amount for each currency used)</td>
<td class="text-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Now that we have our nouns more or less squared away we can start building up the main function. Remember that we have two tasks: calculate the change and break up the change into the different types of coins/dollars used. Let's start with the first one:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">price</span> = {125, 27};
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">paid</span> = {200, 0};
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">change</span> = paid - price;

  cout &lt;&lt; <span style="color: #2aa889;">"Price: "</span> &lt;&lt; price &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
  cout &lt;&lt; <span style="color: #2aa889;">"Paid: "</span> &lt;&lt; paid &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
  cout &lt;&lt; <span style="color: #2aa889;">"Change: "</span> &lt;&lt; change &lt;&lt; <span style="color: #2aa889;">"\n"</span>;

  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
Right off the bat we are struck with two problems. First, there is no defined way to actually subtract to <code>Dollars</code> values. Second, cout only prints out the primitive types by default. So we'll have to add those problems to our goals.
</p>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">goals</th>
<th scope="col" class="text-left">Done?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">sales price</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">amount paid</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">the change</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">amounts for each type of coin/dollar used</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">subtract Dollars values</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">display Dollars values</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">calculate (the change)</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">display (the amount for each currency used)</td>
<td class="text-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
The simpler of the two new goals is displaying a <code>Dollars</code> value, so we'll tackle it first.
</p>

<p>
\[Dollars \rightarrow ???\]
</p>

<p>
We need to somehow convert a <code>Dollars</code> value into one of the primitive types that <code>cout</code> can display. The easiest target (usually) is <code>string</code>. Since a <code>Dollars</code> value is really just two <code>int</code> values so our problem really looks like \((int, int) \rightarrow string\), we can use <code>to_string</code> to convert the numbers into <code>string</code> values and then add them up while putting the usual dot inbetween. 
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">string</span> <span style="color: #599cab;">display_dollars</span>(<span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">x</span>){
  <span style="color: #195466; font-weight: bold;">return</span> to_string(x.papers) + <span style="color: #2aa889;">"."</span> + to_string(x.coins);
}
</pre>
</div>

<p>
Now we can comment out the code which wont work yet and test out our <code>display_dollars</code> function.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;iostream&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;string&gt;</span>
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #195466; font-weight: bold;">namespace</span> <span style="color: #33859e; font-weight: bold;">std</span>;

<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Dollars</span> {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">papers</span>;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">coins</span>;
};

<span style="color: #d26937;">string</span> <span style="color: #599cab;">display_dollars</span>(<span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">x</span>){
  <span style="color: #195466; font-weight: bold;">return</span> to_string(x.papers) + <span style="color: #2aa889;">"."</span> + to_string(x.coins);
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">price</span> = {125, 27};
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">paid</span> = {200, 0};
  <span style="color: #245361;">//</span><span style="color: #245361;">Dollars change = paid - price;</span>

  cout &lt;&lt; <span style="color: #2aa889;">"Price: "</span> &lt;&lt; display_dollars(price) &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
  cout &lt;&lt; <span style="color: #2aa889;">"Paid: "</span> &lt;&lt; display_dollars(paid) &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
  <span style="color: #245361;">//</span><span style="color: #245361;">cout &lt;&lt; "Change: " &lt;&lt; change &lt;&lt; "\n";</span>

  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
This should display:
</p>

<div class="org-src-container">

<pre class="src src-bash">Price: 125.27
Paid: 200.0
</pre>
</div>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">goals</th>
<th scope="col" class="text-left">Done?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">sales price</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">amount paid</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">the change</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">amounts for each type of coin/dollar used</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">subtract Dollars values</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">display Dollars values</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">calculate (the change)</td>
<td class="text-left">&#xa0;</td>
</tr>

<tr>
<td class="text-left">display (the amount for each currency used)</td>
<td class="text-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Okay, now let's tackle subtracting <code>Dollars</code> values. Since we need two <code>Dollars</code> values to subtract and get a new one, the outline for this problem looks like this:
</p>

<p>
\[(Dollars, Dollars) \rightarrow Dollars\]
</p>

<p>
However, just like before, we can make the problem easier to solve be replacing the <code>Dollars</code> type with two <code>int</code> values.
</p>

<p>
\[((int, int), (int, int)) \rightarrow (int, int)\]
</p>

<p>
So what would we need to do in order to subtract the values properly? A first instinct might be to do something like \(subtract (a,b) (c,d) = (a - c, d - b)\), yet there is a problem. What happens if \(b > d\)? We can test this to see what happens: 
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;iostream&gt;</span>
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #195466; font-weight: bold;">namespace</span> <span style="color: #33859e; font-weight: bold;">std</span>;

<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Dollars</span> {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">papers</span>;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">coins</span>;
};

<span style="color: #d26937;">string</span> <span style="color: #599cab;">display_dollars</span>(<span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">x</span>){
  <span style="color: #195466; font-weight: bold;">return</span> to_string(x.papers) + <span style="color: #2aa889;">"."</span> + to_string(x.coins);
}

<span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">minus_dollars</span>(<span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">y</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">ps</span> = x.papers - y.papers;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">cs</span> = x.coins - y.coins;
  <span style="color: #195466; font-weight: bold;">return</span> Dollars{ ps, cs }; 
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">a</span> = {10, 5};
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">b</span> = {5, 10};

  cout &lt;&lt; display_dollars(minus_dollars(a, b)) &lt;&lt; <span style="color: #2aa889;">"\n"</span>;

  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
Which displays:
</p>

<div class="org-src-container">

<pre class="src src-bash">5.-5
</pre>
</div>

<p>
The <code>.coin</code> value of the <code>Dollars</code> would end up negative, which isn't what we want. If it's the case where \(b > d\), then we want to subtract a dollar and subtract the coin amount from 100.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;iostream&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;string&gt;</span>
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #195466; font-weight: bold;">namespace</span> <span style="color: #33859e; font-weight: bold;">std</span>;

<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Dollars</span> {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">papers</span>;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">coins</span>;
};

<span style="color: #d26937;">string</span> <span style="color: #599cab;">display_dollars</span>(<span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">x</span>){
  <span style="color: #195466; font-weight: bold;">return</span> to_string(x.papers) + <span style="color: #2aa889;">"."</span> + to_string(x.coins);
}

<span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">minus_dollars</span>(<span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">y</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">ps</span> = x.papers - y.papers;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">cs</span> = x.coins - y.coins;
  <span style="color: #195466; font-weight: bold;">return</span> cs &gt;= 0 ? Dollars{ ps, cs } : Dollars{ ps - 1, 100 + cs };
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">price</span> = {125, 27};
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">paid</span> = {200, 0};
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">change</span> = minus_dollars(paid, price);

  cout &lt;&lt; <span style="color: #2aa889;">"Price: "</span> &lt;&lt; display_dollars(price) &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
  cout &lt;&lt; <span style="color: #2aa889;">"Paid: "</span> &lt;&lt; display_dollars(paid) &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
  cout &lt;&lt; <span style="color: #2aa889;">"Change: "</span> &lt;&lt; display_dollars(change) &lt;&lt; <span style="color: #2aa889;">"\n"</span>;

  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
Which displays
</p>

<div class="org-src-container">

<pre class="src src-bash">Price: 125.27
Paid: 200.0
Change: 74.73
</pre>
</div>

<p>
Problem solved!
</p>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">goals</th>
<th scope="col" class="text-left">Done?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">sales price</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">amount paid</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">the change</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">amounts for each type of coin/dollar used</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">subtract Dollars values</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">display Dollars values</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">calculate (the change)</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">display (the amount for each currency used)</td>
<td class="text-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Now we only have one goal left to solve. We need to somehow figure out how many of each type of currency (fifty dollar bill, quarter, dollar, penny, etc) can be used to make up the change.
</p>

<p>
The algorithm can be described as followed:
</p>
<ol class="org-ol">
<li>If the value is greater than or equal to $100, subtract $100 from the change, record "1 hundred", and go to step 1
</li>
<li>If the value is greater than or equal to $50, subtract $50 from the change, record "1 fifty", and go to step 1
</li>
<li>If the value is greater than or equal to $20, subtract $20 from the change, record "1 twenty", and go to step 1 
</li>
<li>If the value is greater than or equal to $10, subtract $10 from the change, record "1 ten", and go to step 1 
</li>
<li>If the value is greater than or equal to $5, subtract $5 from the change, record "1 five", and go to step 1 
</li>
<li>If the value is greater than or equal to $1, subtract $1 from the change, record "1 one" and go to step 1  
</li>
<li>If the value is greater than or equal to $0.25, subtract $0.25 from the change, record "1 quarter" and go to step 1 
</li>
<li>If the value is greater than or equal to $0.10, subtract $0.10 from the change, record "1 dime", and go to step 1 
</li>
<li>If the value is greater than or equal to $0.05, subtract $0.05 from the change, record "1 nickle", and go to step 1 
</li>
<li>If the value is greater than or equal to $0.01, subtract $0.01 from the change, record "1 penny", and go to step 1
</li>
<li>Done!
</li>
</ol>

<p>
If that seems horribly tedious and repetitive, that's because it is. Imagine what the code might look like if we tried to just directly write this out! As always, lets try to generalize and break this down into smaller pieces. First, notice the parts of the algorithm which are exactly the same for every step:
</p>

<div class="org-src-container">

<pre class="src src-bash">If the value is greater than or equal to X, subtract X, from the change and record Y, and go to step 1
</pre>
</div>

<p>
This screams a function! So what do we need? We need some <code>Dollars</code> amount for \(X\) and some <code>string</code> for \(Y\). Remember how we eneded up defining our currency?
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Currency</span> {
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>;
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">worth</span>;
};
</pre>
</div>

<p>
It is <b>exactly</b> the type we need for this! That alone doesn't do too much for us though. This algorithm assumes that we have some way of recording which values we see. How would this be done in real life? Probably by just writing down that you've used a certain type of coin? In the end you might get a list like:
</p>

<div class="org-src-container">

<pre class="src src-bash">1 hundred
1 dollar
1 quarter
1 penny
1 penny
</pre>
</div>

<p>
This is just a collection of stuff, so we can use a <code>vector</code> to represent it and since we already figured out that our <code>Currency</code> type matches up with what we need to record, might as well just make it a <code>vector&lt;Currency&gt;</code>. So each step of our algorithm looks a bit like this:
</p>

<p>
\[(Dollars, vector(Currency)) \rightarrow (Dollars, vector(Currency))\]
</p>

<p>
Each step the change gets smaller and the record is updated, so the result is both new values. However, where are we going to get the values to check for at each step? One step has to be $100, then $50, and so on. Remember when we made that <code>vector&lt;Currency&gt;</code> earlier?
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">vector</span>&lt;Currency&gt; <span style="color: #599cab;">currency</span> = {
  { <span style="color: #2aa889;">"hundreds"</span>, {100, 0} },
  { <span style="color: #2aa889;">"fifties"</span>, {50, 0} },
  { <span style="color: #2aa889;">"twenties"</span>, {20, 0} },
  { <span style="color: #2aa889;">"tens"</span>, {10, 0} },
  { <span style="color: #2aa889;">"fives"</span>, {5, 0} },
  { <span style="color: #2aa889;">"dollars"</span>, {1, 0} },
  { <span style="color: #2aa889;">"quarters"</span>, {0, 25} },
  { <span style="color: #2aa889;">"dimes"</span>, {0, 10} },
  { <span style="color: #2aa889;">"nickles"</span>, {0, 5}},
  { <span style="color: #2aa889;">"pennies"</span>, {0, 1} }
};
</pre>
</div>

<p>
So our problem outline will look like this:
</p>

<p>
\[vector(Currency) \rightarrow (Dollars, vector(Currency))\]
</p>

<p>
That's a pattern for accumulate! That being said, accumulate isn't the only solution here. We <b>could</b> use a loop for this as well. Looping over the <code>vector</code> and updating variables is the same as using <code>accumulate</code>. In either case, the steps are similar.
</p>
<ul class="org-ul">
<li>We should stop when there is no more change left, so the do-nothing input is $0.0
</li>
<li>When it's done we should just return our record
</li>
<li>Breaking off the front is just applying our generalized step until it's greater than the change
</li>
<li>To solve the smaller part of the problem we can just repeat the steps using our result from the front
</li>
<li>No real need to combine results, just return the solution
</li>
</ul>

<p>
Translated more into code we get:
</p>
<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">steps</th>
<th scope="col" class="text-left">value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">do-nothing input</td>
<td class="text-left">change == Dollars{0,0}</td>
</tr>

<tr>
<td class="text-left">do-nothing step</td>
<td class="text-left">record</td>
</tr>

<tr>
<td class="text-left">break off the front</td>
<td class="text-left">step(change, record)</td>
</tr>

<tr>
<td class="text-left">make problem smaller</td>
<td class="text-left">used(change, record)</td>
</tr>

<tr>
<td class="text-left">combine results</td>
<td class="text-left">used(change, record)</td>
</tr>
</tbody>
</table>

<p>
Fair enough, but which tool should we use for this? Since there isn't a clear meaning for adding our starting value with an element from the list we'd have to jump through hoops to get accumulate to work with this. That means a loop is probably our best bet. Since we don't know how many times this loop will have to run, we'll use a <code>while</code> loop.
</p>

<p>
So let's begin with what we know so far:
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;Currency&gt; <span style="color: #599cab;">record_coins</span>(<span style="color: #d26937;">Dollarss</span> <span style="color: #599cab;">change</span>) {
  <span style="color: #d26937;">vector</span>&lt;Currency&gt; <span style="color: #599cab;">record</span>;
  <span style="color: #195466; font-weight: bold;">while</span> (change.papers &gt; 0 || change.coins &gt; 0) {
    ???
  }

  <span style="color: #195466; font-weight: bold;">return</span> record;
}
</pre>
</div>

<p>
We know from our do nothing check that we should stop when the change is $0.0, which means the loop should continue while either there are some dollars or some coins left. Since we need to record our values, we create a <code>vector&lt;Currency&gt;</code> and name it appropiately. Since we don't actually care about the change when we finish, we can just return the record.
</p>

<p>
Now we can use our <code>currency</code> collection to implement the steps of the algorithm. In this case, we know exactly how many times we need to loop, since <code>vector</code> values always know their own size, we can use a <code>for</code> loop. Since we want to end up using the whole collection, we can use a <code>range-based for loop</code>.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;Currency&gt; <span style="color: #599cab;">record_coins</span>(<span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">change</span>) {
  <span style="color: #d26937;">vector</span>&lt;Currency&gt; <span style="color: #599cab;">curr_used</span>;
  <span style="color: #195466; font-weight: bold;">while</span> (change.papers &gt; 0 || change.coins &gt; 0) {
    <span style="color: #195466; font-weight: bold;">for</span> (<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">c</span> : currency) {
      ???
    }
  }

  <span style="color: #195466; font-weight: bold;">return</span> curr_used;
}
</pre>
</div>

<p>
Almost there! The <code>for</code> loop will capture doing all the steps and the <code>while</code> loop will capture repeating those steps. Now we need to implement the single step for our algorithm. 
</p>

<div class="org-src-container">

<pre class="src src-bash">If the value is greater than or equal to X, subtract X, from the change and record Y, and go to step 1
</pre>
</div>

<p>
First, we check if the current \(change\) is greater than some <code>Currency</code> \(c\).
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;Currency&gt; <span style="color: #599cab;">record_coins</span>(<span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">change</span>) {
  <span style="color: #d26937;">vector</span>&lt;Currency&gt; <span style="color: #599cab;">curr_used</span>;
  <span style="color: #195466; font-weight: bold;">while</span> (change.papers &gt; 0 || change.coins &gt; 0) {
    <span style="color: #195466; font-weight: bold;">for</span> (<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">c</span> : currency) {
        <span style="color: #195466; font-weight: bold;">if</span> (change.papers &gt;= c.worth.papers &amp;&amp; change.coins &gt;= c.worth.coins) {
          ???
        }
    }
  }

  <span style="color: #195466; font-weight: bold;">return</span> curr_used;
}
</pre>
</div>

<p>
If it is, we can subtract \(c\) from \(change\) and record \(c\) by pushing it into \(record\).
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;Currency&gt; <span style="color: #599cab;">record_coins</span>(<span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">change</span>) {
  <span style="color: #d26937;">vector</span>&lt;Currency&gt; <span style="color: #599cab;">curr_used</span>;
  <span style="color: #195466; font-weight: bold;">while</span> (change.papers &gt; 0 || change.coins &gt; 0) {
    <span style="color: #195466; font-weight: bold;">for</span> (<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">c</span> : currency) {
        <span style="color: #195466; font-weight: bold;">if</span> (change.papers &gt;= c.worth.papers &amp;&amp; change.coins &gt;= c.worth.coins) {
          change = minus_dollars(change, c.worth);
          curr_used.push_back(c);
        }
    }
  }

  <span style="color: #195466; font-weight: bold;">return</span> curr_used;
}
</pre>
</div>

<p>
That almost covers everything except the "and go to step 1" part. How can we simulate this? Well, since our <code>while</code> loop represents repeating all the steps, if we just ending the <code>for</code> loop early via \(break\) we could emulate "go to step 1".
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;Currency&gt; <span style="color: #599cab;">record_coins</span>(<span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">change</span>) {
  <span style="color: #d26937;">vector</span>&lt;Currency&gt; <span style="color: #599cab;">curr_used</span>;
  <span style="color: #195466; font-weight: bold;">while</span> (change.papers &gt; 0 || change.coins &gt; 0) {
    <span style="color: #195466; font-weight: bold;">for</span> (<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">c</span> : currency) {
        <span style="color: #195466; font-weight: bold;">if</span> (change.papers &gt;= c.worth.papers &amp;&amp; change.coins &gt;= c.worth.coins) {
          change = minus_dollars(change, c.worth);
          curr_used.push_back(c);
          <span style="color: #195466; font-weight: bold;">break</span>;
        }
    }
  }

  <span style="color: #195466; font-weight: bold;">return</span> curr_used;
}
</pre>
</div>

<p>
Now we can test this out!
</p>

<div class="org-src-container">

<pre class="src src-bash">Price: 125.27
Paid: 200.0
Change: 74.73
fifties
twenties
dollars
dollars
dollars
dollars
quarters
quarters
dimes
dimes
pennies
pennies
pennies
</pre>
</div>

<p>
That looks about right!
</p>

<p>
Now we just need to count how many of each type of currency exists in the record.
</p>

<p>
We need to take our record <code>vector&lt;Currency&gt;</code> and get another collection which has each type of currency and a count of how many there were in the collection.
</p>

<p>
Abstractly our problem looks like this:
</p>

<p>
\[vector(Currency) \rightarrow vector((Currency, int))\]
</p>

<p>
Because our problem has a shape like \(vector(A) -> vector(B)\) we could use transform for this. But which collection are we transforming? If we transform \(record\), then we won't have access to the other elements so we can't count their occurences. In this case it actually makes more sense to use \(currency\) and for each item use \(record\) to count the occurences.
</p>

<p>
So our step per element looks like this:
\[(vector(Currency), string) \rightarrow int\]
</p>

<p>
We need \(record\) and what type of currency we're looking for. So how exactly can we count repeated items in a collection? Given that \(record\) will contain all the items we want to count, we could just remove all the elements which are not a penny for example and take the length of \(record\) afterwards.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">vector</span>&lt;Currency&gt; <span style="color: #599cab;">filter_coins</span>(<span style="color: #d26937;">vector</span>&lt;Currency&gt; <span style="color: #599cab;">change</span>, <span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">new_end</span> = remove_if(change.begin(), change.end(),
    [name](<span style="color: #d26937;">Currency</span> <span style="color: #599cab;">c</span>) { <span style="color: #195466; font-weight: bold;">return</span> c.name != name; });
  change.erase(new_end, change.end());
  <span style="color: #195466; font-weight: bold;">return</span> change;
}
</pre>
</div>

<p>
We can use <code>remove_if</code> to filter out everything that isn't what we're looking for and return a new collection with only that type of currency. Counting them is simply a matter of getting the size of the result.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">count_coins</span>(<span style="color: #d26937;">vector</span>&lt;Currency&gt; <span style="color: #599cab;">change</span>, <span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> filter_coins(change, name).size();
}
</pre>
</div>

<p>
Alright, now the question is what to use to do the "transform" step. Remember that transform is useful when we actually need to use the results later. So if we used transform we end up creating a new <code>vector</code> of <code>pair</code> values only to loop through it and deconstruct those pairs to print out the values.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">price</span> = {125, 27};
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">paid</span> = {200, 0};
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">change</span> = minus_dollars(paid, price); 

  cout &lt;&lt; <span style="color: #2aa889;">"Price: "</span> &lt;&lt; display_dollars(price) &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
  cout &lt;&lt; <span style="color: #2aa889;">"Paid: "</span> &lt;&lt; display_dollars(paid) &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
  cout &lt;&lt; <span style="color: #2aa889;">"Change: "</span> &lt;&lt; display_dollars(change) &lt;&lt; <span style="color: #2aa889;">"\n"</span>;

  <span style="color: #d26937;">vector</span>&lt;Currency&gt; <span style="color: #599cab;">record</span> = record_coins(change);

  <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">pair</span>&lt;Currency, <span style="color: #d26937;">int</span>&gt;&gt; <span style="color: #599cab;">counts</span>;

  transform(currency.begin(), currency.end(), back_inserter(counts),
    [record](<span style="color: #d26937;">Currency</span> <span style="color: #599cab;">c</span>) { <span style="color: #195466; font-weight: bold;">return</span> make_pair(c, count_coins(record, c.name)); });

  <span style="color: #195466; font-weight: bold;">for</span> (<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">pair</span> : counts) {
    <span style="color: #d26937;">Currency</span> <span style="color: #599cab;">c</span> = get&lt;0&gt;(pair);
    <span style="color: #d26937;">int</span> <span style="color: #599cab;">count</span> = get&lt;1&gt;(pair);
    <span style="color: #195466; font-weight: bold;">if</span> (count &gt; 0) {
      cout &lt;&lt; c.name &lt;&lt; <span style="color: #2aa889;">": "</span> &lt;&lt; count &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
    }
  }

  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
While this could work, it creates more clutter than necessary. In this case it is less cognative load to simply loop over \(currency\) and then get and print the count without creating the pairs and extra collection.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">for</span> (<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">c</span> : currency) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">count</span> = count_coins(record, c.name);
  <span style="color: #195466; font-weight: bold;">if</span> (count &gt; 0) {
    cout &lt;&lt; c.name &lt;&lt; <span style="color: #2aa889;">": "</span> &lt;&lt; count &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
  }
}
</pre>
</div>

<p>
Putting everything together we get:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;iostream&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;string&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;vector&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;numeric&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;algorithm&gt;</span>
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #195466; font-weight: bold;">namespace</span> <span style="color: #33859e; font-weight: bold;">std</span>;

<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Dollars</span> {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">papers</span>;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">coins</span>;
};

<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Currency</span> {
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>;
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">worth</span>;
};

<span style="color: #195466; font-weight: bold;">const</span> <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">Currency</span>&gt; <span style="color: #599cab;">currency</span> = {
  { <span style="color: #2aa889;">"hundreds"</span>, {100, 0} },
  { <span style="color: #2aa889;">"fifties"</span>, {50, 0} },
  { <span style="color: #2aa889;">"twenties"</span>, {20, 0} },
  { <span style="color: #2aa889;">"tens"</span>, {10, 0} },
  { <span style="color: #2aa889;">"fives"</span>, {5, 0} },
  { <span style="color: #2aa889;">"dollars"</span>, {1, 0} },
  { <span style="color: #2aa889;">"quarters"</span>, {0, 25} },
  { <span style="color: #2aa889;">"dimes"</span>, {0, 10} },
  { <span style="color: #2aa889;">"nickles"</span>, {0, 5}},
  { <span style="color: #2aa889;">"pennies"</span>, {0, 1} }
};

<span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">minus_dollars</span>(<span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">x</span>, <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">y</span>) {
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">ps</span> = x.papers - y.papers;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">cs</span> = x.coins - y.coins;

  <span style="color: #195466; font-weight: bold;">return</span> cs &gt;= 0 ? Dollars{ ps, cs } : Dollars{ ps - 1, 100 + cs };
}

<span style="color: #d26937;">string</span> <span style="color: #599cab;">display_dollars</span>(<span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">x</span>){
  <span style="color: #195466; font-weight: bold;">return</span> to_string(x.papers) + <span style="color: #2aa889;">"."</span> + to_string(x.coins);
}

<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">Currency</span>&gt; <span style="color: #599cab;">record_coins</span>(<span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">change</span>) {
  <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">Currency</span>&gt; <span style="color: #599cab;">record</span>;
  <span style="color: #195466; font-weight: bold;">while</span> (change.papers &gt; 0 || change.coins &gt; 0) {
    <span style="color: #195466; font-weight: bold;">for</span> (<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">c</span> : currency) {
        <span style="color: #195466; font-weight: bold;">if</span> (change.papers &gt;= c.worth.papers &amp;&amp; change.coins &gt;= c.worth.coins) {
          change = minus_dollars(change, c.worth);
          record.push_back(c);
          <span style="color: #195466; font-weight: bold;">break</span>;
        }
    }
  }

  <span style="color: #195466; font-weight: bold;">return</span> record;
}

<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">Currency</span>&gt; <span style="color: #599cab;">filter_coins</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">Currency</span>&gt; <span style="color: #599cab;">change</span>, <span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">new_end</span> = remove_if(change.begin(), change.end(),
    [name](<span style="color: #d26937;">Currency</span> <span style="color: #599cab;">c</span>) { <span style="color: #195466; font-weight: bold;">return</span> c.name != name; });
  change.erase(new_end, change.end());
  <span style="color: #195466; font-weight: bold;">return</span> change;
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">count_coins</span>(<span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">Currency</span>&gt; <span style="color: #599cab;">change</span>, <span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>) {
  <span style="color: #195466; font-weight: bold;">return</span> filter_coins(change, name).size();
}

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">price</span> = {125, 27};
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">paid</span> = {200, 0};
  <span style="color: #d26937;">Dollars</span> <span style="color: #599cab;">change</span> = minus_dollars(paid, price); 

  cout &lt;&lt; <span style="color: #2aa889;">"Price: "</span> &lt;&lt; display_dollars(price) &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
  cout &lt;&lt; <span style="color: #2aa889;">"Paid: "</span> &lt;&lt; display_dollars(paid) &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
  cout &lt;&lt; <span style="color: #2aa889;">"Change: "</span> &lt;&lt; display_dollars(change) &lt;&lt; <span style="color: #2aa889;">"\n"</span>;

  <span style="color: #d26937;">vector</span>&lt;<span style="color: #d26937;">Currency</span>&gt; <span style="color: #599cab;">record</span> = record_coins(change);

  <span style="color: #195466; font-weight: bold;">for</span> (<span style="color: #195466; font-weight: bold;">auto</span> <span style="color: #599cab;">c</span> : currency) {
    <span style="color: #d26937;">int</span> <span style="color: #599cab;">count</span> = count_coins(record, c.name);
    <span style="color: #195466; font-weight: bold;">if</span> (count &gt; 0) {
      cout &lt;&lt; c.name &lt;&lt; <span style="color: #2aa889;">": "</span> &lt;&lt; count &lt;&lt; <span style="color: #2aa889;">"\n"</span>;
    }
  }

  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
Which displays:
</p>

<div class="org-src-container">

<pre class="src src-bash">Price: 125.27
Paid: 200.0
Change: 74.73
fifties: 1
twenties: 1
dollars: 4
quarters: 2
dimes: 2
pennies: 3
</pre>
</div>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">goals</th>
<th scope="col" class="text-left">Done?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">sales price</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">amount paid</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">the change</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">amounts for each type of coin/dollar used</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">subtract Dollars values</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">display Dollars values</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">calculate (the change)</td>
<td class="text-left">\(\checkmark\)</td>
</tr>

<tr>
<td class="text-left">display (the amount for each currency used)</td>
<td class="text-left">\(\checkmark\)</td>
</tr>
</tbody>
</table>

<p>
Done!
</p>
</div>
</div>

<div id="outline-container-sec-12-6" class="outline-3">
<h3 id="sec-12-6"><span class="section-number-3">12.6</span> Summary</h3>
<div class="outline-text-3" id="text-12-6">
<p>
The choice of how to represent data is important and impact what tools you can use to solve a problem. While some tools like recursion may be powerful, not everything is a nail. Using the wrong tools ends up creating clutter and unecessary complexity in the problem. As we program it is always important to periodically ask ourselves if we can do better with our solutions. The change making problem could be solved in qute a few ways, but some of those ways are either tedious or to mentally stressful to be viable.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> Objects</h2>
<div class="outline-text-2" id="text-13">
</div><div id="outline-container-sec-13-1" class="outline-3">
<h3 id="sec-13-1"><span class="section-number-3">13.1</span> Making an object</h3>
<div class="outline-text-3" id="text-13-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Person</span> {
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">dollars</span>;
}

<span style="color: #d26937;">Person</span> <span style="color: #599cab;">mk_person</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">dollars</span>){
  <span style="color: #195466; font-weight: bold;">return</span> Person { name, age };
}

<span style="color: #d26937;">Person</span> <span style="color: #599cab;">mk_default_person</span>() {
  <span style="color: #195466; font-weight: bold;">return</span> Person { <span style="color: #2aa889;">""</span>, 0 };
}

</pre>
</div>

<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Person</span> {
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">dollars</span>;

  <span style="color: #599cab;">Person</span> (<span style="color: #d26937;">string</span> <span style="color: #599cab;">n</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">d</span>)
    : name(n), <span style="color: #d26937;">dollars</span>(<span style="color: #599cab;">d</span>) {}

  <span style="color: #599cab;">Person</span>()
    : name(<span style="color: #2aa889;">""</span>), dollars(0) {}
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-13-2" class="outline-3">
<h3 id="sec-13-2"><span class="section-number-3">13.2</span> Dot functions</h3>
<div class="outline-text-3" id="text-13-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Person</span> {
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">dollars</span>;
  <span style="color: #d26937;">function</span>&lt;<span style="color: #d26937;">void</span>(<span style="color: #d26937;">int</span>)&gt; <span style="color: #599cab;">pay</span>;

  <span style="color: #599cab;">Person</span> (<span style="color: #d26937;">string</span> <span style="color: #599cab;">n</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">d</span>)
    : name(n), <span style="color: #d26937;">dollars</span>(<span style="color: #599cab;">d</span>) 
  {
    pay = [<span style="color: #195466; font-weight: bold;">this</span>](<span style="color: #d26937;">int</span> <span style="color: #599cab;">amount</span>) {
      dollars = dollars + amount;
    };
  }

  <span style="color: #599cab;">Person</span>()
    : name(<span style="color: #2aa889;">""</span>), dollars(0)
  {
    pay = [<span style="color: #195466; font-weight: bold;">this</span>](<span style="color: #d26937;">int</span> <span style="color: #599cab;">amount</span>) {
      dollars = dollars + amount;
    };
  }
}
</pre>
</div>


<p>
Full example:
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;iostream&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;functional&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;string&gt;</span>
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #195466; font-weight: bold;">namespace</span> <span style="color: #33859e; font-weight: bold;">std</span>;

<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Person</span> {
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">dollars</span>;

  <span style="color: #599cab;">Person</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">n</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">d</span>)
        : name(name), <span style="color: #d26937;">dollars</span>(<span style="color: #599cab;">d</span>)
  {
    pay = [<span style="color: #195466; font-weight: bold;">this</span>](<span style="color: #d26937;">int</span> <span style="color: #599cab;">amount</span>) {
      dollars = dollars + amount;
    };
  }

  <span style="color: #599cab;">Person</span>()
    : name(<span style="color: #2aa889;">""</span>), dollars(0)
  {
    pay = [<span style="color: #195466; font-weight: bold;">this</span>](<span style="color: #d26937;">int</span> <span style="color: #599cab;">amount</span>) {
      dollars = dollars + amount;
    };
  }
};

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">Person</span> <span style="color: #599cab;">p</span>(<span style="color: #2aa889;">"Iron Man"</span>, 1000000);
  cout &lt;&lt; p.name &lt;&lt; <span style="color: #2aa889;">" is worth "</span> &lt;&lt; p.dollars &lt;&lt; <span style="color: #2aa889;">"\n"</span>;

  p.pay(10);
  cout &lt;&lt; p.name &lt;&lt; <span style="color: #2aa889;">" got paid!\n"</span>;
  cout &lt;&lt; p.name &lt;&lt; <span style="color: #2aa889;">" is now worth "</span> &lt;&lt; p.dollars &lt;&lt; <span style="color: #2aa889;">"\n"</span>;

  system(<span style="color: #2aa889;">"pause"</span>);
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
This can be short handed via:
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Person</span> {
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">dollars</span>;
  <span style="color: #d26937;">function</span>&lt;<span style="color: #d26937;">void</span>(<span style="color: #d26937;">int</span>)&gt; <span style="color: #599cab;">pay</span>;

  <span style="color: #599cab;">Person</span> (<span style="color: #d26937;">string</span> <span style="color: #599cab;">n</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">d</span>)
    : name(name), <span style="color: #d26937;">dollars</span>(<span style="color: #599cab;">d</span>) {}

  <span style="color: #599cab;">Person</span>()
    : name(<span style="color: #2aa889;">""</span>), dollars(0) {}

  <span style="color: #d26937;">void</span> <span style="color: #599cab;">pay</span>(<span style="color: #d26937;">int</span> <span style="color: #599cab;">amount</span>) {
    dollars = dollars + amount;
  }
}
</pre>
</div>

<p>
Full example:
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;iostream&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;functional&gt;</span>
<span style="color: #c23127;">#include</span> <span style="color: #2aa889;">&lt;string&gt;</span>
<span style="color: #195466; font-weight: bold;">using</span> <span style="color: #195466; font-weight: bold;">namespace</span> <span style="color: #33859e; font-weight: bold;">std</span>;

<span style="color: #195466; font-weight: bold;">struct</span> <span style="color: #d26937;">Person</span> {
  <span style="color: #d26937;">string</span> <span style="color: #599cab;">name</span>;
  <span style="color: #d26937;">int</span> <span style="color: #599cab;">dollars</span>;

  <span style="color: #599cab;">Person</span>(<span style="color: #d26937;">string</span> <span style="color: #599cab;">n</span>, <span style="color: #d26937;">int</span> <span style="color: #599cab;">d</span>)
        : name(n), <span style="color: #d26937;">dollars</span>(<span style="color: #599cab;">d</span>) {}

  <span style="color: #599cab;">Person</span>()
    : name(<span style="color: #2aa889;">""</span>), dollars(0)
  {}

  <span style="color: #d26937;">void</span> <span style="color: #599cab;">pay</span> (<span style="color: #d26937;">int</span> <span style="color: #599cab;">amount</span>) {
    dollars = dollars + amount;
  };
};

<span style="color: #d26937;">int</span> <span style="color: #599cab;">main</span>() {
  <span style="color: #d26937;">Person</span> <span style="color: #599cab;">p</span>(<span style="color: #2aa889;">"Iron Man"</span>, 1000000);
  cout &lt;&lt; p.name &lt;&lt; <span style="color: #2aa889;">" is worth "</span> &lt;&lt; p.dollars &lt;&lt; <span style="color: #2aa889;">"\n"</span>;

  p.pay(10);
  cout &lt;&lt; p.name &lt;&lt; <span style="color: #2aa889;">" got paid!\n"</span>;
  cout &lt;&lt; p.name &lt;&lt; <span style="color: #2aa889;">" is now worth "</span> &lt;&lt; p.dollars &lt;&lt; <span style="color: #2aa889;">"\n"</span>;

  system(<span style="color: #2aa889;">"pause"</span>);
  <span style="color: #195466; font-weight: bold;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
</div><div class="col-md-3"><nav id="table-of-contents">
<div id="text-table-of-contents" class="bs-docs-sidebar">
<ul class="nav">
<li><a href="#sec-1">1. Representing Data</a>
<ul class="nav">
<li><a href="#sec-1-1">1.1. Constants</a></li>
<li><a href="#sec-1-2">1.2. Functions</a></li>
<li><a href="#sec-1-3">1.3. templates</a></li>
<li><a href="#sec-1-4">1.4. Summary</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Math Tools</a>
<ul class="nav">
<li><a href="#sec-2-1">2.1. basic math functions</a></li>
<li><a href="#sec-2-2">2.2. representing expressions</a></li>
<li><a href="#sec-2-3">2.3. cmath</a></li>
<li><a href="#sec-2-4">2.4. char math</a></li>
<li><a href="#sec-2-5">2.5. type conversions</a></li>
<li><a href="#sec-2-6">2.6. string math</a></li>
</ul>
</li>
<li><a href="#sec-3">3. String Tools</a>
<ul class="nav">
<li><a href="#sec-3-1">3.1. find length of string</a></li>
<li><a href="#sec-3-2">3.2. accessing parts of a string</a></li>
<li><a href="#sec-3-3">3.3. modifying a string</a></li>
<li><a href="#sec-3-4">3.4. searching a string</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Choice and Decision Tools</a>
<ul class="nav">
<li><a href="#sec-4-1">4.1. how to make a decision?</a></li>
<li><a href="#sec-4-2">4.2. using comparisons to change result of function</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Variables and Scope</a>
<ul class="nav">
<li><a href="#sec-5-1">5.1. A Name and a Box</a></li>
<li><a href="#sec-5-2">5.2. The auto Keyword</a></li>
<li><a href="#sec-5-3">5.3. Assignment</a></li>
<li><a href="#sec-5-4">5.4. Variables can be Assigned to Eachother</a></li>
<li><a href="#sec-5-5">5.5. Function Evaluation and Scope</a></li>
<li><a href="#sec-5-6">5.6. References</a></li>
<li><a href="#sec-5-7">5.7. Pointers</a></li>
<li><a href="#sec-5-8">5.8. Side effects</a></li>
<li><a href="#sec-5-9">5.9. When to use Variables?</a></li>
<li><a href="#sec-5-10">5.10. When to not use Variables</a></li>
</ul>
</li>
<li><a href="#sec-6">6. Functions as Values</a>
<ul class="nav">
<li><a href="#sec-6-1">6.1. C++ function variables</a></li>
<li><a href="#sec-6-2">6.2. lambda capture</a></li>
<li><a href="#sec-6-3">6.3. passing functions to other functions</a></li>
<li><a href="#sec-6-4">6.4. what are the uses of lambdas?</a></li>
</ul>
</li>
<li><a href="#sec-7">7. Collections of Fixed Size</a>
<ul class="nav">
<li><a href="#sec-7-1">7.1. accessing array elements</a></li>
<li><a href="#sec-7-2">7.2. modifying array elements</a></li>
<li><a href="#sec-7-3">7.3. warning</a></li>
<li><a href="#sec-7-4">7.4. Better array type</a></li>
</ul>
</li>
<li><a href="#sec-8">8. Recursion</a>
<ul class="nav">
<li><a href="#sec-8-1">8.1. Finding the do-nothing step and input</a></li>
<li><a href="#sec-8-2">8.2. Breaking off the front</a></li>
<li><a href="#sec-8-3">8.3. Making the problem smaller</a></li>
<li><a href="#sec-8-4">8.4. Combining Results</a></li>
<li><a href="#sec-8-5">8.5. Summary</a></li>
</ul>
</li>
<li><a href="#sec-9">9. Recursion with Arrays</a>
<ul class="nav">
<li><a href="#sec-9-1">9.1. Typical pattern</a></li>
<li><a href="#sec-9-2">9.2. all</a></li>
</ul>
</li>
<li><a href="#sec-10">10. Collections of Unfixed Size</a>
<ul class="nav">
<li><a href="#sec-10-1">10.1. vectors</a></li>
<li><a href="#sec-10-2">10.2. what can vectors do</a></li>
</ul>
</li>
<li><a href="#sec-11">11. New Recursion Techniques</a>
<ul class="nav">
<li><a href="#sec-11-1">11.1. Examining Past Problems</a></li>
<li><a href="#sec-11-2">11.2. Generalizing Sum</a></li>
<li><a href="#sec-11-3">11.3. Accumulate</a></li>
<li><a href="#sec-11-4">11.4. Range</a></li>
<li><a href="#sec-11-5">11.5. Generalizing Range</a></li>
<li><a href="#sec-11-6">11.6. Grow</a></li>
<li><a href="#sec-11-7">11.7. No More Recursion</a></li>
<li><a href="#sec-11-8">11.8. Problem Solving with Grow and Accumulate</a></li>
<li><a href="#sec-11-9">11.9. Transform</a></li>
<li><a href="#sec-11-10">11.10. Summary</a></li>
</ul>
</li>
<li><a href="#sec-12">12. C++ Shortcuts</a>
<ul class="nav">
<li><a href="#sec-12-1">12.1. while loops</a></li>
<li><a href="#sec-12-2">12.2. for loops</a></li>
<li><a href="#sec-12-3">12.3. when to use what</a></li>
<li><a href="#sec-12-4">12.4. if statements</a></li>
<li><a href="#sec-12-5">12.5. First example</a></li>
<li><a href="#sec-12-6">12.6. Summary</a></li>
</ul>
</li>
<li><a href="#sec-13">13. Objects</a>
<ul class="nav">
<li><a href="#sec-13-1">13.1. Making an object</a></li>
<li><a href="#sec-13-2">13.2. Dot functions</a></li>
</ul>
</li>
</ul>
</div>
</nav>
</div></div></div>
</body>
</html>
